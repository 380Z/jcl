@@PWideCharOrNil
<GROUP BaseServices.Pointermanipulation>
Summary:
  Explicit replacement for PWideChar typecast.
Description:
  PWideCharOrNil returns a pointer to the first character of the specified string
  or nil of the string is empty. This is identical to simply typecasting to
  PWideChar except that this function makes the behaviour of the typecast explicit
   (and independent of the compiler).
Parameters:
  S - The string for which to return a PWideChar.
Result:
  If the specified string is empty the funtion returns nil, otherwise it returns
  a pointer to the first character of the string.
Quick info:
  Unit: JclSysUtils
  Category: Base Services
  Donator: Petr Vones
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@PCharOrNil
<GROUP BaseServices.Pointermanipulation>
Summary:
  Explicit replacement for PChar typecast.
Description:
  PCharOrNil returns a pointer to the first character of the specified string or
  nil if the string is empty. This is identical to simply typecasting to PChar
  except that this function makes the behaviour of the typecast explicit (and
  independent of the compiler).
Parameters:
  S - The string for which to return a PChar.
Result:
  If the specified string is empty the funtion returns nil, otherwise it returns
  a pointer to the first character of the string.
Quick info:
  Unit: JclSysUtils
  Category: Base Services
  Donator: Petr Vones
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@IntToStrZeroPad
<GROUP BaseServices.Numericformattingroutines>
Summary:
  Converts an integer to a string an left pads it with zero's.
Description:
  IntToStrZeroPad converts the specified integer value to a string containing the
  decimal representation of that number and left pads it with zero's if the
  resulting string is less than the specified number of characters.
Parameters:
  Value - The integer value to convert to a string.
  Count - The number of characters in the resulting string. If the string is less than the specified number, the string is left padded with zero's until the string is the specified number of characters long.
Result:
  The string representation of the specified integer value, left padded with zero's.
  I don't know of any input that can cause this function to fail, but in the
  unlikely event that it does, it does so by raising an exception.
Quick info:
  Unit: JclSysUtils
  Category: Base Services
  Donator: Anthony Steele
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@Iff
<GROUP BaseServices>
Summary:
  Replacement for the C++ ternary conditional operator.
Description:
  Iff is a replacement for the C/C++ ternary conditional operator ?:. It evaluates
  the specified boolean expression and depending on the outcome returns either
  the specified TruePart or FalsePart parameter.
  The difference to the C/C++ operator is that both expressions are evaluated.
Parameters:
  Condition - The expression which determines which of the other parameters is returned as the function result.
  TruePart - The function result if Condition evaluates to True.
  FalsePart - The function result if Condition evaluates to False.
Result:
  If Condition evaluates to True TruePart is returned, otherwise FalsePart is returned.
Quick info:
  Unit: JclSysUtils
  Category: Base Services
  Donator: Bernhard Berger
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@SizeOfMem
<GROUP MemoryClassesandObjects.Pointermanipulation>
Summary:
  Returns the size of a memory block given a pointer.
Description:
  SizeOfMem returns the size of the memory block pointed to by the specified pointer.
  This routine depends on information peeked from the standard Delphi memory manager
  implemention (in GetMem.inc) and will not work when a custom memory manager
  replacement is in use. Also, it will only work for memory allocated using the
  AllocMem, GetMem and New routines; that is, using the Delphi memory manager.
Parameters:
  P - Pointer to the memory block whose size to retrieve.
Result:
  The total size of the memory block pointed to by P. Note that the current
  implementation uses a 4 byte header to store some additonal information (such as
  the size) about the memory block. These 4 bytes are included in the result. To get
  the size of the block available to the user (the size specified when the block
  was allocated) simply subtract 4. If the function fails to determine the size of
  the memory, for example because it detected that the Delphi memory manager was
  replaced by a custom memory manager, it returns -1.
Quick info:
  Unit: JclSysUtils
  Category: Memory, Classes and Objects
  Donator: Robert R. Marsh
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@FreeAndNil
<GROUP MemoryClassesandObjects.Pointermanipulation>
Summary:
  Frees an object reference and replaces it with nil.
Description:
  FreeAndNil frees the object instance pointed to by Obj and replaces the reference
  with nil. This ensures that the reference is nil after the object has been
  destroyed and helps debugging. Do not use this routine on objects or generic
  pointers which are not TObject descendants. For generic pointers you can use
  the FreeMemAndNil procedure.
Parameters:
  Obj - Reference to an instance of a TObject descendant to free. Upon return the Obj variable has been reset to nil so future references ensure a relatively easy to understand access violation.
Quick info:
  Unit: JclSysUtils
  Category: Memory, Classes and Objects
  Donator: Marcel van Brakel
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@FreeMemAndNil
<GROUP MemoryClassesandObjects.Pointermanipulation>
Summary:
  Frees a block of memory and sets the reference to nil.
Description:
  FreeMemAndNil frees the memory pointed to by P and replaces the reference
  with nil. This ensures that the reference is nil after the memory has been
  released and helps debugging. Do not use this routine on objects or TObject
  descendants. For TObject (descendants) you can use the FreeAndNil procedure.
Parameters:
  P - Reference to the memory block to release. Upon return the P variable has been reset to nil so future references ensure a relatively easy to understand access violation.
Quick info:
  Unit: JclSysUtils
  Category: Memory, Classes and Objects
  Donator: Marcel van Brakel
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@GetAndFillMem
<GROUP MemoryClassesandObjects.Pointermanipulation>
Summary:
  Allocates memory and fills it with the specified value.
Description:
  GetAndFillMem allocates a block of memory from the heap of the specified size
  and fills each byte in that block with the specified value.
Parameters:
  P - Receives a pointer to the allocated memory block.
  Size - Size, in bytes, of the block of memory to allocate.
  Value - Value with which to fill the memory block.
Quick info:
  Unit: JclSysUtils
  Category: Memory, Classes and Objects
  Donator: Marcel van Brakel
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@GetVirtualMethodCount
<GROUP MemoryClassesandObjects.ClassManipulation.VMT>
Summary:
  Returns the number of virtual methods of a class.
Description:
  GetVirtualMethodCount returns the number of virtual methods of the specified
  class. This includes the methods declared in the class itself and all its
  parent classes. However, the result does not include the virtual methods declared
  in TObject. The result includes all abstract methods.
Parameters:
  AClass - The class for which to get the number of virtual methods.
Result:
  The number of virtual methods of the given class.
Quick info:
  Unit: JclSysUtils
  Category: Memory, Classes and Objects
  Donator: Python
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@GetVirtualMethod
<GROUP MemoryClassesandObjects.ClassManipulation.VMT>
Summary:
  Returns a pointer to the virtual method from the specified class with the given index.
Description:
  Returns the virtual method from the specified class with the given index. There
  is no checking performed that the given index actually is a virtual method, and the
  return value is undefined for invalid indices.
Parameters:
  AClass - The class for which to get a virtual method.
  Index - The index of the virtual method to be retrieved. If the index is invalid the result is undefined. Valid indices are 0 to GetVirtualMethodCount - 1.
Result:
  The result is a pointer to the virtual method. If the method is an abstract
  method the value returned is a pointer to System._AbstractError.
Quick info:
  Unit: JclSysUtils
  Category: Memory, Classes and Objects
  Donator: Python
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@SetVirtualMethod
<GROUP MemoryClassesandObjects.ClassManipulation.VMT>
Summary:
  Changes a virtual method to the given method.
Description:
  Changes a virtual method to the given method.<P><FONT color=red>Do <B>NOT</B>
  use this function.</FONT> There should be no need to use this function
  unless your implementing a very dirty hack. <P>There is no checking
  performed that the Index is a valid virtual method index. The function only
  changes the pointer in the VMT of the specified class, not the static references
  to this method, which are made when an anchestor uses inherited to call the virtual
  method. This procedure changes the executable code (with the risk of completly
  destroying your application) and uses WriteProcessMemory to accomplish that.
  The function is multiprocessor safe.
Parameters:
  AClass - The class for which to set a virtual method.
  Index - The index of the virtual method to be set.
  Method - The new address of the virtual method.
Quick info:
  Unit: JclSysUtils
  Category: Memory, Classes and Objects
  Donator: Python
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@GetDynamicMethodCount
<GROUP MemoryClassesandObjects.ClassManipulation.DMT>
Summary:
  Returns the number of dynamic methods of a class.
Description:
  GetDynamicMethodCount returns the number of dynamic methods for the specified
  class (including abstract methods). This only includes dynamic methods declared
  in the class itself, not the methods delcared in ancestor classes.
Parameters:
  AClass - The class for which to get the number of dynamic methods.
Result:
  The number of dynamic methods of the specified class.
Quick info:
  Unit: JclSysUtils
  Category: Memory, Classes and Objects
  Donator: Python
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@GetDynamicIndexList
<GROUP MemoryClassesandObjects.ClassManipulation.DMT>
Summary:
  Returns the list of indices of the dynamic methods.
Description:
  Returns the list of indices for the dynamic methods, not including the indices
  of the dynamic methods from inherited classes.
  Use this list in combination with GetDynamicAddressList
  and GetDynamicMethodCount to get all dynamic methods with their indices.
  The number of entries in the returned array that contain meaningful data is
  returned by GetDynamicMethodCount. The returned pointer points directly
  into the class structure and should not be modified.
Parameters:
  AClass - The class for which to get dynamic method index list.
Result:
  Pointer to an array containing the indices. Do not modify this array!
Quick info:
  Unit: JclSysUtils
  Category: Memory, Classes and Objects
  Donator: Python
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@TDynamicIndexList
<GROUP MemoryClassesandObjects.ClassManipulation.DMT>
Summary:
  List of valid indices in a dynamic method table.
Description:
  List of indices of valid entries in a dynamic method table. Use GetDynamicMethodCount
  to get the count of valid entries in this list.
Quick info:
  Unit: JclSysUtils
  Category: Memory, Classes and Objects
  Donator: Python
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@GetDynamicAddressList
<GROUP MemoryClassesandObjects.ClassManipulation.DMT>
Summary:
  Returns the list of addresses for the dynamic methods of a class.
Description:
  Returns the list of addresses for the dynamic methods of the specified class.
  Use this list in combination with GetDynamicIndexList
  and GetDynamicMethodCount to get all dynamic methods and their indices.
  The number of entries in the returned array that contain meaningful data is
  returned by GetDynamicMethodCount. The returned pointer points directly into
  the class structure and should not be modified.
Parameters:
  AClass - The class for which to get dynamic method address list.
Result:
  Pointer to an array containing the addresses. Do not modify this array!
Quick info:
  Unit: JclSysUtils
  Category: Memory, Classes and Objects
  Donator: Python
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@TDynamicAddressList
<GROUP MemoryClassesandObjects.ClassManipulation.DMT>
Summary:
  List of addresses of a dynamic methods
Description:
  List of addresses of the dynamic methods, use GetDynamicMethodCount
  to get the indices of valid entries in the list.
Quick info:
  Unit: JclSysUtils
  Category: Memory, Classes and Objects
  Donator: Python
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@HasDynamicMethod
<GROUP MemoryClassesandObjects.ClassManipulation.DMT>
Summary:
  Test if the class (or one of its ancestors) has a dynamic method with the given index.
Description:
  Test if the class (or one of its ancestors) has a dynamic method with the given index.
Parameters:
  AClass - The class for which to test for the dynamic method.
  Index - The index for which to test.
Result:
  If the class contains a dynamic method with the given index the result is True,
  otherwise the result is False.
Quick info:
  Unit: JclSysUtils
  Category: Memory, Classes and Objects
  Donator: Python
  Delphi Versions: 4,5
--------------------------------------------------------------------------------
@@GetDynamicMethod
<GROUP MemoryClassesandObjects.ClassManipulation.DMT>
Summary:
  Returns a pointer to a specific dynamic method.
Description:
  Returns (the most recent version of) the dynamic method with the given index.
  If there is no dynamic method with the given index an abstract error will be
  raised, however, if the dynamic method is an abstract method,
  System._AbstractError is returned.
Parameters:
  AClass - The class for which to get the dynamic method.
  Index - The index for which to get.
Result:
  Returns a pointer to the dynamic method, or System._AbstractError if the
  dynamic method is an abstract method.
Quick info:
  Unit: JclSysUtils
  Category: Memory, Classes and Objects
  Donator: Python
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@GetInitTable
<GROUP MemoryClassesandObjects.ClassManipulation.DMT>
Summary:
  Returns the initialization table of a class.
Description:
  GetInitTable returns the initialization table of the specified class.
  TODO This is abracadabra to me :-) Need to contact author for further explanation
  about this (eg what does the init table look like).
  The initialization table is a record type info, from which the size is set to zero, but
  still has info about the fields which needs to be initialized, but only for
  the fields not already existing in an inherited class. It is used when a new
  object is created to initialize its fields.
Parameters:
  AClass - The class for which to get the initialization table.
Result:
  The result is a pointer to the initialization table. Do not modify this structure!
Quick info:
  Unit: JclSysUtils
  Category: Memory, Classes and Objects
  Donator: Python
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@GetFieldTable
<GROUP MemoryClassesandObjects.ClassManipulation.DMT>
Summary:
  Returns the field table of a class.
Description:
  GetFieldTable returns a pointer to the field table of the specified class.
  A field table contains information about the published fields in a class.
Parameters:
  AClass - The class for which to retrieve the field table.
Result:
  Pointer to the field table. Do not modify this structure!
Quick info:
  Unit: JclSysUtils
  Category: Memory, Classes and Objects
  Donator: Python
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@TFieldTable
<GROUP MemoryClassesandObjects.ClassManipulation.DMT>
Summary:
  TODO
Description:
  TODO
Quick info:
  Unit: JclSysUtils
  Category: Memory, Classes and Objects
  Donator: Python
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
@@TFieldTable.EntryCount
  Number of entries in the field table.
@@TFieldTable.FieldClassTable
  Table with classes, used by the entries IDX property.
@@TFieldTable.FirstEntry
  First entry (if it exists), this is a variable length structure.
--------------------------------------------------------------------------------
@@TFieldClassTable
<GROUP MemoryClassesandObjects.ClassManipulation.DMT>
Summary:
  List of classes used by the fields entries.
Description:
  List of classes used by the fields entries.
Quick info:
  Unit: JclSysUtils
  Category: Memory, Classes and Objects
  Donator: Python
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
@@TFieldClassTable.Count
  Number of classes in the Classes array.
@@TFieldClassTable.Classes
  array of classes. The highest valid index in this array is Count - 1.
--------------------------------------------------------------------------------
@@TFieldEntry
<GROUP MemoryClassesandObjects.ClassManipulation.DMT>
Summary:
  TFieldEntry contains information about a field of a class.
Description:
  TFieldEntry contains information about a field of a class.
Quick info:
  Unit: JclSysUtils
  Category: Memory, Classes and Objects
  Donator: Python
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
@@TFieldEntry.OffSet
  OffSet of the field. TODO relative to what?
@@TFieldEntry.IDX
  Index for the classtype in the class list.
@@TFieldEntry.Name
  Name of the field.
--------------------------------------------------------------------------------
@@GetMethodTable
<GROUP MemoryClassesandObjects.ClassManipulation.DMT>
Summary:
  Returns the method table of a class.
Description:
  GetMethodTable returns a pointer to the method table of the specified class.
  The method table contains information about the published methods declared in the
  class.
Parameters:
  AClass - The class for which to retrieve the method table.
Result:
  Pointer to the method table. Do not modify this structure!
Quick info:
  Unit: JclSysUtils
  Category: Memory, Classes and Objects
  Donator: Python
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@TMethodTable
<GROUP MemoryClassesandObjects.ClassManipulation.DMT>
Summary:
  Structure for the Method Table
Description:
  Method Table Structure. Gives a description of method, with Count the number
  of methods, followed by count numbers of a variable length structure for each
  entry.
Quick info:
  Unit: JclSysUtils
  Category: Memory, Classes and Objects
  Donator: Python
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
@@TMethodTable.Count
  Number of TMethodEntries after count.
@@TMethodTable.FirstEntry
  First entry (if exists) of the method entries.
--------------------------------------------------------------------------------
@@GetMethodEntry
<GROUP MemoryClassesandObjects.ClassManipulation.DMT>
Summary:
  Returns an entry from the method table.
Description:
  GetMethodEntry returns the entry with the given index from the method table.
  There is no checking performed that the given Index is valid.
Parameters:
  MethodTable - The method table to get the entry from
  Index - The index of the entry to retrieve.
Result:
  Pointer to the method table entry from the method table with
  the given index. Do not modify this structure!
Quick info:
  Unit: JclSysUtils
  Category: Memory, Classes and Objects
  Donator: Python
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@TMethodEntry
<GROUP MemoryClassesandObjects.ClassManipulation.DMT>
Summary:
  Entry of a method table use by TMethodTable.
Description:
  Entry of a method table use by TMethodTable.
Quick info:
  Unit: JclSysUtils
  Category: Memory, Classes and Objects
  Donator: Python
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
@@TMethodEntry.EntrySize
  Size of the TMethodEntry. Use this to go to the next MethodEntry.
@@TMethodEntry.Address
  Pointer to the method.
@@TMethodEntry.Name
  Name of the method.
--------------------------------------------------------------------------------
@@SetClassParent
<GROUP MemoryClassesandObjects.ClassManipulation.Miscellanuous>
Summary:
  Modifies the class parent for the given class.
Description:
  Changes the parent of AClass to become NewClassParent. <P><FONT color=red>
  Do <B>NOT</B> use this function.</FONT> There should be
  no need to use this function unless you are implementing a very dirty hack.<P>
  This procedure changes the executable code (with the risk of completly destroying
  your application) and uses WriteProcessMemory for this.</P>
  The function is multiprocessor safe.
Parameters:
  AClass - The class whose parent to change.
  NewClassParent - The new parent for AClass.
Quick info:
  Unit: JclSysUtils
  Category: Memory, Classes and Objects
  Donator: Python
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@GetClassParent
<GROUP MemoryClassesandObjects.ClassManipulation.Miscellanuous>
Summary:
  Returns the parent of the class.
Description:
  Returns the parent class of the given class. That is, it returns the type of the
  immediate ancestor of the specified class. This is the same as TObject.ClassParent.
Parameters:
  AClass - The class for which to retrieve the parent class.
Result:
  The parent class (type of the immediate ancestor) of the specified class or nil
  of the specified class is TObject.
Quick info:
  Unit: JclSysUtils
  Category: Memory, Classes and Objects
  Donator: Python
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@IsClass
<GROUP MemoryClassesandObjects.ClassManipulation.Miscellanuous>
Summary:
  Returns whether a pointer points to a class.
Description:
  IsClass tests whether the specified pointer points to a class. Currently the
  implementation only test whether the Self pointer actually points to the class itself.
Parameters:
  Address - The address to test. Note that this should be the equivalent of Obj.ClassType where Obj is an instance of TObject or descendant class.
Result:
  The result is True if the Address is a class otherwise it is False.
Quick info:
  Unit: JclSysUtils
  Category: Memory, Classes and Objects
  Donator: Python
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@IsObject
<GROUP MemoryClassesandObjects.ClassManipulation.Miscellanuous>
Summary:
  Returns whether a pointer points to an object.
Description:
  IsObject tests whether the specified pointer points to an object. Currently the
  implementation only test whether the Self pointer actually points to the object itself.
Parameters:
  Address - The address to test. Note that this should be a TObject or TObject descendant.
Result:
  The result is True if the Address is an object otherwise it is False.
Quick info:
  Unit: JclSysUtils
  Category: Memory, Classes and Objects
  Donator: Python
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@ISafeGuard
<GROUP MemoryClassesandObjects.Guards.ISafeGuard>
Summary:
  Interface used to provide automatic resource destruction.
Description:
  ISafeGuard is the interface used by the Guard functions to provide automatic
  resource destruction. A safeguard is an interface which gets associated with the
  resource and ensures that when execution leaves the scope at which the safeguard
  variable is declared, the resource is released (e.g. memory freed or object destroyed).
  Since a safeguard is an interface and Delphi ensures that interfaces are released
  even when an exception is raised, you can use a safeguard to ensure that a resource
  always gets freed without having to explicitly code it. For example: 
   <PRE class=syntax>
   <B>var</B>
     SafeGuard: ISafeGuard;
     Strings: TStrings;
   <B>begin</B>
     Strings := TStrings(Guard(TStringList.Create, SafeGuard));
     String.ReadFromFile('d:\delphi\jcl\source\JclBase.pas');
     // code to manipulate strings goes here
     Strings.SaveToFile('d:\delphi\jcl\source\JclBase.pas');
   <B>end</B>;
   </PRE>
  In the above code, the TStrings object is associated with the SafeGuard. No matter
  how the function terminates, the safeguard ensures that the TStrings object is
  destroyed. Usually you will simply store the returned safeguard interface pointer
  in a variable at the appropriate scope and forget about it. However, the ISafeGuard
  interface does provide some additional functionality which may be useful at times.
Quick info:
  Unit: JclSysUtils
  Category: Memory, Classes and Objects
  Donator: Rudy Velthuis
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@ISafeGuard.ReleaseItem
Summary:
  Disassociates the resource from the safeguard.
Description:
  ReleaseItem returns a pointer to the associated resource and then disassociates it
  with the safeguard. This means that when execution leaves the scope in which
  the interface variable is declared, the resource will not be automatically freed.
  By using ReleaseItem you are handed back the responsibility to explicitly release
  the resource.
Result:
  Pointer to the resource associated with the safeguard.
Quick info:
  Unit: JclSysUtils
  Category: Memory, Classes and Objects
  Visibility: Public
  Donator: Rudy Velthuis
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@ISafeGuard.GetItem
Summary:
  Returns a pointer to the resource associated with the safeguard.
Description:
  The GetItem method returns a pointer to the resource associated with the safeguard.
  Usually you will hold on to this pointer when you associated it with the safeguard,
  however you can use the safeguard as the storage for the resource pointer itself.
Result:
  Pointer to the resource associated with the safeguard.
Quick info:
  Unit: JclSysUtils
  Category: Memory, Classes and Objects
  Visibility: Public
  Donator: Rudy Velthuis
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@ISafeGuard.FreeItem
Summary:
  Frees the memory of the associated resource.
Description:
  The FreeItem method frees the resource associated with the safeguard. You should
  never call this method directly, it is called automatically when execution leaves
  the scope in which the interface variable is declared.
Quick info:
  Unit: JclSysUtils
  Category: Memory, Classes and Objects
  Visibility: Public
  Donator: Rudy Velthuis
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@ISafeGuard.Item
Summary:
  Returns a pointer to the protected resource.
Description:
  The Item property returns a pointer to the associated resource protected by the
  safeguard. You'll have to cast the pointer to the appropriate type.
Quick info:
  Unit: JclSysUtils
  Category: Memory, Classes and Objects
  Visibility: Public
  Donator: Rudy Velthuis
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@IMultiSafeGuard
<GROUP MemoryClassesandObjects.Guards.IMultiSafeGuard>
Summary:
  Interface used to provide automatic resource destruction for multiple resources.
Description:
  IMultiSafeGuard is the interface used by the Guard functions to provide automatic
  resource destruction for multiple resources. A safeguard is an interface which gets
  associated with the resources and ensures that when execution leaves the scope at
  which the safeguard variable is declared, the resources are released (e.g. memory
  freed or objects destroyed). Since a safeguard is an interface and Delphi ensures
  that interfaces are released even when an exception is raised, you can use a
  safeguard to ensure that a resource always gets freed without having to explicitly
  code it. For example: 
   <PRE class=syntax>
   <B>var</B>
     SafeGuard: IMultiSafeGuard;
     O1, O2: TObject;
   <B>begin</B>
     O1 := Guard(TObject.Create, SafeGuard);
     O2 := Guard(TObject.Create, SafeGuard);
     // use O1 and O2 here
   <B>end</B>;
   </PRE>
  In the above code, the objects are associated with the SafeGuard. No matter
  how the function terminates, the safeguard ensures that the objects are
  destroyed. Usually you will simply store the returned safeguard interface pointer
  in a variable at the appropriate scope and forget about it. However, the ISafeGuard
  interface does provide some additional functionality which may be useful at times.
Notes:
  You can use IMultiSafeGuard to guard multiple memory allocations or multiple objects. However, a single IMultiSafeGuard interface can only store one or the other, you can not mix memory and objects in a single IMultiSafeGuard.
Quick info:
  Unit: JclSysUtils
  Category: Memory, Classes and Objects
  Donator: Team JEDI
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@IMultiSafeGuard.ReleaseItem
Summary:
  Disassociates the resource from the safeguard.
Description:
  ReleaseItem returns a pointer to the associated resource and then disassociates it
  with the safeguard. This means that when execution leaves the scope in which
  the interface variable is declared, the resource will not be automatically freed.
  By using ReleaseItem you are handed back the responsibility to explicitly release
  the resource.
Result:
  Pointer to the resource associated with the safeguard.
Quick info:
  Unit: JclSysUtils
  Category: Memory, Classes and Objects
  Visibility: Public
  Donator: Team JEDI
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@IMultiSafeGuard.GetItem
Summary:
  Returns a pointer to the resource associated with the safeguard.
Description:
  The GetItem method returns a pointer to the resource associated with the safeguard.
  Usually you will hold on to this pointer when you associated it with the safeguard,
  however you can use the safeguard as the storage for the resource pointer itself.
Result:
  Pointer to the resource associated with the safeguard.
Quick info:
  Unit: JclSysUtils
  Category: Memory, Classes and Objects
  Visibility: Public
  Donator: Team JEDI
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@IMultiSafeGuard.FreeItem
Summary:
  Frees the memory of the associated resource.
Description:
  The FreeItem method frees the resource associated with the safeguard. You should
  never call this method directly, it is called automatically when execution leaves
  the scope in which the interface variable is declared.
Quick info:
  Unit: JclSysUtils
  Category: Memory, Classes and Objects
  Visibility: Public
  Donator: Team JEDI
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@IMultiSafeGuard.Count
Summary:
  Returns the number of items guarded by the interface.
Description:
  The Count property returns the number of items guarded by the interface.
Quick info:
  Unit: JclSysUtils
  Category: Memory, Classes and Objects
  Visibility: Public
  Donator: Team JEDI
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@IMultiSafeGuard.Items
Summary:
  Returns a pointer to the protected resource.
Description:
  The Items property provides zero-based indexed access to the items guarded by the
  interface. The total numer of items can be learned from the Count property.
  You'll have to cast the pointer to the appropriate type.
Quick info:
  Unit: JclSysUtils
  Category: Memory, Classes and Objects
  Visibility: Public
  Donator: Team JEDI
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@Guard
<GROUP MemoryClassesandObjects.Guards>
Summary:
  Associates a resource, pointer or object reference, with a safeguard.
Description:
  Associates a resource, pointer or object reference, with a safeguard. A safeguard
  is an interface which gets associated with the resource and ensures that when
  execution leaves the scope at which the safeguard variable is declared, the
  resource is released (e.g. memory freed or object destroyed). Since a safeguard is
  an interface and Delphi ensures that interfaces are released even when an exception
  is raised, you can use a safeguard to ensure that a resource always gets freed
  without having to explicitly code it. For example: 
   <PRE class=syntax>
   <B>var</B>
     SafeGuard: ISafeGuard;
     Strings: TStrings;
   <B>begin</B>
     Strings := TStrings(Guard(TStringList.Create, SafeGuard));
     String.ReadFromFile('d:\delphi\jcl\source\JclBase.pas');
     // code to manipulate strings goes here
     Strings.SaveToFile('d:\delphi\jcl\source\JclBase.pas');
   <B>end;</B>
   </PRE>
  In the above code, the TStrings object is associated with the SafeGuard. No matter
  how the function terminates, the safeguard ensures that the TStrings object is
  destroyed. Usually you will simply store the returned safeguard interface pointer
  in a variable at the appropriate scope and forget about it. However, the ISafeGuard
  interface does provide some additional functionality which may be useful at times.
  See the ISafeGuard interface for more information.
Parameters:
  Mem - The pointer (or object in the case of the overloaded Guard function) which to associate with the safeguard.
  SafeGuard - The guard variable to associate the resource with.
Result:
  Copy of the Mem (or Obj) parameter. This is merely a convenience which allows
  you to create the resource embedded inside the function call as demonstrated above.
Quick info:
  Unit: JclSysUtils
  Category: Memory, Classes and Objects
  Donator: Rudy Velthuis
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@GuardGetMem
<GROUP MemoryClassesandObjects.Guards>
Summary:
  Allocates a specified amount of memory and associates it with a safeguard.
Description:
  GuardGetMem allocates the specified amount of memory and associates it with a
  safeguard. A pointer to the allocated memory is returned as the function result.
  By using GuardGetMem you ensure that no matter how the scope in which the memory
  is allocated is left (e.g. by an exception or explicit Exit), the memory will be
  freed. See Guard for a more detailed description.
Parameters:
  Size - Size, in bytes, of the memory to allocate. This memory is allocated using the standard GetMem function and as such is uninitialized.
  SafeGuard - Receives a pointer to the ISafeGuard interface which is associated with the allocated memory.
Result:
  Pointer to the block of allocated memory.
Quick info:
  Unit: JclSysUtils
  Category: Memory, Classes and Objects
  Donator: Rudy Velthuis
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@GuardAllocMem
<GROUP MemoryClassesandObjects.Guards>
Summary:
  Allocates a specified amount of memory and associates it with a safeguard.
Description:
  GuardGetMem allocates the specified amount of memory and associates it with a
  safeguard. This function is identical to GuardGetMem except that the function
  uses AllocMem internally, as opposed to GetMem. As such the allocated memory is
  initialized with all zeros. A pointer to the allocated memory is returned as the
  function result. By using GuardGetMem you ensure that no matter how the scope in
  which the memory is allocated is left (e.g. by an exception or explicit Exit), the
  memory will be freed. See Guard for a more detailed description.
Parameters:
  Size - Size, in bytes, of the memory to allocate. This memory is allocated using the standard AllocMem function and as such is initialized to all zeros.
  SafeGuard - Receives a pointer to the ISafeGuard interface which is associated with the allocated memory.
Result:
  Pointer to the block of allocated memory.
Quick info:
  Unit: JclSysUtils
  Category: Memory, Classes and Objects
  Donator: Rudy Velthuis
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@ClearObjectList
<GROUP MemoryClassesandObjects.Miscellanuous>
Summary:
  Clears the contents of a TList which contains objects.
Description:
  ClearObjectList clears the contents of the specified list. The routine assumes that each
  item in the list is a TObject descendant and frees these objects before removing
  them from the list. If the list contains items other than TObject descendants,
  the result is unpredictable (likely an access violation will occur).
Parameters:
  List - The list to clear.
Quick info:
  Unit: JclSysUtils
  Category: Memory, Classes and Objects
  Donator: Heri Bender
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@FreeObjectList
<GROUP MemoryClassesandObjects.Miscellanuous>
Summary:
  Clears the contents of a TList which contains objects.
Description:
  FreeObjectList clears the contents of the specified list and then frees the list itself.
  The routine assumes that each item in the list is a TObject descendant and frees
  these objects before removing them from the list. If the list contains items other
  than TObject descendants, the result is unpredictable (likely an access violation
  will occur).
Parameters:
  List - The list to free.
Quick info:
  Unit: JclSysUtils
  Category: Memory, Classes and Objects
  Donator: Heri Bender
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@TModuleHandle
<GROUP BaseServices.Dynamicloading>
Summary:
  OS independent type for loaded modules.
Description:
  OS independent type for loaded modules.
Quick info:
  Unit: JclSysUtils
  Category: Base Services
  Donator: Robert Marquardt
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@INVALID_MODULEHANDLE_VALUE
<GROUP BaseServices.Dynamicloading>
Summary:
  OS independent value for variables of type TModuleHandle.
Description:
  OS independent value for variables of type TModuleHandle.
  Denotes that the variable does not contain a valid handle to a module.
Quick info:
  Unit: JclSysUtils
  Category: Base Services
  Donator: Robert Marquardt
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@LoadModule
<GROUP BaseServices.Dynamicloading>
Summary:
  Loads the dynamic module (DLL) from file FileName.
Description:
  The dynamic module (DLL) is loaded into memory and its initialization code
  is executed. This is an OS independent replacement for LoadLibrary.
  The function does nothing but reports success if Module is not initialized
  to INVALID_MODULEHANDLE_VALUE to prevent multiple loads.
Parameters:
  Module - Receives the handle of the loaded module.
  FileName - File name of the module to load.
Result:
  The function returns True if the module could be loaded False otherwise.
Quick info:
  Unit: JclSysUtils
  Category: Base Services
  Donator: Robert Marquardt
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@LoadModuleEx
<GROUP BaseServices.Dynamicloading>
Summary:
  Loads the dynamic module (DLL) from file FileName.
Description:
  The dynamic module (DLL) is loaded into memory and its initialization code
  is executed if the flags allow that.
  This is an OS independent replacement for LoadLibraryEx.
  Flags are OS dependent. For Windows its the flags of LoadLibraryEx.
  The function does nothing but reports success if Module is not initialized
  to INVALID_MODULEHANDLE_VALUE to prevent multiple loads.
Parameters:
  Module - Receives the handle of the loaded module.
  FileName - File name of the module to load.
  Flags - Additional loading flags.
Quick info:
  Unit: JclSysUtils
  Category: Base Services
  Donator: Robert Marquardt
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@UnloadModule
<GROUP BaseServices.Dynamicloading>
Summary:
  Unloads a dynamic module (DLL) from memory.
Description:
  Unloads a dynamic module (DLL) loaded with LoadModule or
Parameters:
  Module - Contains the handle of the module to unload.
Quick info:
  Unit: JclSysUtils
  Category: Base Services
  Donator: Robert Marquardt
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@GetModuleSymbol
<GROUP BaseServices.Dynamicloading>
Summary:
  Gives access to the exported symbol SymbolName from the loaded module Module.
Description:
  Gives access to the exported symbol SymbolName from the loaded module Module.
  Normally this is the name of an exported function.
Parameters:
  Module - Handle to the loaded module.
  SymbolName - Name of the exported symbol to access.
Result:
  The pointer to the exported symbol. Normally this is a "pointer to function"
  as C calls it. In Pascal its a function type. nil is returned for symbols
  not contained in the module.
Quick info:
  Unit: JclSysUtils
  Category: Base Services
  Donator: Robert Marquardt
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@GetModuleSymbolEx
<GROUP BaseServices.Dynamicloading>
Summary:
  Gives access to the exported symbol SymbolName from the loaded module Module.
Description:
  Gives access to the exported symbol SymbolName from the loaded module Module.
  Normally this is the name of an exported function.
  Accu is updated by "Accu := Accu and (Result <> nil);". This allows to
  call GetModuleSymbolEx for many symbols and render a global result for
  successfully accessing all symbols.
Parameters:
  Module - Handle to the loaded module.
  SymbolName - Name of the exported symbol to access.
  Accu - Success accumulator to be updated.
Result:
  The pointer to the exported symbol. Normally this is a "pointer to function"
  as C calls it. In Pascal its a function type. nil is returned for symbols
  not contained in the module and Accu will contain False.
Quick info:
  Unit: JclSysUtils
  Category: Base Services
  Donator: Robert Marquardt
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@ReadModuleData
<GROUP BaseServices.Dynamicloading>
Summary:
  Reads the data of an exported variable.
Description:
  ReadModuleData copies the contents of the exported variable SymbolName to
  Buffer. Size tells the amount of bytes to be copied.
  This function allows to access variables in dynamic modules which are
  not directly accessible in Pascal.
  Beware! You are accessing the DLL memory image directly.
  Be sure to access a variable not a function and be sure
  to read the correct amount of data.
Parameters:
  Module - Handle to the loaded module.
  SymbolName - Name of the exported variable to access.
   - The untyped destination of the copy.
  Size - Amount of bytes to copy.
Quick info:
  Unit: JclSysUtils
  Category: Base Services
  Donator: Robert Marquardt
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
@@WriteModuleData
<GROUP BaseServices.Dynamicloading>
Summary:
  Writes the data of an exported variable.
Description:
  WriteModuleData copies the contents of Buffer to the exported variable SymbolName.
  Size tells the amount of bytes to be copied.
  This function allows to set variables in dynamic modules which are
  not directly accessible in Pascal.
  BEWARE! You are accessing the DLL memory image directly.
  Be sure to access a variable not a function and be sure
  to write the correct amount of data.
  The changes are not persistent. They get lost when the
  DLL is unloaded.
Parameters:
  Module - Handle to the loaded module.
  SymbolName - Name of the exported variable to access.
   - The untyped source of the copy.
  Size - Amount of bytes to copy.
Quick info:
  Unit: JclSysUtils
  Category: Base Services
  Donator: Robert Marquardt
  Delphi Versions: 4,5,6
  Kylix Versions: 1
  Free Pascal Compiler Versions: 1.x
--------------------------------------------------------------------------------
