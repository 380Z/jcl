<DECL>--------------------------------------------------------------------------
[Declaration]
function EnableCrashOnCtrlScroll(const Enable: Boolean): Boolean;
[ShortDescr]
Enables manually crashing Windows.
[Description]
EnableCrashOnCtrlScroll enables crashing Windows 2000 using the keyboard. After
this has been enabled you can bugcheck Windows 2000 by holding down the right
control key and pressing the scroll key twice. On the second press Windows will
bugcheck with code 0x000000E2. Note that this function simply modifies a registry
entry, to actually enable this 'feature' you must reboot first.
[Parameters]
Count=1
1=Enable:Boolean=If set to True the crash on ctrl scroll 'feature' is enabled, if
set to False it is disabled.
[Result]
If the function succeeds it returns True, otherwise it returns False.
[Quick Info]
BCB=3,4,5
Unit=JclDebug
Category=Debugging
SubCat=Crash
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
Windows NT/2000=Requires Windows NT 2000 or later.
Windows 95/98=Unsupported.
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure AssertKindOf(const ClassName: string; const Obj: TObject); overload;
procedure AssertKindOf(const ClassType: TClass; const Obj: TObject); overload;
[ShortDescr]
Asserts that an object is of a specified class.
[Description]
AssertKindOf asserts that the specified object is of the specified type or inherits
from that type. If this is not the case the function triggers an assertion failure.
The overloaded procedure allows you to directly specify a class type instead of
a class name.
[Parameters]
Count=2
1=ClassName:string=Name of the class to test Obj for.
2=Obj:TObject=The object to test.
[Quick Info]
BCB=3,4,5
Unit=JclDebug
Category=Debugging
SubCat=Diagnostics
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure Trace(const Msg: string);
[ShortDescr]
Sends a message to the debugger.
[Description]
Trace sends the specified message to the debugger.
[Parameters]
Count=1
1=Msg:string=The message to send to the debugger.
[Notes]
Count=1
1=If you are running your application under the control of the debugger you can view
these messages using the event log dialog, 'View | Debug Windows | Event Log'.
If the application is not running under the debugger the message is sent to the
system debugger. If there is no system debugger active the function does nothing.
[Quick Info]
BCB=3,4,5
Unit=JclDebug
Category=Debugging
SubCat=Diagnostics
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
[SeeAlso]
Count=3
1=TraceFmt
2=TraceLoc
3=TraceLocFmt
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure TraceFmt(const Fmt: string; const Args: array of const);
[ShortDescr]
Sends a formatted message to the debugger.
[Description]
TraceFmt sends a message, formatted from the supplied format string and
arguments array, to the debugger. The function uses the VCL Format() function
to format the string and therefore you can use this function exactly like you
would use Format(). See the Delphi help file for more information.
[Parameters]
Count=2
1=Fmt:string=Controls the formatting of the message.
2=Args:array of const=Arguments formatted under control of the Fmt string.
[Notes]
Count=1
1=If you are running your application under the control of the debugger you can view
these messages using the event log dialog, 'View | Debug Windows | Event Log'.
If the application is not running under the debugger the message is sent to the
system debugger. If there is no system debugger active the function does nothing.
[Quick Info]
BCB=3,4,5
Unit=JclDebug
Category=Debugging
SubCat=Diagnostics
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
[SeeAlso]
Count=3
1=Trace
2=TraceLoc
3=TraceLocFmt
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure TraceLoc(const Msg: string);
[ShortDescr]
Sends a message to the debugger including location information.
[Description]
TraceLoc sends the specified message to the debugger but first prepends it with
the source file location from which TraceLoc is called. For example, when calling
TraceLoc from a method called TForm1.Button1Click located in unit1.pas like
this: TraceLoc('Trace me.') the resulting string sent to the debugger will be:<BR>
  unit.pas:123 (TForm1.ButtonClick) "Trace me." <BR>
assuming the TraceLoc statement is on line 123 in the source. Note that this
function requires a detailed map file!
[Parameters]
Count=1
1=Msg:string=The message to send to the debugger.
[Notes]
Count=1
1=If you are running your application under the control of the debugger you can view
these messages using the event log dialog, 'View | Debug Windows | Event Log'.
If the application is not running under the debugger the message is sent to the
system debugger. If there is no system debugger active the function does nothing.
[Quick Info]
BCB=3,4,5
Unit=JclDebug
Category=Debugging
SubCat=Diagnostics
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Requirements=A detailed map file.
[SeeAlso]
Count=3
1=Trace
2=TraceFmt
3=TraceLocFmt
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure TraceLocFmt(const Fmt: string; const Args: array of const);
[ShortDescr]
Sends a formatted message to the debugger prepending it with location information.
[Description]
TraceFmt sends a message, formatted from the supplied format string and
arguments array, to the debugger, but first prepends it with the source file location
information. The function uses the VCL Format() function to format the string and
therefore you can use this function exactly like you would use Format().
See the Delphi help file for more information. See <REF>TraceLoc</REF> for an
example output.
[Parameters]
Count=2
1=Fmt:string=Controls the formatting of the message.
2=Args:array of const=Arguments formatted under control of the Fmt string.
[Notes]
Count=1
1=If you are running your application under the control of the debugger you can view
these messages using the event log dialog, 'View | Debug Windows | Event Log'.
If the application is not running under the debugger the message is sent to the
system debugger. If there is no system debugger active the function does nothing.
[Quick Info]
BCB=3,4,5
Unit=JclDebug
Category=Debugging
SubCat=Diagnostics
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Requirements=A detailed map file.
[SeeAlso]
Count=3
1=Trace
2=TraceFmt
3=TraceLoc
<DECL>--------------------------------------------------------------------------
[Declaration]
TJclMapAddress = record
  Segment: Word;
  Offset: Integer;
end;
[ShortDescr]
Holds location information.
[Description]
TJclMapAddress holds location information in notifiers of the map parsers.
[RecordFields]
Count=2
1=Segment:Word=Segment number of item.
2=Offset:Integer=Offset of item.
[Quick Info]
Kind=Type
BCB=4,5
Kind=Type
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
PJclMapString = PAnsiChar;
[ShortDescr]
A map-file string
[Description]
PJclMapString holds a map-file specific string. Use the MapStringToString class
function to convert it to a normal string.
[Quick Info]
Kind=Type
BCB=4,5
Kind=Type
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
TJclAbstractMapParser = class (TObject)
[ShortDescr]
Abstract Map parser
[Description]
TJclAbstractMapParser is an abstract base class for a MAP-file parser.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclAbstractMapParser
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure ClassTableItem(const Address: TJclMapAddress; Len: Integer; SectionName, GroupName: PJclMapString); virtual; abstract;
[ShortDescr]
Handler for a class item
[Description]
ClassTableItem is a handler for a class item (eg. CODE, DATA or BSS class) in
the map file. It get's called by the Parse method when it finds a class table item.
[Parameters]
Count=4
1=Address:TJclMapAddress=Address of the class item.
2=Len:Integer=Length of the class item.
3=SectionName=Section name of the class item (eg. ".text").
4=GroupName=Class name of the class item (eg. "CODE").
[Quick Info]
Kind=Method
Visibility=Protected
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclAbstractMapParser
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure SegmentItem(const Address: TJclMapAddress; Len: Integer; GroupName, UnitName: PJclMapString); virtual; abstract;
[ShortDescr]
Handler for a segment item (i.e.. a Delphi unit)
[Description]
SegmentItem is a handler for a segment item (i.e.. a Delphi unit) in the map file.
It gets called by the Parse method when it finds a segment item.
[Parameters]
Count=4
1=Address:TJclMapAddress=Address of the segment item.
2=Len:Integer=Length of the segment item.
3=GroupName:PJclMapString=Class name of the segment item (eg. "CODE").
4=UnitName:PJclMapString=Delphi unit name of the segment item (eg. "System").
[Quick Info]
Kind=Method
Visibility=Protected
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclAbstractMapParser
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure PublicsByNameItem(const Address: TJclMapAddress; Name: PJclMapString); virtual; abstract;
[ShortDescr]
Handler for a public item in the publics by name section.
[Description]
PublicsByNameItem is a handler for a public item (eg. a procedure) in the "Publics
By Name"-section of the map file.
It gets called by the Parse method when it finds a public item in the "Publics
By Name"-section.
[Parameters]
Count=2
1=Address:TJclMapAddress=Address of the public item.
2=Name:PJclMapString=Name of the public item.
[Quick Info]
Kind=Method
Visibility=Protected
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclAbstractMapParser
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure PublicsByValueItem(const Address: TJclMapAddress; Name: PJclMapString); virtual; abstract;
[ShortDescr]
Handler for a public item in the publics by value section.
[Description]
PublicsByValueItem is a handler for a public item (eg. a procedure) in the "Publics
By Value"-section of the map file.
It gets called by the Parse method when it finds a public item in the "Publics
By Value"-section.
[Parameters]
Count=2
1=Address:TJclMapAddress=Address of the public item.
2=Name:PJclMapString=Name of the public item.
[Quick Info]
Kind=Method
Visibility=Protected
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclAbstractMapParser
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure LineNumberUnitItem(UnitName, UnitFileName: PJclMapString); virtual; abstract;
[ShortDescr]
Handler for a unit declaration in the lines section.
[Description]
LineNumberUnitItem is a handler for a unit declaration in the lines section
of the map file. It gets called by the Parse method when it finds a unit
declaration in the lines section.
[Parameters]
Count=2
1=UnitName:PJclMapString=Name of the unit.
2=UnitFileName:PJclMapString=Name of the source file.
[Quick Info]
Kind=Method
Visibility=Protected
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclAbstractMapParser
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure LineNumbersItem(LineNumber: Integer; const Address: TJclMapAddress); virtual; abstract;
[ShortDescr]
Handler for a line declaration in the lines section.
[Description]
LineNumbers is a handler for a line declaration in the lines section
of the map file. It gets called by the Parse method when it finds a unit
declaration in the lines section.
[Parameters]
Count=2
1=LineNumber:Integer=Line number for the item.
2=Address:PJclMapAddress=Starting address for the line number.
[Quick Info]
Kind=Method
Visibility=Protected
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclAbstractMapParser
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
constructor Create(const MapFileName: TFileName); virtual;
[ShortDescr]
Creates an instance of TJclAbstractMapParser
[Description]
The Create method instantiates a map-parser object. Since TJclAbstractMapParser
is an abstract base class, you should not Create an instance of
TJclAbstractMapParser directly, but rather of a descendant.</P><P>
If the specified file exists, a TJclFileMappingStream will be assigned to
the Stream property, referencing the map file.
[Parameters]
Count=1
1=MapFileName:TFileName=Name of the map-file to associate with the parser.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclAbstractMapParser
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
destructor Destroy; override;
[ShortDescr]
Destroys an instance of TJclAbstractMapParser
[Description]
Destroy frees up all internal objects before freeing this instance.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclAbstractMapParser
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure Parse;
[ShortDescr]
Parses the map file
[Description]
Parse parses the map file specified referenced by the Stream property. It calls
different methods for items found in the file. Descendants override these methods
to store it in an internal structure.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclAbstractMapParser
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
class function MapStringToStr(MapString: PJclMapString): string;
[ShortDescr]
Translates map file specific strings to a normal string.
[Description]
MapStringToStr translates map file specific strings to a normal string.</P><P>
If MapString points to an opening bracket, it returns the text starting
at the next character up to the closing bracket or a Carriage Return, whichever
comes first.<BR>
If MapString does not point to an opening bracket, it returns the text from
the current location up to the next space, a carriage return or a closing bracket.
[Parameters]
Count=1
1=MapString:PJclMapString=String to translate
[Result]
If MapString = nil the function returns an empty string, otherwise it returns
translated version of the string.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclAbstractMapParser
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
property Stream: TJclFileMappingStream read FStream;
[ShortDescr]
A stream referencing the map file
[Description]
Stream holds the a reference to the map file assigned by the Create method.
[Quick Info]
Kind=Property
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclAbstractMapParser
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
TJclMapParser = class (<REF Target"..\TJclAbstractMapParser\TJclAbstractMapParser">TJclAbstractMapParser</REF>)
[ShortDescr]
Generic map file parser
[Description]
TJclMapParser is a class for a generic MAP-file parser. Items are reported to
the user through event calls.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclMapParser
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
property OnClassTable: TJclMapClassTableEvent read FOnClassTable write FOnClassTable;
[ShortDescr]
Event handler for a class item.
[Description]
OnClassTable is the event handler for a class item in the map file. It get's called by
the ClassTableItem method when the parser finds a class table item.
[Quick Info]
Kind=Property
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclMapParser
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
property OnSegment: TJclMapSegmentEvent read FOnSegmentItem write FOnSegmentItem;
[ShortDescr]
Event handler for a segment item (i.e.. a Delphi unit)
[Description]
OnSegment is the event handler for a segment item (i.e.. a Delphi unit) in the map file.
It gets called by the SegmentItem method when the parser finds a segment item.
[Quick Info]
Kind=Property
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclMapParser
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
property OnPublicsByName: TJclMapPublicsEvent read FOnPublicsByName write FOnPublicsByName;
[ShortDescr]
Event handler for a public item in the publics by name section.
[Description]
OnPublicsByName is the event handler for a public item (eg. a procedure) in the "Publics
By Name"-section of the map file.
It gets called by the PublicsByNameItem method when the parser finds a public item in
the "Publics By Name"-section.
[Quick Info]
Kind=Property
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclMapParser
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
property OnPublicsByValue: TJclMapPublicsEvent read FOnPublicsByValue write FOnPublicsByValue;
[ShortDescr]
Event handler for a public item in the publics by value section.
[Description]
OnPublicsByValue is the event handler for a public item (eg. a procedure) in the "Publics
By Value"-section of the map file.
It gets called by the PublicsByValueItem method when the parser finds a public item in
the "Publics By Value"-section.
[Quick Info]
Kind=Property
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclMapParser
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
property OnLineNumberUnit: TJclMapLineNumberUnitEvent read FOnLineNumberUnit write FOnLineNumberUnit;
[ShortDescr]
Event handler for a unit declaration in the lines section.
[Description]
OnLineNumberUnit is the event handler for a unit declaration in the lines section
of the map file. It gets called by the LineNumberUnitItem method when the parser
finds a unit declaration in the lines section.
[Quick Info]
Kind=Property
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclMapParser
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
property OnLineNumbers: TJclMapLineNumbersEvent read FOnLineNumbers write FOnLineNumbers;
[ShortDescr]
Event handler for a line declaration in the lines section.
[Description]
OnLineNumbers is the event handler for a line declaration in the lines section
of the map file. It gets called by the LineNumbers method when the parser finds
a unit declaration in the lines section.
[Quick Info]
Kind=Property
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclMapParser
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
TJclMapScanner = class (<REF Target"..\TJclAbstractMapParser\TJclAbstractMapParser">TJclAbstractMapParser</REF>)
[ShortDescr]
Generic map file parser
[Description]
TJclMapScanner is a map file scanner. The class scans the map file and holds the
result for later reference.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclMapScanner
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure Scan;
[ShortDescr]
Scans the map file.
[Description]
Scan scans the map file specified by Create and stores the result for later
reference.
[Quick Info]
Kind=Method
Visibility=Protected
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclMapScanner
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
constructor Create(const MapFileName: TFileName);
[ShortDescr]
Creates an instance of TJclMapScanner
[Description]
The Create method instantiates a map-file scanner object. After calling the
inherited Create from <REF Target"..\TJclAbstractMapParser\TJclAbstractMapParser">TJclAbstractMapParser</REF>,
the scan method will be called to scan the file.
[Parameters]
Count=1
1=MapFileName:TFileName=Name of the map-file to associate with the parser.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclMapScanner
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function LineNumberFromAddr(Addr: DWORD): Integer;
[ShortDescr]
Returns the line number for an address.
[Description]
LineNumberFromAddr returns the line number for the specified address.
[Parameters]
Count=1
1=Addr:DWORD=Address to get line number for.
[Result]
The line number for the specified address.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclMapScanner
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function ModuleNameFromAddr(Addr: DWORD): string;
[ShortDescr]
Returns the Delphi unit name for an address.
[Description]
ModuleNameFromAddr returns the Delphi unit name for the specified address.
[Parameters]
Count=1
1=Addr:DWORD=Address to get unit name for.
[Result]
The Delphi unit name for the specified address.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclMapScanner
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function ProcNameFromAddr(Addr: DWORD): string;
[ShortDescr]
Returns the procedure name for an address.
[Description]
ProcNameFromAddr returns the procedure name for the specified address.
[Parameters]
Count=1
1=Addr:DWORD=Address to get procedure name for.
[Result]
The procedure name for the specified address.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclMapScanner
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function SourceNameFromAddr(Addr: DWORD): string;
[ShortDescr]
Returns the source file name for an address.
[Description]
SourceNameFromAddr returns the source-file name for the specified address.
[Result]
The source file name for the specified address.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclMapScanner
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
TJclBinDebugGenerator = class (<REF Target"..\..\Map Parsers\TJclMapScanner\TJclMapScanner">TJclMapScanner</REF>)
[ShortDescr]
Generates a binary version of a map file.
[Description]
TJclBinDebugGenerator translates the text based map file created by the linker into
a smaller, binary version. The result is saved in a memory stream.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Binary Debug Data\TJclBinDebugGenerator
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure CreateData;
[ShortDescr]
Translates the map file
[Description]
CreateData translates the text based map file into a binary version and stores it
in a memorystream, referenced by the <REF Target".\Properties\DataStream">DataStream</REF>
property. CreateData gets called by the Create method automatically.</P><P>
Literal strings are compressed into a 6-bit character, which results in a compression of
3:4. Furthermore, it doesn't store spaces and integers are stored as integer values (always
4 bytes instead of 8-byte hex-string). This results in a considerable savings on
needed space.
[Quick Info]
Kind=Method
Visibility=Protected
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Binary Debug Data\TJclBinDebugGenerator
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
constructor Create(const MapFileName: TFileName);
[ShortDescr]
Creates an instance of TJclBinDebugGenerator
[Description]
The Create method instantiates a binary debug generator object. After calling the
inherited Create from <REF Target"..\TJclMapScanner\TJclMapScanner">TJclMapScanner</REF>,
the <REF>CreateData</REF> method will be called to convert the text-based map file to a
binary version.
[Parameters]
Count=1
1=MapFileName:TFileName=Name of the map-file to associate with the parser.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Binary Debug Data\TJclBinDebugGenerator
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
property DataStream: TMemoryStream read FDataStream;
[ShortDescr]
A memory stream holding the translation result.
[Description]
DataStream holds the result of the translation.
[Quick Info]
Kind=Property
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Binary Debug Data\TJclBinDebugGenerator
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
TJclBinDebugScanner = class (TObject)
[ShortDescr]
Scans a binary version of a map file.
[Description]
TJclBinDebugScanner is like the TJclMapScanner except that it scans a binary map
file. The binary file can be generated from a text-based map file by instantiating
a TJclBinDebugGenerator object and saving the DataStream to a file.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Binary Debug Data\TJclBinDebugScanner
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
constructor Create(AStream: TCustomMemoryStream; CacheData: Boolean);
[ShortDescr]
Creates an instance of TJclBinDebugScanner
[Description]
The Create method instantiates a binary debug scanner object. After instantiating
and assigning the stream, the format is checked. You can use the <REF Target"..\Properties\ValidFormat">ValidFormat</REF>-property
to check if the stream actually contains binary debug data.
[Parameters]
Count=2
1=AStream:TCustomMemoryStream=Stream with binary debug data.
2=CacheData:Boolean=If set to true, data read from the stream is internally cached.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Binary Debug Data\TJclBinDebugScanner
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function LineNumberFromAddr(Addr: DWORD): Integer;
[ShortDescr]
Returns the line number for an address.
[Description]
LineNumberFromAddr returns the line number for the specified address.
[Parameters]
Count=1
1=Addr:DWORD=Address to get line number for.
[Result]
The line number for the specified address.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Binary Debug Data\TJclBinDebugScanner
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function ModuleNameFromAddr(Addr: DWORD): string;
[ShortDescr]
Returns the Delphi unit name for an address.
[Description]
ModuleNameFromAddr returns the Delphi unit name for the specified address.
[Parameters]
Count=1
1=Addr:DWORD=Address to get unit name for.
[Result]
The Delphi unit name for the specified address.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Binary Debug Data\TJclBinDebugScanner
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function ProcNameFromAddr(Addr: DWORD): string;
[ShortDescr]
Returns the procedure name for an address.
[Description]
ProcNameFromAddr returns the procedure name for the specified address.
[Parameters]
Count=1
1=Addr:DWORD=Address to get procedure name for.
[Result]
The procedure name for the specified address.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Binary Debug Data\TJclBinDebugScanner
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function SourceNameFromAddr(Addr: DWORD): string;
[ShortDescr]
Returns the source file name for an address.
[Description]
SourceNameFromAddr returns the source-file name for the specified address.
[Result]
The source file name for the specified address.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Binary Debug Data\TJclBinDebugScanner
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
property ValidFormat: Boolean read FValidFormat;
[ShortDescr]
Flag to check validity of data
[Description]
ValidFormat is true if the data in the specified stream is valid binary debug data.
[Quick Info]
Kind=Property
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Binary Debug Data\TJclBinDebugScanner
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
TJclLocationInfo = record
  Address: Pointer;
  UnitName: string;
  ProcedureName: string;
  LineNumber: Integer;
  SourceName: string;
  DebugInfo: <REF Target"TJclDebugInfoSource\TJclDebugInfoSource">TJclDebugInfoSource</REF>;
end;
[ShortDescr]
Location info structure
[Description]
TJclLocationInfo is the structure returned in various routines and methods that
request location info for a specific address.
[RecordFields]
Count=6
1=Address:Pointer=Nearest address of the request.
2=UnitName:string=Name of the Delphi unit the address is located in.
3=ProcedureName:string=Name of the procedure for the address.
4=LineNumber:Integer=Line-number for the address.
5=SourceName:string=Name of the source file for the address.
6=DebugInfo:TJclDebugInfoSource=Other usefull information for the address. 
See <REF Target"TJclDebugInfoSource\TJclDebugInfoSource">TJclDebugInfoSource</REF>
for more information.
[Quick Info]
Kind=Type
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
TJclDebugInfoSource = class (TObject)
[ShortDescr]
Debug info location item.
[Description]
TJclDebugInfoSource is an abstract base class to hold location information. 
Instances of descendants are created by the TJclDebugInfoList-object.</P><P>
Descendants should override the <REF Target"Methods\InitializeSource">InitializeSource</REF> 
and <REF Target"Methods\GetLocationInfo">GetLocationInfo</REF> methods.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\TJclDebugInfoSource
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function InitializeSource: Boolean; virtual; abstract;
[ShortDescr]
Initializes the object.
[Description]
InitializeSource initializes the object.
[Result]
If the function succeeds it returns True, otherwise it returns False.
[Quick Info]
Kind=Method
Visibility=Protected
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\TJclDebugInfoSource
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
constructor Create(AModule: HMODULE); virtual;
[ShortDescr]
Instantiates a DebugInfoSource object.
[Description]
Create instantiates a TJclDebugInfoSource object and links it to a specific
module. TJclDebugInfoSource is an abstract base class and you should never
instantiate a TJclDebugSource directly, but rather a descendant.
[Parameters]
Count=1
1=AModule:HMODULE=Module handle to create debug info for.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\TJclDebugInfoSource
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function GetLocationInfo(const Addr: Pointer; var Info: TJclLocationInfo): Boolean; virtual; abstract;
[ShortDescr]
Retreives information on a specified address.
[Description]
GetLocationInfo retreives information for the address specified by the Addr 
parameter and returns it through the Info parameter.
[Parameters]
Count=2
1=Addr:Pointer=Address to get information on
2=Info:TJclLocationInfo=Structure that holds information on the address, if address 
belongs to this object
[Result]
If the specified address exists within the module represented by this object the 
function returns True and Info will hold the information for the specified address.
If the address does not exist within the module, the function returns False.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\TJclDebugInfoSource
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
property Module: HMODULE read FModule;
[ShortDescr]
Module referenced by this object.
[Description]
Module holds the module handle this instance has been created for.
[Quick Info]
Kind=Property
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\TJclDebugInfoSource
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
property FileName: TFileName read GetFileName;
[ShortDescr]
File name for the module referenced by this object.
[Description]
FileName holds the file name of the module this instance has been created for.
[Quick Info]
Kind=Property
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\TJclDebugInfoSource
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
TJclDebugInfoList = class (TObjectList)
[ShortDescr]
Holds a list of debug info items
[Description]
TJclDebugInfoList holds a list of DebugInfo items requested. Items are created
when needed, not when the list is created.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\TJclDebugInfoList
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function CreateDebugInfo(const Module: HMODULE): TJclDebugInfoSource;
[ShortDescr]
Creates a DebugInfoSource descendant for a module
[Description]
CreateDebugInfo will atempt to create a TJclDebugInfoSource for the given module 
and initializes it. The method tries to obtain the following types in order:
	<UL>
		<LI>Text-based map file</LI>
		<LI>Jcl Binary debug data resource</LI>
		<LI>Borland exports header</LI>
	</UL>
If initialization failed for all supported types nil will be returned, otherwise
it will return the first that initialized correctly.
[Parameters]
Count=1
1=Module:HMODULE=Module handle to create debug info for.
[Result]
If debug info could be obtained for the specified module, a TJclDebugInfoSource
descendant will be returned, otherwise it returns nil. [Quick Info]
Kind=Method
Visibility=Protected
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\TJclDebugInfoList
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function GetLocationInfo(const Addr: Pointer; var Info: TJclLocationInfo): Boolean;
[ShortDescr]
Retreives information on a specified address.
[Description]
GetLocationInfo retreives information for the address specified by the Addr 
parameter and returns it through the Info parameter.
[Parameters]
Count=2
1=Addr:Pointer=Address to get information on
2=Info:TJclLocationInfo=Structure that holds information on the address, if address 
belongs to any module in the current process.
[Result]
If the specified address exists within the curent process the 
function returns True and Info will hold the information for the specified address.
If the address does not exist within the curretn process, the function returns False.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\TJclDebugInfoList
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
property ItemFromModule[const Module: HMODULE]: TJclDebugInfoSource read GetItemFromModule;
[ShortDescr]
Gets a DebugInfo item for the specified module.
[Description]
ItemFromModule returns a DebugInfo item for the specified module. If the item
hasn't been created, it will try to do so.
[Quick Info]
Kind=Property
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\TJclDebugInfoList
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
property Items[Index: Integer]: TJclDebugInfoSource read GetItems;
[ShortDescr]
Returns the debug info item at the specified index
[Description]
Items returns the debug info item at the specified index.
[Quick Info]
Kind=Property
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\TJclDebugInfoList
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
TJclDebugInfoMap = class (TJclDebugInfoSource)
[ShortDescr]
Debug info location item for text-base map files.
[Description]
TJclDebugInfoMap is the class to hold location information by scanning
a text-based map file. It uses a TJclMapScanner object to do so.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\TJclDebugInfoMap
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
TJclDebugInfoBinary = class (TJclDebugInfoSource)
[ShortDescr]
Debug info location item for Jcl binary debug data.
[Description]
TJclDebugInfoBinary is the class to hold location information by scanning
a Jcl binary debug data resource. It uses a TJclBinDebugScanner object to do so.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\TJclDebugInfoBinary
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
TJclDebugInfoExports = class (TJclDebugInfoSource)
[ShortDescr]
Debug info location item for Borland export header.
[Description]
TJclDebugInfoExports is the class to hold location information by scanning
a Borland export header for the PE-image. It uses a TJclPeBorImage object to do so.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\TJclDebugInfoExports
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function ModuleFromAddr(const Addr: Pointer): HMODULE;
[ShortDescr]
Returns the module handle for an address.
[Description]
TODO
[Parameters]
Count=1
1=Addr:Pointer=Address to get the module handle of.
[Result]
If the Addr parameter points to an address in code-segment, it returns the
handle of the module at at that address, otherwise it returns 0.
[Quick Info]
BCB=3,4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=3,4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
function IsSystemModule(const Module: HMODULE): Boolean;
[ShortDescr]
Determines if a module belongs to the current application
[Description]
IsSystemModule checks if the specified module is part of the current application.
It does so by searching the list at LibModuleList (see Delphi Help).
[Parameters]
Count=1
1=Module:HMODULE=Module handle to check.
[Result]
If the module belongs to the application, the function returns True, otherwise it
returns False.
[Quick Info]
BCB=3,4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=3,4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
function Caller(Level: Integer): Pointer;
[ShortDescr]
Returns the address of a calling routine.
[Description]
Caller returns the address of the calling routine at the specified level. Specifying
level 0 results in the currently executing routine, level 1 results in the caller
of the currently executing routine, level 2 results in the caller of the caller of
the, well, you get the picture. The returned address is the address of the instruction
at which execution continues when the function(s) return.
[Parameters]
Count=1
1=Level:Integer=The level of the caller for which you want the address. Level 0
is the currently executing routine, 1 is the caller, 2 is the caller of the caller
and so forth.
[Result]
The address of the instruction of the routine specified by Level at which execution
resumes when the function(s) return.
[Quick Info]
BCB=3,4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=3,4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
function GetLocationInfo(const Addr: Pointer): TJclLocationInfo;
[ShortDescr]
Returns location info given an address.
[Description]
GetLocationInfo returns a TJclLocationInfo structure for the specified address.
[Parameters]
Count=1
1=Addr:Pointer=Addres to obtain information on.
[Result]
This function returns a TJclLocationInfo record filled with any information it 
could find.
[Quick Info]
BCB=3,4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=3,4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Requirements=A detailed map file.
<DECL>--------------------------------------------------------------------------
[Declaration]
function GetLocationInfoStr(const Addr: Pointer): string;
[ShortDescr]
Returns location info in a formatted string, given an address.
[Description]
GetLocationInfoStr returns location info in a formatted string. The string is
formatted as: [<I>Address</I>] <I>UnitName</I>.<I>ProcedureName</I> (Line <I>linenumber</I>, "<I>source file name</I>"
[Parameters]
Count=1
1=Addr:Pointer=Address to obtain information on.
[Result]
If location info was found, the function returns the info formatted as:
 <B>[</B><I>Address</I><B>]</B> <I>UnitName</I><B>.</B><I>ProcedureName</I>
<B>(Line</B> <I>linenumber</I><B>, "</B><I>source file name</I></B>"), otherwise
it returns a string formatted as <B>[</B><I>Address</I><B>]</B>.
[Quick Info]
BCB=3,4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=3,4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Requirements=A detailed map file.
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure ClearLocationData;
[ShortDescr]
Clears the list of debug information items.
[Description]
ClearLocationData clears the list of debug information items created so far. All
routines that request location information use this list. If many request for many
different modules have been made, this could consume a lot of memory. By clearing
the list, the memory is release, but items will be added for any location request 
made later on.
[Quick Info]
BCB=3,4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=3,4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Requirements=A detailed map file.
<DECL>--------------------------------------------------------------------------
[Declaration]
function __FILE__(const Level: Integer = 0): string;
[ShortDescr]
Returns the name of the file.
[Description]
__FILE__ returns the name of the source file in which the routine specified by
Level exists. Level 0 denotes the currently executing routine, 1 denotes the
caller of the routine, 2 the caller of the caller, etc.
[Parameters]
Count=1
1=Level:Integer=Caller level for which you want to know the source file in which
it resides. 0 is the currently executing routine, 1 is the caller, 2 is the caller
of the caller, etc.
[Result]
Filename of the source file in which the routine specified by Level exists.
[Notes]
Count=1
1=Usage of this function requires building the module with a detailed map file.
Use the Linker tab in the Project Options dialog to enable creation of a map file.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Requirements=A detailed map file.
[SeeAlso]
Count=7
1=__MODULE__
2=__PROC__
3=__LINE__
4=__FILE_OF_ADDR__
5=__MODULE_OF_ADDR__
6=__PROC_OF_ADDR__
7=__LINE_OF_ADDR__
<DECL>--------------------------------------------------------------------------
[Declaration]
function __MODULE__(const Level: Integer = 0): string;
[ShortDescr]
Returns the name of the unit in which a routine resides.
[Description]
__MODULE__ returns the name of the unit in which the routine specified by
Level exists. Level 0 denotes the currently executing routine, 1 denotes the
caller of the routine, 2 the caller of the caller, etc.
[Parameters]
Count=1
1=Level:Integer=Caller level for which you want to know the module name in which
it resides. 0 is the currently executing routine, 1 is the caller, 2 is the caller
of the caller, etc.
[Result]
Unit name in which the routine specified by Level exists.
[Notes]
Count=1
1=Usage of this function requires building the module with a detailed map file.
Use the Linker tab in the Project Options dialog to enable creation of a map file.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Requirements=A detailed map file.
[SeeAlso]
Count=7
1=__FILE__
2=__PROC__
3=__LINE__
4=__FILE_OF_ADDR__
5=__MODULE_OF_ADDR__
6=__PROC_OF_ADDR__
7=__LINE_OF_ADDR__
<DECL>--------------------------------------------------------------------------
[Declaration]
function __PROC__(const Level: Integer = 0): string;
[ShortDescr]
Returns the name of the routine at a specified level.
[Description]
__PROC__ returns the name of the procedure at the specified Level. Level 0 denotes
the currently executing routine, 1 denotes the caller of the routine, 2 the caller
of the caller, etc.
[Parameters]
Count=1
1=Level:Integer=Caller level for which you want to know the name. 0 is the
currently executing routine, 1 is the caller, 2 is the caller of the caller, etc.
[Result]
Name of the routine at the specified level.
[Notes]
Count=1
1=Usage of this function requires building the module with a detailed map file.
Use the Linker tab in the Project Options dialog to enable creation of a map file.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Requirements=A detailed map file.
[SeeAlso]
Count=7
1=__FILE__
2=__MODULE__
3=__LINE__
4=__FILE_OF_ADDR__
5=__MODULE_OF_ADDR__
6=__PROC_OF_ADDR__
7=__LINE_OF_ADDR__
<DECL>--------------------------------------------------------------------------
[Declaration]
function __LINE__(const Level: Integer = 0): Integer;
[ShortDescr]
Returns the line number in the source code file at which a routine is executing.
[Description]
__LINE__ returns the line number within the source code file at which the routine
specified by Level is currently executing. Level 0 denotes the currently executing
routine, 1 denotes the caller of the routine, 2 the caller of the caller, etc.
[Parameters]
Count=1
1=Level:Integer=Caller level for which you want to know the line number. 0 is the
currently executing routine, 1 is the caller, 2 is the caller of the caller, etc.
[Result]
Line number of the routine specified by Level.
[Notes]
Count=1
1=Usage of this function requires building the module with a detailed map file.
Use the Linker tab in the Project Options dialog to enable creation of a map file.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Requirements=A detailed map file.
[SeeAlso]
Count=9
1=__FILE__
2=__MODULE__
3=__PROC__
4=__MAP__
5=__FILE_OF_ADDR__
6=__MODULE_OF_ADDR__
7=__PROC_OF_ADDR__
8=__LINE_OF_ADDR__
9=__MAP_OF_ADDR__
<DECL>--------------------------------------------------------------------------
[Declaration]
function __MAP__(const Level: Integer; var _File, _Module, _Proc: string;
  var _Line: Integer): Boolean;
[ShortDescr]
Returns the file name, unit name, procedure name and line number at which a 
routine is executing.
[Description]
__MAP__ combines the __FILE__, __MODULE, __PROC__ and __LINE__ routines into a
single call.
[Parameters]
Count=5
1=Level:Integer=Caller level for which you want to get location information. 0 is the
currently executing routine, 1 is the caller, 2 is the caller of the caller, etc.
2=_File:string=File name of the routine specified by Level
3=_Module:string=Unit name of the routine specified by Level
4=_Proc:string=Procedure name of the routine specified by Level
5=_Line:Integer=Line number of the routine specified by Level
[Result]
Returns True if the information was found, otherwise False.
[Notes]
Count=1
1=Usage of this function requires building the module with a detailed map file.
Use the Linker tab in the Project Options dialog to enable creation of a map file.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Requirements=A detailed map file.
[SeeAlso]
Count=9
1=__FILE__
2=__MODULE__
3=__PROC__
4=__LINE__
5=__FILE_OF_ADDR__
6=__MODULE_OF_ADDR__
7=__PROC_OF_ADDR__
8=__LINE_OF_ADDR__
9=__MAP_OF_ADDR__
<DECL>--------------------------------------------------------------------------
[Declaration]
function __FILE_OF_ADDR__(const Addr: Pointer): string;
[ShortDescr]
Returns the filename for an address.
[Description]
__FILE_OF_ADDR__ returns the name of the source code file given an address.
[Parameters]
Count=1
1=Addr:Pointer=The address for which you want to know the source code file.
[Result]
Name of the source code file in which the specified address is defined.
[Notes]
Count=1
1=Usage of this function requires building the module with a detailed map file.
Use the Linker tab in the Project Options dialog to enable creation of a map file.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Requirements=A detailed map file.
[SeeAlso]
Count=9
1=__FILE__
2=__MODULE__
3=__PROC__
4=__LINE__
5=__MAP__
6=__MODULE_OF_ADDR__
7=__PROC_OF_ADDR__
8=__LINE_OF_ADDR__
9=__MAP_OF_ADDR__
<DECL>--------------------------------------------------------------------------
[Declaration]
function __MODULE_OF_ADDR__(const Addr: Pointer): string;
[ShortDescr]
Returns the module name for an address.
[Description]
__MODULE_OF_ADDR__ returns the name of the module given an address.
[Parameters]
Count=1
1=Addr:Pointer=The address for which you want to know the module name.
[Result]
Name of module in which the specified address is defined.
[Notes]
Count=1
1=Usage of this function requires building the module with a detailed map file.
Use the Linker tab in the Project Options dialog to enable creation of a map file.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Requirements=A detailed map file.
[SeeAlso]
Count=9
1=__FILE__
2=__MODULE__
3=__PROC__
4=__LINE__
5=__MAP__
6=__FILE_OF_ADDR__
7=__PROC_OF_ADDR__
8=__LINE_OF_ADDR__
9=__MAP_OF_ADDR__
<DECL>--------------------------------------------------------------------------
[Declaration]
function __PROC_OF_ADDR__(const Addr: Pointer): string;
[ShortDescr]
Returns the procedure name for an address.
[Description]
__PROC_OF_ADDR__ returns the name of the procedure given an address.
[Parameters]
Count=1
1=Addr:Pointer=Address for which you want to know the procedure.
[Result]
Name of the procedure in which Addr is defined.
[Notes]
Count=1
1=Usage of this function requires building the module with a detailed map file.
Use the Linker tab in the Project Options dialog to enable creation of a map file.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Requirements=A detailed map file.
[SeeAlso]
Count=9
1=__FILE__
2=__MODULE__
3=__PROC__
4=__LINE__
5=__MAP__
6=__FILE_OF_ADDR__
7=__MODULE_OF_ADDR__
8=__LINE_OF_ADDR__
9=__MAP_OF_ADDR__
<DECL>--------------------------------------------------------------------------
[Declaration]
function __LINE_OF_ADDR__(const Addr: Pointer): Integer;
[ShortDescr]
Returns the line number given an address.
[Description]
__LINE_OF_ADDR__ returns the line number in a source code file given an address.
[Parameters]
Count=1
1=Addr:Pointer=The address for which you want to know the line number.
[Result]
Line number at which the address is defined.
[Notes]
Count=1
1=Usage of this function requires building the module with a detailed map file.
Use the Linker tab in the Project Options dialog to enable creation of a map file.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Requirements=A detailed map file.
[SeeAlso]
Count=9
1=__FILE__
2=__MODULE__
3=__PROC__
4=__LINE__
5=__MAP__
6=__FILE_OF_ADDR__
7=__MODULE_OF_ADDR__
8=__PROC_OF_ADDR__
9=__MAP_OF_ADDR__
<DECL>--------------------------------------------------------------------------
[Declaration]
function __MAP_OF_ADDR__(const Addr: Pointer; var _File, _Module, _Proc: string;
  var _Line: Integer): Boolean;
[ShortDescr]
Returns the file name, unit name, procedure name and line number given an address.
[Description]
__MAP_OF_ADDR__ combines the __FILE_OF_ADDR__, __MODULE_OF_ADDR__, __PROC_OF_ADDR__ 
and __LINE_OF_ADDR__ routines into a single call.
[Parameters]
Count=5
1=Addr:Pointer=The address for which you want to know the location information.
2=_File:string=File name of the routine specified by Level
3=_Module:string=Unit name of the routine specified by Level
4=_Proc:string=Procedure name of the routine specified by Level
5=_Line:Integer=Line number of the routine specified by Level
[Result]
Returns True if the information was found, otherwise False.
[Notes]
Count=1
1=Usage of this function requires building the module with a detailed map file.
Use the Linker tab in the Project Options dialog to enable creation of a map file.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Requirements=A detailed map file.
[SeeAlso]
Count=9
1=__FILE__
2=__MODULE__
3=__PROC__
4=__LINE__
5=__MAP__
6=__FILE_OF_ADDR__
7=__MODULE_OF_ADDR__
8=__PROC_OF_ADDR__
9=__LINE_OF_ADDR__
<DECL>--------------------------------------------------------------------------
[Declaration]
PStackFrame = ^TStackFrame;
TStackFrame = record
  CallersEBP: DWORD;
  CallerAdr: DWORD;
end;
[ShortDescr]
Stack frame information
[Description]
TStackFrame holds stack frame information.
[RecordFields]
Count=2
1=CallersEBP:DWORD=Callers EBP register
2=CallerAdr:DWORD=Address of caller
[Quick Info]
Kind=Type
BCB=4,5
Kind=Type
Unit=JclDebug
Category=Debugging
SubCat=Stack info routines
Author=Hallvard Vassbotn;hallvard.vassbotn@c2i.net
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
TStackInfo = record
  CallerAdr: DWORD;
  Level: DWORD;
  CallersEBP: DWORD;
  DumpSize: DWORD;
  ParamSize: DWORD;
  ParamPtr: PDWORDArray;
  case Integer of
    0: (StackFrame: <REF>PStackFrame</REF>);
    1: (DumpPtr: PByteArray);
end;
[ShortDescr]
Stack information
[Description]
TStackInfo holds stack information.
[RecordFields]
Count=8
1=CallerAdr:DWORD=Return address  (the address of the caller)
2=Level:DWORD=Caller level
3=CallersEBP:DWORD=EBP register of caller (only filled if the trace was not a raw stack trace)
4=DumpSize:DWORD=Length of memory block between callers frame and this frame (only filled if the trace was not a raw stack trace)
5=ParamSize:DWORD=Number of DWORD parameters (only filled if the trace was not a raw stack trace)
6=ParamPtr:PDWORDArray=Points to the parameters (only filled if the trace was not a raw stack trace)
7=StackFrame:PStackFrame=Current stack frame (only filled if the trace was not a raw stack trace)
8=DumpPtr:PByteArray=Points to the memory block of the stack frame (only filled if the trace was not a raw stack trace)
[Quick Info]
Kind=Type
BCB=4,5
Kind=Type
Unit=JclDebug
Category=Debugging
SubCat=Stack info routines
Author=Hallvard Vassbotn;hallvard.vassbotn@c2i.net
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
TJclStackInfoItem = class (TObject)
[ShortDescr]
Stack information item
[Description]
TStackInfoItem holds stack information.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Stack info routines\TJclStackInfoItem
Author=Hallvard Vassbotn;hallvard.vassbotn@c2i.net
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
property LogicalAddress: DWORD read GetLogicalAddress;
[ShortDescr]
Retreives the logical address for the caller
[Description]
LogicalAddress retreives teh logical address for the caller. It does so by 
subtracting the caller's module base address from the caller's address.
[Quick Info]
BCB=4,5
Kind=Property
Visibility=Public
Unit=JclDebug
Category=Debugging
SubCat=Stack info routines\TJclStackInfoItem
Author=Hallvard Vassbotn;hallvard.vassbotn@c2i.net
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
property StackInfo: TStackInfo read FStackInfo;
[ShortDescr]
Stack information.
[Description]
StackInfo holds the actual stack information.
[Quick Info]
BCB=4,5
Kind=Property
Visibility=Public
Unit=JclDebug
Category=Debugging
SubCat=Stack info routines\TJclStackInfoItem
Author=Hallvard Vassbotn;hallvard.vassbotn@c2i.net
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
TJclStackInfoList = class (TObjectList)
[ShortDescr]
Stack information list
[Description]
TStackInfoList holds a list of stack information items (<REF Target"..\TJclStackInfoItem\TJclStackInfoItem"TJclStackInfoItem</REF>).
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Stack info routines\TJclStackInfoList
Author=Hallvard Vassbotn;hallvard.vassbotn@c2i.net
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
constructor Create(Raw: Boolean; AIgnoreLevels: DWORD; FirstCaller: Pointer);
[ShortDescr]
Instantiates a stack list.
[Description]
Create instantiates a stack list and immediately executes the trace.
[Parameters]
Count=3
1=Raw:Boolean=When set to False, the stack is traced by means of the EBP frame, 
when set to True, all DWORDs are checked for valid caller addresses.
2=AIgnoreLevels:DWORD=Number of callers to ignore upon tracing.
3=FirstCaller:Pointer=If not nil, an explicit TJclStackInfoItem is added to the
list, pointing to the FirstCaller.
[Quick Info]
BCB=4,5
Kind=Method
Visibility=Public
Unit=JclDebug
Category=Debugging
SubCat=Stack info routines\TJclStackInfoList
Author=Hallvard Vassbotn;hallvard.vassbotn@c2i.net
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure AddToStrings(Strings: TStrings);
[ShortDescr]
Adds all stack info items a list.
[Description]
AddToStrings adds all stack info items to a TStrings descendant. For each stack
info item it stores the result of the call GetLocationInfoStr(CallerAddress).
[Parameters]
Count=1
1=String:TStrings=TStrings descendant to retreive the stack trace in.
[Quick Info]
BCB=4,5
Kind=Method
Visibility=Public
Unit=JclDebug
Category=Debugging
SubCat=Stack info routines\TJclStackInfoList
Author=Hallvard Vassbotn;hallvard.vassbotn@c2i.net
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
property Items[Index: Integer]: TJclStackInfoItem read GetItems; default;
[ShortDescr]
List of stack info items
[Description]
Items is a reference to all stack info items obtained during the trace.
[Quick Info]
BCB=4,5
Kind=Property
Visibility=Public
Unit=JclDebug
Category=Debugging
SubCat=Stack info routines\TJclStackInfoList
Author=Hallvard Vassbotn;hallvard.vassbotn@c2i.net
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
property IgnoreLevels: DWORD read FIgnoreLevels;
[ShortDescr]
Number of levels ignored in the trace
[Description]
IgnoreLevels is the number of levels that were ignored when the trace started. This 
number was given upon creation of the list.
[Quick Info]
BCB=4,5
Kind=Property
Visibility=Public
Unit=JclDebug
Category=Debugging
SubCat=Stack info routines\TJclStackInfoList
Author=Hallvard Vassbotn;hallvard.vassbotn@c2i.net
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
property ThreadID: DWORD read FThreadID;
[ShortDescr]
ID of thread that made the trace.
[Description]
ThreadID is ID of the thread that executed the trace.
[Quick Info]
BCB=4,5
Kind=Property
Visibility=Public
Unit=JclDebug
Category=Debugging
SubCat=Stack info routines\TJclStackInfoList
Author=Hallvard Vassbotn;hallvard.vassbotn@c2i.net
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
property TimeStamp: TDateTime read FTimeStamp;
[ShortDescr]
Time stamp of list creation
[Description]
TimeStamp holds the date and time of creation of the list.
[Quick Info]
BCB=4,5
Kind=Property
Visibility=Public
Unit=JclDebug
Category=Debugging
SubCat=Stack info routines\TJclStackInfoList
Author=Hallvard Vassbotn;hallvard.vassbotn@c2i.net
Delphi=4,5