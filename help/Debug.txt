<DECL>--------------------------------------------------------------------------
[Declaration]
function IsHandleValid(Handle: THandle): Boolean;
[ShortDescr]
Tests whether a handle is valid.
[Description]
The IsHandleValid determines whether a handle is valid. The handle can point to
any kind of Win32 object such as a file, mutex or console screen buffer. Note that
the result of this function is only an indication of whether the handle points
to a valid object. Since handles are reused by Win32 it is possible that the
handle actually points to a different object than you thought. More reason to
always set handles to 0 or INVALID_HANDLE_VALUE immediately after you close it.
[Parameters]
Count=1
1=Handle:THandle=The handle to test for validity.
[Result]
If the specified handle is valid the function returns True. If the specified
handle is invalid the function returns False.
[Quick Info]
BCB=3,4,5
Unit=JclDebug
Category=Debugging
SubCat=Miscellanuous
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function IsDebuggerAttached: Boolean;
[ShortDescr]
Determines whether the calling process is running under the context of a debugger.
[Description]
The IsDebuggerAttached function determines whether the calling process is running
under the context of a debugger. Unlike the IsDebuggerPresent API function, this
one also functions correctly under Windows 95.
[Result]
If the current process is running in the context of a debugger, the return value is True.
If the current process is not running in the context of a debugger, the return value is False.
[Quick Info]
BCB=3,4,5
Unit=JclDebug
Category=Debugging
SubCat=Miscellanuous
Author=Petr Vones;petr.v@mujmail.cz
Delphi=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function EnableCrashOnCtrlScroll(const Enable: Boolean): Boolean;
[ShortDescr]
Enables manually crashing Windows.
[Description]
EnableCrashOnCtrlScroll enables crashing Windows 2000 using the keyboard. After
this has been enabled you can bugcheck Windows 2000 by holding down the right
control key and pressing the scroll key twice. On the second press Windows will
bugcheck with code 0x000000E2. Note that this function simply modifies a registry
entry, to actually enable this 'feature' you must reboot first.
[Parameters]
Count=1
1=Enable:Boolean=If set to True the crash on ctrl scroll 'feature' is enabled, if
set to False it is disabled.
[Result]
If the function succeeds it returns True, otherwise it returns False.
[Quick Info]
BCB=3,4,5
Unit=JclDebug
Category=Debugging
SubCat=Miscellanuous
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
Windows NT/2000=Requires Windows NT 2000 or later.
Windows 95/98=Unsupported.
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure AssertKindOf(const ClassName: string; const Obj: TObject); overload;
procedure AssertKindOf(const ClassType: TClass; const Obj: TObject); overload;
[ShortDescr]
Asserts that an object is of a specified class.
[Description]
AssertKindOf asserts that the specified object is of the specified type or inherits
from that type. If this is not the case the function triggers an assertion failure.
The overloaded procedure allows you to directly specify a class type instead of
a class name.
[Parameters]
Count=2
1=ClassName:string=Name of the class to test Obj for.
2=Obj:TObject=The object to test.
[Quick Info]
BCB=3,4,5
Unit=JclDebug
Category=Debugging
SubCat=Diagnostics
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure Trace(const Msg: string);
[ShortDescr]
Sends a message to the debugger.
[Description]
Trace sends the specified message to the debugger.
[Parameters]
Count=1
1=Msg:string=The message to send to the debugger.
[Notes]
Count=1
1=If you are running your application under the control of the debugger you can view
these messages using the event log dialog, 'View | Debug Windows | Event Log'.
If the application is not running under the debugger the message is sent to the
system debugger. If there is no system debugger active the function does nothing.
[Quick Info]
BCB=3,4,5
Unit=JclDebug
Category=Debugging
SubCat=Diagnostics
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
[SeeAlso]
Count=3
1=TraceFmt
2=TraceLoc
3=TraceLocFmt
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure TraceFmt(const Fmt: string; const Args: array of const);
[ShortDescr]
Sends a formatted message to the debugger.
[Description]
TraceFmt sends a message, formatted from the supplied format string and
arguments array, to the debugger. The function uses the VCL Format() function
to format the string and therefore you can use this function exactly like you
would use Format(). See the Delphi help file for more information.
[Parameters]
Count=2
1=Fmt:string=Controls the formatting of the message.
2=Args:array of const=Arguments formatted under control of the Fmt string.
[Notes]
Count=1
1=If you are running your application under the control of the debugger you can view
these messages using the event log dialog, 'View | Debug Windows | Event Log'.
If the application is not running under the debugger the message is sent to the
system debugger. If there is no system debugger active the function does nothing.
[Quick Info]
BCB=3,4,5
Unit=JclDebug
Category=Debugging
SubCat=Diagnostics
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
[SeeAlso]
Count=3
1=Trace
2=TraceLoc
3=TraceLocFmt
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure TraceLoc(const Msg: string);
[ShortDescr]
Sends a message to the debugger including location information.
[Description]
TraceLoc sends the specified message to the debugger but first prepends it with
the source file location from which TraceLoc is called. For example, when calling
TraceLoc from a method called TForm1.Button1Click located in unit1.pas like
this: TraceLoc('Trace me.') the resulting string sent to the debugger will be:<BR>
  unit.pas:123 (TForm1.ButtonClick) "Trace me." <BR>
assuming the TraceLoc statement is on line 123 in the source. Note that this
function requires a detailed map file!
[Parameters]
Count=1
1=Msg:string=The message to send to the debugger.
[Notes]
Count=1
1=If you are running your application under the control of the debugger you can view
these messages using the event log dialog, 'View | Debug Windows | Event Log'.
If the application is not running under the debugger the message is sent to the
system debugger. If there is no system debugger active the function does nothing.
[Quick Info]
BCB=3,4,5
Unit=JclDebug
Category=Debugging
SubCat=Diagnostics
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Requirements=A detailed map file.
[SeeAlso]
Count=3
1=Trace
2=TraceFmt
3=TraceLocFmt
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure TraceLocFmt(const Fmt: string; const Args: array of const);
[ShortDescr]
Sends a formatted message to the debugger prepending it with location information.
[Description]
TraceFmt sends a message, formatted from the supplied format string and
arguments array, to the debugger, but first prepends it with the source file location
information. The function uses the VCL Format() function to format the string and
therefore you can use this function exactly like you would use Format().
See the Delphi help file for more information. See <REF>TraceLoc</REF> for an
example output.
[Parameters]
Count=2
1=Fmt:string=Controls the formatting of the message.
2=Args:array of const=Arguments formatted under control of the Fmt string.
[Notes]
Count=1
1=If you are running your application under the control of the debugger you can view
these messages using the event log dialog, 'View | Debug Windows | Event Log'.
If the application is not running under the debugger the message is sent to the
system debugger. If there is no system debugger active the function does nothing.
[Quick Info]
BCB=3,4,5
Unit=JclDebug
Category=Debugging
SubCat=Diagnostics
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Requirements=A detailed map file.
[SeeAlso]
Count=3
1=Trace
2=TraceFmt
3=TraceLoc
<DECL>--------------------------------------------------------------------------
[Declaration]
TJclMapAddress = packed record
  Segment: Word;
  Offset: Integer;
end;
[ShortDescr]
Holds location information.
[Description]
TJclMapAddress holds location information in notifiers of the map parsers.
[RecordFields]
Count=2
1=Segment:Word=Segment number of item.
2=Offset:Integer=Offset of item.
[Quick Info]
Kind=Type
BCB=4,5
Kind=Type
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
PJclMapString = PAnsiChar;
[ShortDescr]
A map-file string
[Description]
PJclMapString holds a map-file specific string. Use the MapStringToString class
function to convert it to a normal string.
[Quick Info]
Kind=Type
BCB=4,5
Kind=Type
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
TJclAbstractMapParser = class (TObject)
[ShortDescr]
Abstract Map parser
[Description]
TJclAbstractMapParser is an abstract base class for a MAP-file parser.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclAbstractMapParser
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure ClassTableItem(const Address: <REF Target"..\..\Types\TJclMapAddress">TJclMapAddress</REF>; Len: Integer; SectionName, GroupName: <REF Target"..\..\Types\PJclMapString">PJclMapString</REF>); virtual; abstract;
[ShortDescr]
Handler for a class item
[Description]
ClassTableItem is a handler for a class item (eg. CODE, DATA or BSS class) in
the map file. It get's called by the Parse method when it finds a class table item.
[Parameters]
Count=4
1=Address:TJclMapAddress=Address of the class item.
2=Len:Integer=Length of the class item.
3=SectionName=Section name of the class item (eg. ".text").
4=GroupName=Class name of the class item (eg. "CODE").
[Quick Info]
Kind=Method
Visibility=Protected
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclAbstractMapParser
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure SegmentItem(const Address: <REF Target"..\..\Types\TJclMapAddress">TJclMapAddress</REF>; Len: Integer; GroupName, UnitName: <REF Target"..\..\Types\PJclMapString">PJclMapString</REF>); virtual; abstract;
[ShortDescr]
Handler for a segment item (i.e.. a Delphi unit)
[Description]
SegmentItem is a handler for a segment item (i.e.. a Delphi unit) in the map file.
It gets called by the Parse method when it finds a segment item.
[Parameters]
Count=4
1=Address:TJclMapAddress=Address of the segment item.
2=Len:Integer=Length of the segment item.
3=GroupName:PJclMapString=Class name of the segment item (eg. "CODE").
4=UnitName:PJclMapString=Delphi unit name of the segment item (eg. "System").
[Quick Info]
Kind=Method
Visibility=Protected
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclAbstractMapParser
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure PublicsByNameItem(const Address: <REF Target"..\..\Types\TJclMapAddress">TJclMapAddress</REF>; Name: <REF Target"..\..\Types\PJclMapString">PJclMapString</REF>); virtual; abstract;
[ShortDescr]
Handler for a public item in the publics by name section.
[Description]
PublicsByNameItem is a handler for a public item (eg. a procedure) in the "Publics
By Name"-section of the map file.
It gets called by the Parse method when it finds a public item in the "Publics
By Name"-section.
[Parameters]
Count=2
1=Address:TJclMapAddress=Address of the public item.
2=Name:PJclMapString=Name of the public item.
[Quick Info]
Kind=Method
Visibility=Protected
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclAbstractMapParser
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure PublicsByValueItem(const Address: <REF Target"..\..\Types\TJclMapAddress">TJclMapAddress</REF>; Name: <REF Target"..\..\Types\PJclMapString">PJclMapString</REF>); virtual; abstract;
[ShortDescr]
Handler for a public item in the publics by value section.
[Description]
PublicsByValueItem is a handler for a public item (eg. a procedure) in the "Publics
By Value"-section of the map file.
It gets called by the Parse method when it finds a public item in the "Publics
By Value"-section.
[Parameters]
Count=2
1=Address:TJclMapAddress=Address of the public item.
2=Name:PJclMapString=Name of the public item.
[Quick Info]
Kind=Method
Visibility=Protected
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclAbstractMapParser
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure LineNumberUnitItem(UnitName, UnitFileName: <REF Target"..\..\Types\PJclMapString">PJclMapString</REF>); virtual; abstract;
[ShortDescr]
Handler for a unit declaration in the lines section.
[Description]
LineNumberUnitItem is a handler for a unit declaration in the lines section
of the map file. It gets called by the Parse method when it finds a unit
declaration in the lines section.
[Parameters]
Count=2
1=UnitName:PJclMapString=Name of the unit.
2=UnitFileName:PJclMapString=Name of the source file.
[Quick Info]
Kind=Method
Visibility=Protected
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclAbstractMapParser
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure LineNumbersItem(LineNumber: Integer; const Address: <REF Target"..\..\Types\TJclMapAddress">TJclMapAddress</REF>); virtual; abstract;
[ShortDescr]
Handler for a line declaration in the lines section.
[Description]
LineNumbers is a handler for a line declaration in the lines section
of the map file. It gets called by the Parse method when it finds a unit
declaration in the lines section.
[Parameters]
Count=2
1=LineNumber:Integer=Line number for the item.
2=Address:PJclMapAddress=Starting address for the line number.
[Quick Info]
Kind=Method
Visibility=Protected
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclAbstractMapParser
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
constructor Create(const MapFileName: TFileName); virtual;
[ShortDescr]
Creates an instance of TJclAbstractMapParser
[Description]
The Create method instantiates a map-parser object. Since TJclAbstractMapParser
is an abstract base class, you should not Create an instance of
TJclAbstractMapParser directly, but rather of a descendant.</P><P>
If the specified file exists, a <REF Target"..\..\..\..\..\Files and IO\Streams\TJclFileMapping\TJclFileMapping">TJclFileMappingStream</REF> will be assigned to
the Stream property, referencing the map file.
[Parameters]
Count=1
1=MapFileName:TFileName=Name of the map-file to associate with the parser.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclAbstractMapParser
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
destructor Destroy; override;
[ShortDescr]
Destroys an instance of TJclAbstractMapParser
[Description]
Destroy frees up all internal objects before freeing this instance.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclAbstractMapParser
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure Parse;
[ShortDescr]
Parses the map file
[Description]
Parse parses the map file specified referenced by the Stream property. It calls
different methods for items found in the file. Descendants override these methods
to store it in an internal structure.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclAbstractMapParser
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
class function MapStringToStr(MapString: <REF Target"..\..\Types\PJclMapString">PJclMapString</REF>): string;
[ShortDescr]
Translates map file specific strings to a normal string.
[Description]
MapStringToStr translates map file specific strings to a normal string.</P><P>
If MapString points to an opening bracket, it returns the text starting
at the next character up to the closing bracket or a Carriage Return, whichever
comes first.<BR>
If MapString does not point to an opening bracket, it returns the text from
the current location up to the next space, a carriage return or a closing bracket.
[Parameters]
Count=1
1=MapString:PJclMapString=String to translate
[Result]
If MapString = nil the function returns an empty string, otherwise it returns
translated version of the string.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclAbstractMapParser
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
property Stream: TJclFileMappingStream read FStream;
[ShortDescr]
A stream referencing the map file
[Description]
Stream holds the a reference to the map file assigned by the Create method.
[Quick Info]
Kind=Property
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclAbstractMapParser
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
property LinkerBug: Boolean read FLinkerBug;
[ShortDescr]
Is the linker bug found in the map
[Description]
LinkerBug holds a flag to determine if the linker bug is found in the map file.
The bug appears if a unit has >64K of data after the code and another unit
follows. The solution is to move the data to a separate unit.
[Quick Info]
Kind=Property
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclAbstractMapParser
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
[SeeAlso]
Count=1
1=LinkerBugUnit
<DECL>--------------------------------------------------------------------------
[Declaration]
property LinkerBugUnitName: string read GetLinkerBugUnitName;
[ShortDescr]
Unit name of where the linker bug occured.
[Description]
LinkerBugUnit holds the name of the unit containing the linker bug. If there's
no linker bug present (ie. LinkerBug = False) LinkerBugUnit is empty.
[Quick Info]
Kind=Property
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclAbstractMapParser
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
[SeeAlso]
Count=1
1=LinkerBug
<DECL>--------------------------------------------------------------------------
[Declaration]
TJclMapParser = class (<REF Target"..\TJclAbstractMapParser\TJclAbstractMapParser">TJclAbstractMapParser</REF>)
[ShortDescr]
Generic map file parser
[Description]
TJclMapParser is a class for a generic MAP-file parser. Items are reported to
the user through event calls.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclMapParser
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
property OnClassTable: TJclMapClassTableEvent read FOnClassTable write FOnClassTable;
[ShortDescr]
Event handler for a class item.
[Description]
OnClassTable is the event handler for a class item in the map file. It get's called by
the ClassTableItem method when the parser finds a class table item.
[Quick Info]
Kind=Property
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclMapParser
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
property OnSegment: TJclMapSegmentEvent read FOnSegmentItem write FOnSegmentItem;
[ShortDescr]
Event handler for a segment item (i.e.. a Delphi unit)
[Description]
OnSegment is the event handler for a segment item (i.e.. a Delphi unit) in the map file.
It gets called by the SegmentItem method when the parser finds a segment item.
[Quick Info]
Kind=Property
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclMapParser
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
property OnPublicsByName: TJclMapPublicsEvent read FOnPublicsByName write FOnPublicsByName;
[ShortDescr]
Event handler for a public item in the publics by name section.
[Description]
OnPublicsByName is the event handler for a public item (eg. a procedure) in the "Publics
By Name"-section of the map file.
It gets called by the PublicsByNameItem method when the parser finds a public item in
the "Publics By Name"-section.
[Quick Info]
Kind=Property
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclMapParser
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
property OnPublicsByValue: TJclMapPublicsEvent read FOnPublicsByValue write FOnPublicsByValue;
[ShortDescr]
Event handler for a public item in the publics by value section.
[Description]
OnPublicsByValue is the event handler for a public item (eg. a procedure) in the "Publics
By Value"-section of the map file.
It gets called by the PublicsByValueItem method when the parser finds a public item in
the "Publics By Value"-section.
[Quick Info]
Kind=Property
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclMapParser
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
property OnLineNumberUnit: TJclMapLineNumberUnitEvent read FOnLineNumberUnit write FOnLineNumberUnit;
[ShortDescr]
Event handler for a unit declaration in the lines section.
[Description]
OnLineNumberUnit is the event handler for a unit declaration in the lines section
of the map file. It gets called by the LineNumberUnitItem method when the parser
finds a unit declaration in the lines section.
[Quick Info]
Kind=Property
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclMapParser
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
property OnLineNumbers: TJclMapLineNumbersEvent read FOnLineNumbers write FOnLineNumbers;
[ShortDescr]
Event handler for a line declaration in the lines section.
[Description]
OnLineNumbers is the event handler for a line declaration in the lines section
of the map file. It gets called by the LineNumbers method when the parser finds
a unit declaration in the lines section.
[Quick Info]
Kind=Property
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclMapParser
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
TJclMapScanner = class (<REF Target"..\TJclAbstractMapParser\TJclAbstractMapParser">TJclAbstractMapParser</REF>)
[ShortDescr]
Generic map file parser
[Description]
TJclMapScanner is a map file scanner. The class scans the map file and holds the
result for later reference.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclMapScanner
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure Scan;
[ShortDescr]
Scans the map file.
[Description]
Scan scans the map file specified by Create and stores the result for later
reference.
[Quick Info]
Kind=Method
Visibility=Protected
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclMapScanner
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
constructor Create(const MapFileName: TFileName);
[ShortDescr]
Creates an instance of TJclMapScanner
[Description]
The Create method instantiates a map-file scanner object. After calling the
inherited Create from <REF Target"..\TJclAbstractMapParser\TJclAbstractMapParser">TJclAbstractMapParser</REF>,
the scan method will be called to scan the file.
[Parameters]
Count=1
1=MapFileName:TFileName=Name of the map-file to associate with the parser.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclMapScanner
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function LineNumberFromAddr(Addr: DWORD): Integer;
[ShortDescr]
Returns the line number for an address.
[Description]
LineNumberFromAddr returns the line number for the specified address.
[Parameters]
Count=1
1=Addr:DWORD=Address to get line number for.
[Result]
The line number for the specified address.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclMapScanner
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
[SeeAlso]
Count=4
1=ModuleNameFromAddr
2=ModuleStartFromAddr
3=ProcNameFromAddr
4=SourceNameFromAddr
<DECL>--------------------------------------------------------------------------
[Declaration]
function ModuleNameFromAddr(Addr: DWORD): string;
[ShortDescr]
Returns the Delphi unit name for an address.
[Description]
ModuleNameFromAddr returns the Delphi unit name for the specified address.
[Parameters]
Count=1
1=Addr:DWORD=Address to get unit name for.
[Result]
The Delphi unit name for the specified address.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclMapScanner
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
[SeeAlso]
Count=4
1=LineNumberFromAddr
2=ModuleStartFromAddr
3=ProcNameFromAddr
4=SourceNameFromAddr
<DECL>--------------------------------------------------------------------------
[Declaration]
function ModuleStartFromAddr(Addr: DWORD): DWORD;
[ShortDescr]
Returns the starting address of a module given an address.
[Description]
ModuleStartFromAddr returns the starting address of the Delphi unit that contains
the specified address.
[Parameters]
Count=1
1=Addr:DWORD=Address to get unit start for.
[Result]
The starting address of the Delphi unit that contains the specified address.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclMapScanner
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
[SeeAlso]
Count=4
1=LineNumberFromAddr
2=ModuleNameFromAddr
3=ProcNameFromAddr
4=SourceNameFromAddr
<DECL>--------------------------------------------------------------------------
[Declaration]
function ProcNameFromAddr(Addr: DWORD): string;
[ShortDescr]
Returns the procedure name for an address.
[Description]
ProcNameFromAddr returns the procedure name for the specified address.
[Parameters]
Count=1
1=Addr:DWORD=Address to get procedure name for.
[Result]
The procedure name for the specified address.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclMapScanner
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
[SeeAlso]
Count=4
1=LineNumberFromAddr
2=ModuleNameFromAddr
3=ModuleStartFromAddr
4=SourceNameFromAddr
<DECL>--------------------------------------------------------------------------
[Declaration]
function SourceNameFromAddr(Addr: DWORD): string;
[ShortDescr]
Returns the source file name for an address.
[Description]
SourceNameFromAddr returns the source-file name for the specified address.
[Parameters]
Count=1
1=Addr:DWORD=Address to get procedure name for.
[Result]
The source file name for the specified address.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Map Parsers\TJclMapScanner
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
[SeeAlso]
Count=4
1=LineNumberFromAddr
2=ModuleNameFromAddr
3=ModuleStartFromAddr
4=ProcNameFromAddr
<DECL>--------------------------------------------------------------------------
[Declaration]
JclDbgDataSignature = $4742444A; // JDBG
[ShortDescr]
Signature of Jcl Binary Debug Data
[Description]
JclDbgDataSignature is the signature of the Jcl Binary Debug Data
[Quick Info]
Kind=Constant
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Binary Debug Data
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
JclDbgDataResName = 'JCLDEBUG';
[ShortDescr]
Resource name for binary debug data
[Description]
JclDbgDataResName is the resource name for Jcl Binary Debug Data.
[Quick Info]
Kind=Constant
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Binary Debug Data
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
JclDbgFileExtension = '.jdbg';
[ShortDescr]
File extension for a Jcl Binary Debug File
[Description]
JclDbgFileExtension is the extension for Jcl Binary Debug Data File.
[Quick Info]
Kind=Constant
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Binary Debug Data
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
TJclBinDebugGenerator = class (<REF Target"..\..\Map Parsers\TJclMapScanner\TJclMapScanner">TJclMapScanner</REF>)
[ShortDescr]
Generates a binary version of a map file.
[Description]
TJclBinDebugGenerator translates the text based map file created by the linker into
a smaller, binary version. The result is saved in a memory stream.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Binary Debug Data\TJclBinDebugGenerator
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure CreateData;
[ShortDescr]
Translates the map file
[Description]
CreateData translates the text based map file into a binary version and stores it
in a memorystream, referenced by the <REF Target"..\Properties\DataStream">DataStream</REF>
property. CreateData gets called by the Create method automatically.</P><P>
Literal strings are compressed into a 6-bit character, which results in a compression of
3:4. Furthermore, it doesn't store spaces and integers are stored as integer values (always
4 bytes instead of 8-byte hex-string). This results in a considerable savings on
needed space.
[Quick Info]
Kind=Method
Visibility=Protected
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Binary Debug Data\TJclBinDebugGenerator
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
constructor Create(const MapFileName: TFileName);
[ShortDescr]
Creates an instance of TJclBinDebugGenerator
[Description]
The Create method instantiates a binary debug generator object. After calling the
inherited Create from <REF Target"..\..\TJclMapScanner\TJclMapScanner">TJclMapScanner</REF>,
the <REF>CreateData</REF> method will be called to convert the text-based map file to a
binary version.
[Parameters]
Count=1
1=MapFileName:TFileName=Name of the map-file to associate with the parser.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Binary Debug Data\TJclBinDebugGenerator
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function CalculateCheckSum: Boolean;
[ShortDescr]
Calculates the checksum of the binary data.
[Description]
CalculateChecksum calculates the checksum of the binary debug data.
[Result]
If the checksum could be calculated the function returns True, otherwise it returns
False.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Binary Debug Data\TJclBinDebugGenerator
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
property DataStream: TMemoryStream read FDataStream;
[ShortDescr]
A memory stream holding the translation result.
[Description]
DataStream holds the result of the translation.
[Quick Info]
Kind=Property
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Binary Debug Data\TJclBinDebugGenerator
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
TJclBinDebugScanner = class (TObject)
[ShortDescr]
Scans a binary version of a map file.
[Description]
TJclBinDebugScanner is like the TJclMapScanner except that it scans a binary map
file. The binary file can be generated from a text-based map file by instantiating
a <REF Target"..\TJclBinDebugGenerator\TJclBinDebugGenerator">TJclBinDebugGenerator</REF>-object 
and saving the DataStream to a file.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Binary Debug Data\TJclBinDebugScanner
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
constructor Create(AStream: TCustomMemoryStream; CacheData: Boolean);
[ShortDescr]
Creates an instance of TJclBinDebugScanner
[Description]
The Create method instantiates a binary debug scanner object. After instantiating
and assigning the stream, the format is checked. You can use the <REF Target"..\Properties\ValidFormat">ValidFormat</REF>-property
to check if the stream actually contains binary debug data.
[Parameters]
Count=2
1=AStream:TCustomMemoryStream=Stream with binary debug data.
2=CacheData:Boolean=If set to true, data read from the stream is internally cached.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Binary Debug Data\TJclBinDebugScanner
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function IsModuleNameValid(const Name: TFileName): Boolean;
[ShortDescr]
Checks if the given filename is a valid name for the module.
[Description]
IsModuleNameValid checks if the given filename is a valid name for the module.
[Parameters]
Count=1
1=Name:TFileName=Filename to check
[Result]
If the specified filename belongs to this module the function returns True, 
otherwise it returns False.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Binary Debug Data\TJclBinDebugScanner
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function LineNumberFromAddr(Addr: DWORD): Integer;
[ShortDescr]
Returns the line number for an address.
[Description]
LineNumberFromAddr returns the line number for the specified address.
[Parameters]
Count=1
1=Addr:DWORD=Address to get line number for.
[Result]
The line number for the specified address.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Binary Debug Data\TJclBinDebugScanner
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
[SeeAlso]
Count=4
1=ModuleNameFromAddr
2=ModuleStartFromAddr
3=ProcNameFromAddr
4=SourceNameFromAddr
<DECL>--------------------------------------------------------------------------
[Declaration]
function ModuleNameFromAddr(Addr: DWORD): string;
[ShortDescr]
Returns the Delphi unit name for an address.
[Description]
ModuleNameFromAddr returns the Delphi unit name for the specified address.
[Parameters]
Count=1
1=Addr:DWORD=Address to get unit name for.
[Result]
The Delphi unit name for the specified address.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Binary Debug Data\TJclBinDebugScanner
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
[SeeAlso]
Count=4
1=LineNumberFromAddr
2=ModuleStartFromAddr
3=ProcNameFromAddr
4=SourceNameFromAddr
<DECL>--------------------------------------------------------------------------
[Declaration]
function ModuleStartFromAddr(Addr: DWORD): DWORD;
[ShortDescr]
Returns the starting address of a module given an address.
[Description]
ModuleStartFromAddr returns the starting address of the Delphi unit that contains
the specified address.
[Parameters]
Count=1
1=Addr:DWORD=Address to get unit start for.
[Result]
The starting address of the Delphi unit that contains the specified address.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Binary Debug Data\TJclBinDebugScanner
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
[SeeAlso]
Count=4
1=LineNumberFromAddr
2=ModuleNameFromAddr
3=ProcNameFromAddr
4=SourceNameFromAddr
<DECL>--------------------------------------------------------------------------
[Declaration]
function ProcNameFromAddr(Addr: DWORD): string;
[ShortDescr]
Returns the procedure name for an address.
[Description]
ProcNameFromAddr returns the procedure name for the specified address.
[Parameters]
Count=1
1=Addr:DWORD=Address to get procedure name for.
[Result]
The procedure name for the specified address.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Binary Debug Data\TJclBinDebugScanner
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
[SeeAlso]
Count=4
1=LineNumberFromAddr
2=ModuleNameFromAddr
3=ModuleStartFromAddr
4=SourceNameFromAddr
<DECL>--------------------------------------------------------------------------
[Declaration]
function SourceNameFromAddr(Addr: DWORD): string;
[ShortDescr]
Returns the source file name for an address.
[Description]
SourceNameFromAddr returns the source-file name for the specified address.
[Result]
The source file name for the specified address.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Binary Debug Data\TJclBinDebugScanner
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
[SeeAlso]
Count=4
1=LineNumberFromAddr
2=ModuleNameFromAddr
3=ModuleStartFromAddr
4=ProcNameFromAddr
<DECL>--------------------------------------------------------------------------
[Declaration]
property ValidFormat: Boolean read FValidFormat;
[ShortDescr]
Flag to check validity of data
[Description]
ValidFormat is true if the data in the specified stream is valid binary debug data.
[Quick Info]
Kind=Property
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Binary Debug Data\TJclBinDebugScanner
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function ConvertMapFileToJdbgFile(const MapFileName: TFileName): Boolean;
[ShortDescr]
Converts a text based MAP file to a Jcl binary debug file.
[Description]
ConvertMapFileToJdbgFile convert the specified text based map file to a Jcl binary
debug file.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\Binary Debug Data
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
TJclLocationInfo = record
  Address: Pointer;
  UnitName: string;
  ProcedureName: string;
  LineNumber: Integer;
  SourceName: string;
  DebugInfo: <REF Target"..\TJclDebugInfoSource\TJclDebugInfoSource">TJclDebugInfoSource</REF>;
end;
[ShortDescr]
Location info structure
[Description]
TJclLocationInfo is the structure returned in various routines and methods that
request location info for a specific address.
[RecordFields]
Count=6
1=Address:Pointer=Nearest address of the request.
2=UnitName:string=Name of the Delphi unit the address is located in.
3=ProcedureName:string=Name of the procedure for the address.
4=LineNumber:Integer=Line-number for the address.
5=SourceName:string=Name of the source file for the address.
6=DebugInfo:TJclDebugInfoSource=Other usefull information for the address.
See <REF Target"..\TJclDebugInfoSource\TJclDebugInfoSource">TJclDebugInfoSource</REF>
for more information.
[Quick Info]
Kind=Type
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
TJclDebugInfoSource = class (TObject)
[ShortDescr]
Debug info location item.
[Description]
TJclDebugInfoSource is an abstract base class to hold location information.
Instances of descendants are created by the TJclDebugInfoList-object.</P><P>
Descendants should override the <REF Target"Methods\InitializeSource">InitializeSource</REF>
and <REF Target"Methods\GetLocationInfo">GetLocationInfo</REF> methods.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\TJclDebugInfoSource
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function InitializeSource: Boolean; virtual; abstract;
[ShortDescr]
Initializes the object.
[Description]
InitializeSource initializes the object.
[Result]
If the function succeeds it returns True, otherwise it returns False.
[Quick Info]
Kind=Method
Visibility=Protected
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\TJclDebugInfoSource
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
constructor Create(AModule: HMODULE); virtual;
[ShortDescr]
Instantiates a DebugInfoSource object.
[Description]
Create instantiates a TJclDebugInfoSource object and links it to a specific
module. TJclDebugInfoSource is an abstract base class and you should never
instantiate a TJclDebugSource directly, but rather a descendant.
[Parameters]
Count=1
1=AModule:HMODULE=Module handle to create debug info for.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\TJclDebugInfoSource
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function GetLocationInfo(const Addr: Pointer; var Info: <REF Target"..\..\Types\TJclLocationInfo">TJclLocationInfo</REF>): Boolean; virtual; abstract;
[ShortDescr]
Retreives information on a specified address.
[Description]
GetLocationInfo retreives information for the address specified by the Addr
parameter and returns it through the Info parameter.
[Parameters]
Count=2
1=Addr:Pointer=Address to get information on
2=Info:TJclLocationInfo=Structure that holds information on the address, if address
belongs to this object
[Result]
If the specified address exists within the module represented by this object the
function returns True and Info will hold the information for the specified address.
If the address does not exist within the module, the function returns False.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\TJclDebugInfoSource
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
property Module: HMODULE read FModule;
[ShortDescr]
Module referenced by this object.
[Description]
Module holds the module handle this instance has been created for.
[Quick Info]
Kind=Property
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\TJclDebugInfoSource
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
property FileName: TFileName read GetFileName;
[ShortDescr]
File name for the module referenced by this object.
[Description]
FileName holds the file name of the module this instance has been created for.
[Quick Info]
Kind=Property
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\TJclDebugInfoSource
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
TJclDebugInfoList = class (TObjectList)
[ShortDescr]
Holds a list of debug info items
[Description]
TJclDebugInfoList holds a list of <REF Target"..\TJclDebugInfoSource\TJclDebugInfoSource">TJclDebugInfoSource</REF> 
items requested. Items are created when needed, not when the list is created.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\TJclDebugInfoList
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function CreateDebugInfo(const Module: HMODULE): <REF Target"..\..\TJclDebugInfoSource\TJclDebugInfoSource">TJclDebugInfoSource</REF>;
[ShortDescr]
Creates a TJclDebugInfoSource descendant for a module
[Description]
CreateDebugInfo will atempt to create a <REF Target"..\TJclDebugInfoSource\..\TJclDebugInfoSource">TJclDebugInfoSource</REF>
for the given module and initializes it. The method tries to obtain the following types in order:
	<UL>
		<LI>Text-based map file</LI>
		<LI>Jcl Binary debug data resource</LI>
		<LI>Borland exports header</LI>
	</UL>
If initialization failed for all supported types nil will be returned, otherwise
it will return the first that initialized correctly.
[Parameters]
Count=1
1=Module:HMODULE=Module handle to create debug info for.
[Result]
If debug info could be obtained for the specified module, a <REF Target"..\..\TJclDebugInfoSource\TJclDebugInfoSource">TJclDebugInfoSource</REF>
descendant will be returned, otherwise it returns nil.
[Quick Info]
Kind=Method
Visibility=Protected
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\TJclDebugInfoList
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function GetLocationInfo(const Addr: Pointer; var Info: <REF Target"..\..\Types\TJclLocationInfo">TJclLocationInfo</REF>): Boolean;
[ShortDescr]
Retreives information on a specified address.
[Description]
GetLocationInfo retreives information for the address specified by the Addr
parameter and returns it through the Info parameter.
[Parameters]
Count=2
1=Addr:Pointer=Address to get information on
2=Info:TJclLocationInfo=Structure that holds information on the address, if address
belongs to any module in the current process.
[Result]
If the specified address exists within the curent process the function returns True
and Info will hold the information for the specified address. If the address does
not exist within the current process, the function returns False.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\TJclDebugInfoList
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function DebugInfoAvailable(const Module: HMODULE): Boolean;
[ShortDescr]
Determines if debug info for a module is available.
[Description]
DebugInfoAvailable checks if the specified module has debug information.
[Parameters]
Count=1
1=Module:HMODULE=Handle of module to check for debug information.
[Result]
If the specified module has debug information the function returns True, otherwise
False will be returned.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
property ItemFromModule[const Module: HMODULE]: <REF Target"..\..\TJclDebugInfoSource\TJclDebugInfoSource">TJclDebugInfoSource</REF> read GetItemFromModule;
[ShortDescr]
Gets a DebugInfo item for the specified module.
[Description]
ItemFromModule returns a <REF Target"..\..\TJclDebugInfoSource\TJclDebugInfoSource">TJclDebugInfoSource</REF>-item for the specified module. If the item
hasn't been created, it will try to do so.
[Quick Info]
Kind=Property
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\TJclDebugInfoList
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
property Items[Index: Integer]: <REF Target"..\..\TJclDebugInfoSource\TJclDebugInfoSource">TJclDebugInfoSource</REF> read GetItems;
[ShortDescr]
Returns the debug info item at the specified index
[Description]
Items returns the <REF Target"..\..\TJclDebugInfoSource\TJclDebugInfoSource">TJclDebugInfoSource</REF>-item at the specified index.
[Quick Info]
Kind=Property
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\TJclDebugInfoList
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
TJclDebugInfoMap = class (TJclDebugInfoSource)
[ShortDescr]
Debug info location item for text-base map files.
[Description]
TJclDebugInfoMap is the class to hold location information by scanning
a text-based map file. It uses a TJclMapScanner object to do so.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\TJclDebugInfoMap
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
TJclDebugInfoBinary = class (TJclDebugInfoSource)
[ShortDescr]
Debug info location item for Jcl binary debug data.
[Description]
TJclDebugInfoBinary is the class to hold location information by scanning
a Jcl binary debug data resource. It uses a TJclBinDebugScanner object to do so.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\TJclDebugInfoBinary
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
TJclDebugInfoExports = class (TJclDebugInfoSource)
[ShortDescr]
Debug info location item for Borland export header.
[Description]
TJclDebugInfoExports is the class to hold location information by scanning
a Borland export header for the PE-image. It uses a TJclPeBorImage object to do so.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations\TJclDebugInfoExports
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function ModuleFromAddr(const Addr: Pointer): HMODULE;
[ShortDescr]
Returns the module handle for an address.
[Description]
TODO
[Parameters]
Count=1
1=Addr:Pointer=Address to get the module handle of.
[Result]
If the Addr parameter points to an address in code-segment, it returns the
handle of the module at at that address, otherwise it returns 0.
[Quick Info]
BCB=3,4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=3,4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
function IsSystemModule(const Module: HMODULE): Boolean;
[ShortDescr]
Determines if a module belongs to the current application
[Description]
IsSystemModule checks if the specified module is part of the current application.
It does so by searching the list at LibModuleList (see Delphi Help).
[Parameters]
Count=1
1=Module:HMODULE=Module handle to check.
[Result]
If the module belongs to the application, the function returns True, otherwise it
returns False.
[Quick Info]
BCB=3,4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=3,4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
function Caller(Level: Integer): Pointer;
[ShortDescr]
Returns the address of a calling routine.
[Description]
Caller returns the address of the calling routine at the specified level. Specifying
level 0 results in the currently executing routine, level 1 results in the caller
of the currently executing routine, level 2 results in the caller of the caller of
the, well, you get the picture. The returned address is the address of the instruction
at which execution continues when the function(s) return.
[Parameters]
Count=1
1=Level:Integer=The level of the caller for which you want the address. Level 0
is the currently executing routine, 1 is the caller, 2 is the caller of the caller
and so forth.
[Result]
The address of the instruction of the routine specified by Level at which execution
resumes when the function(s) return.
[Quick Info]
BCB=3,4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=3,4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
function GetLocationInfo(const Addr: Pointer): <REF Target"..\..\Types\TJclLocationInfo">TJclLocationInfo</REF>; overload;
function GetLocationInfo(const Addr: Pointer; var Info: <REF Target"..\..\Types\TJclLocationInfo">TJclLocationInfo</REF>): Boolean; overload;
[ShortDescr]
Returns location info given an address.
[Description]
GetLocationInfo returns a TJclLocationInfo structure for the specified address.
[Parameters]
Count=1
1=Addr:Pointer=Addres to obtain information on.
[Result]
This function returns a TJclLocationInfo record filled with any information it
could find.
[Quick Info]
BCB=3,4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=3,4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Requirements=A detailed map file.
<DECL>--------------------------------------------------------------------------
[Declaration]
function GetLocationInfoStr(const Addr: Pointer; IncludeModuleName: Boolean = False): string;
[ShortDescr]
Returns location info in a formatted string, given an address.
[Description]
GetLocationInfoStr returns location info in a formatted string. The string is
formatted as: [<I>Address</I>] <I>UnitName</I>.<I>ProcedureName</I> (Line <I>linenumber</I>, "<I>source file name</I>"
or [<I>Address</I>] {<I>ModuleName</I>} <I>UnitName</I>.<I>ProcedureName</I> (Line <I>linenumber</I>, "<I>source file name</I>", depending
on the value of IncludeModuleName parameter.
[Parameters]
Count=2
1=Addr:Pointer=Address to obtain information on.
2=IncludeModuleName:Boolean=Should the module name be included in the string. If
this parameter is set to True, the module name is inserted right after the address. 
[Result]
If location info was found, the function returns the formatted info string,
otherwise it returns a string formatted as <B>[</B><I>Address</I><B>]</B>.
[Quick Info]
BCB=3,4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=3,4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Requirements=A detailed map file.
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure ClearLocationData;
[ShortDescr]
Clears the list of debug information items.
[Description]
ClearLocationData clears the list of debug information items created so far. All
routines that request location information use this list. If many request for many
different modules have been made, this could consume a lot of memory. By clearing
the list, the memory is release, but items will be added for any location request
made later on.
[Quick Info]
BCB=3,4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=3,4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
function __FILE__(const Level: Integer = 0): string;
[ShortDescr]
Returns the name of the file.
[Description]
__FILE__ returns the name of the source file in which the routine specified by
Level exists. Level 0 denotes the currently executing routine, 1 denotes the
caller of the routine, 2 the caller of the caller, etc.
[Parameters]
Count=1
1=Level:Integer=Caller level for which you want to know the source file in which
it resides. 0 is the currently executing routine, 1 is the caller, 2 is the caller
of the caller, etc.
[Result]
Filename of the source file in which the routine specified by Level exists.
[Notes]
Count=2
1=Usage of this function requires building the module with a detailed map file.
Use the Linker tab in the Project Options dialog to enable creation of a map file.
2=This function is obsolete. Use FileByLevel instead.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Requirements=A detailed map file.
[SeeAlso]
Count=9
1=__MODULE__
2=__PROC__
3=__LINE__
4=__MAP__
5=__FILE_OF_ADDR__
6=__MODULE_OF_ADDR__
7=__PROC_OF_ADDR__
8=__LINE_OF_ADDR__
9=__MAP_OF_ADDR__
<DECL>--------------------------------------------------------------------------
[Declaration]
function __MODULE__(const Level: Integer = 0): string;
[ShortDescr]
Returns the name of the unit in which a routine resides.
[Description]
__MODULE__ returns the name of the unit in which the routine specified by
Level exists. Level 0 denotes the currently executing routine, 1 denotes the
caller of the routine, 2 the caller of the caller, etc.
[Parameters]
Count=1
1=Level:Integer=Caller level for which you want to know the module name in which
it resides. 0 is the currently executing routine, 1 is the caller, 2 is the caller
of the caller, etc.
[Result]
Unit name in which the routine specified by Level exists.
[Notes]
Count=2
1=Usage of this function requires building the module with a detailed map file.
Use the Linker tab in the Project Options dialog to enable creation of a map file.
2=This function is obsolete. Use ModuleByLevel instead.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Requirements=A detailed map file.
[SeeAlso]
Count=9
1=__FILE__
2=__PROC__
3=__LINE__
4=__MAP__
5=__FILE_OF_ADDR__
6=__MODULE_OF_ADDR__
7=__PROC_OF_ADDR__
8=__LINE_OF_ADDR__
9=__MAP_OF_ADDR__
<DECL>--------------------------------------------------------------------------
[Declaration]
function __PROC__(const Level: Integer = 0): string;
[ShortDescr]
Returns the name of the routine at a specified level.
[Description]
__PROC__ returns the name of the procedure at the specified Level. Level 0 denotes
the currently executing routine, 1 denotes the caller of the routine, 2 the caller
of the caller, etc.
[Parameters]
Count=1
1=Level:Integer=Caller level for which you want to know the name. 0 is the
currently executing routine, 1 is the caller, 2 is the caller of the caller, etc.
[Result]
Name of the routine at the specified level.
[Notes]
Count=2
1=Usage of this function requires building the module with a detailed map file.
Use the Linker tab in the Project Options dialog to enable creation of a map file.
2=This function is obsolete. Use ProcByLevel instead.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Requirements=A detailed map file.
[SeeAlso]
Count=9
1=__FILE__
2=__MODULE__
3=__LINE__
4=__MAP__
5=__FILE_OF_ADDR__
6=__MODULE_OF_ADDR__
7=__PROC_OF_ADDR__
8=__LINE_OF_ADDR__
9=__MAP_OF_ADDR__
<DECL>--------------------------------------------------------------------------
[Declaration]
function __LINE__(const Level: Integer = 0): Integer;
[ShortDescr]
Returns the line number in the source code file at which a routine is executing.
[Description]
__LINE__ returns the line number within the source code file at which the routine
specified by Level is currently executing. Level 0 denotes the currently executing
routine, 1 denotes the caller of the routine, 2 the caller of the caller, etc.
[Parameters]
Count=1
1=Level:Integer=Caller level for which you want to know the line number. 0 is the
currently executing routine, 1 is the caller, 2 is the caller of the caller, etc.
[Result]
Line number of the routine specified by Level.
[Notes]
Count=2
1=Usage of this function requires building the module with a detailed map file.
Use the Linker tab in the Project Options dialog to enable creation of a map file.
2=This function is obsolete. Use LineByLevel instead.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Requirements=A detailed map file.
[SeeAlso]
Count=9
1=__FILE__
2=__MODULE__
3=__PROC__
4=__MAP__
5=__FILE_OF_ADDR__
6=__MODULE_OF_ADDR__
7=__PROC_OF_ADDR__
8=__LINE_OF_ADDR__
9=__MAP_OF_ADDR__
<DECL>--------------------------------------------------------------------------
[Declaration]
function __MAP__(const Level: Integer; var _File, _Module, _Proc: string;
  var _Line: Integer): Boolean;
[ShortDescr]
Returns the file name, unit name, procedure name and line number at which a
routine is executing.
[Description]
__MAP__ combines the __FILE__, __MODULE, __PROC__ and __LINE__ routines into a
single call.
[Parameters]
Count=5
1=Level:Integer=Caller level for which you want to get location information. 0 is the
currently executing routine, 1 is the caller, 2 is the caller of the caller, etc.
2=_File:string=File name of the routine specified by Level
3=_Module:string=Unit name of the routine specified by Level
4=_Proc:string=Procedure name of the routine specified by Level
5=_Line:Integer=Line number of the routine specified by Level
[Result]
Returns True if the information was found, otherwise False.
[Notes]
Count=2
1=Usage of this function requires building the module with a detailed map file.
Use the Linker tab in the Project Options dialog to enable creation of a map file.
2=This function is obsolete. Use MapByLevel instead.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Requirements=A detailed map file.
[SeeAlso]
Count=9
1=__FILE__
2=__MODULE__
3=__PROC__
4=__LINE__
5=__FILE_OF_ADDR__
6=__MODULE_OF_ADDR__
7=__PROC_OF_ADDR__
8=__LINE_OF_ADDR__
9=__MAP_OF_ADDR__
<DECL>--------------------------------------------------------------------------
[Declaration]
function __FILE_OF_ADDR__(const Addr: Pointer): string;
[ShortDescr]
Returns the filename for an address.
[Description]
__FILE_OF_ADDR__ returns the name of the source code file given an address.
[Parameters]
Count=1
1=Addr:Pointer=The address for which you want to know the source code file.
[Result]
Name of the source code file in which the specified address is defined.
[Notes]
Count=2
1=Usage of this function requires building the module with a detailed map file.
Use the Linker tab in the Project Options dialog to enable creation of a map file.
2=This function is obsolete. Use FileOfAddr instead.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Requirements=A detailed map file.
[SeeAlso]
Count=9
1=__FILE__
2=__MODULE__
3=__PROC__
4=__LINE__
5=__MAP__
6=__MODULE_OF_ADDR__
7=__PROC_OF_ADDR__
8=__LINE_OF_ADDR__
9=__MAP_OF_ADDR__
<DECL>--------------------------------------------------------------------------
[Declaration]
function __MODULE_OF_ADDR__(const Addr: Pointer): string;
[ShortDescr]
Returns the module name for an address.
[Description]
__MODULE_OF_ADDR__ returns the name of the module given an address.
[Parameters]
Count=1
1=Addr:Pointer=The address for which you want to know the module name.
[Result]
Name of module in which the specified address is defined.
[Notes]
Count=2
1=Usage of this function requires building the module with a detailed map file.
Use the Linker tab in the Project Options dialog to enable creation of a map file.
2=This function is obsolete. Use ModuleOfAddr instead.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Requirements=A detailed map file.
[SeeAlso]
Count=9
1=__FILE__
2=__MODULE__
3=__PROC__
4=__LINE__
5=__MAP__
6=__FILE_OF_ADDR__
7=__PROC_OF_ADDR__
8=__LINE_OF_ADDR__
9=__MAP_OF_ADDR__
<DECL>--------------------------------------------------------------------------
[Declaration]
function __PROC_OF_ADDR__(const Addr: Pointer): string;
[ShortDescr]
Returns the procedure name for an address.
[Description]
__PROC_OF_ADDR__ returns the name of the procedure given an address.
[Parameters]
Count=1
1=Addr:Pointer=Address for which you want to know the procedure.
[Result]
Name of the procedure in which Addr is defined.
[Notes]
Count=2
1=Usage of this function requires building the module with a detailed map file.
Use the Linker tab in the Project Options dialog to enable creation of a map file.
2=This function is obsolete. Use ProcOfAddr instead.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Requirements=A detailed map file.
[SeeAlso]
Count=9
1=__FILE__
2=__MODULE__
3=__PROC__
4=__LINE__
5=__MAP__
6=__FILE_OF_ADDR__
7=__MODULE_OF_ADDR__
8=__LINE_OF_ADDR__
9=__MAP_OF_ADDR__
<DECL>--------------------------------------------------------------------------
[Declaration]
function __LINE_OF_ADDR__(const Addr: Pointer): Integer;
[ShortDescr]
Returns the line number given an address.
[Description]
__LINE_OF_ADDR__ returns the line number in a source code file given an address.
[Parameters]
Count=1
1=Addr:Pointer=The address for which you want to know the line number.
[Result]
Line number at which the address is defined.
[Notes]
Count=2
1=Usage of this function requires building the module with a detailed map file.
Use the Linker tab in the Project Options dialog to enable creation of a map file.
2=This function is obsolete. Use LineOfAddr instead.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Requirements=A detailed map file.
[SeeAlso]
Count=9
1=__FILE__
2=__MODULE__
3=__PROC__
4=__LINE__
5=__MAP__
6=__FILE_OF_ADDR__
7=__MODULE_OF_ADDR__
8=__PROC_OF_ADDR__
9=__MAP_OF_ADDR__
<DECL>--------------------------------------------------------------------------
[Declaration]
function __MAP_OF_ADDR__(const Addr: Pointer; var _File, _Module, _Proc: string;
  var _Line: Integer): Boolean;
[ShortDescr]
Returns the file name, unit name, procedure name and line number given an address.
[Description]
__MAP_OF_ADDR__ combines the __FILE_OF_ADDR__, __MODULE_OF_ADDR__, __PROC_OF_ADDR__
and __LINE_OF_ADDR__ routines into a single call.
[Parameters]
Count=5
1=Addr:Pointer=The address for which you want to know the location information.
2=_File:string=File name of the routine specified by Level
3=_Module:string=Unit name of the routine specified by Level
4=_Proc:string=Procedure name of the routine specified by Level
5=_Line:Integer=Line number of the routine specified by Level
[Result]
Returns True if the information was found, otherwise False.
[Notes]
Count=2
1=Usage of this function requires building the module with a detailed map file.
Use the Linker tab in the Project Options dialog to enable creation of a map file.
2=This function is obsolete. Use MapOfAddr instead.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Requirements=A detailed map file.
[SeeAlso]
Count=9
1=__FILE__
2=__MODULE__
3=__PROC__
4=__LINE__
5=__MAP__
6=__FILE_OF_ADDR__
7=__MODULE_OF_ADDR__
8=__PROC_OF_ADDR__
9=__LINE_OF_ADDR__
<DECL>--------------------------------------------------------------------------
[Declaration]
function FileByLevel(const Level: Integer = 0): string;
[ShortDescr]
Returns the name of the file.
[Description]
FileByLevel returns the name of the source file in which the routine specified by
Level exists. Level 0 denotes the currently executing routine, 1 denotes the
caller of the routine, 2 the caller of the caller, etc.
[Parameters]
Count=1
1=Level:Integer=Caller level for which you want to know the source file in which
it resides. 0 is the currently executing routine, 1 is the caller, 2 is the caller
of the caller, etc.
[Result]
Filename of the source file in which the routine specified by Level exists.
[Notes]
Count=1
1=Usage of this function requires building the module with a detailed map file.
Use the Linker tab in the Project Options dialog to enable creation of a map file.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Requirements=A detailed map file.
[SeeAlso]
Count=9
1=ModuleByLevel
2=ProcByLevel
3=LineByLevel
4=MapByLevel
5=FileOfAddr
6=ModuleOfAddr
7=ProcOfAddr
8=LineOfAddr
9=MapOfAddr
<DECL>--------------------------------------------------------------------------
[Declaration]
function ModuleByLevel(const Level: Integer = 0): string;
[ShortDescr]
Returns the name of the unit in which a routine resides.
[Description]
__MODULE__ returns the name of the unit in which the routine specified by
Level exists. Level 0 denotes the currently executing routine, 1 denotes the
caller of the routine, 2 the caller of the caller, etc.
[Parameters]
Count=1
1=Level:Integer=Caller level for which you want to know the module name in which
it resides. 0 is the currently executing routine, 1 is the caller, 2 is the caller
of the caller, etc.
[Result]
Unit name in which the routine specified by Level exists.
[Notes]
Count=1
1=Usage of this function requires building the module with a detailed map file.
Use the Linker tab in the Project Options dialog to enable creation of a map file.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Requirements=A detailed map file.
[SeeAlso]
Count=9
1=FileByLevel
2=ProcByLevel
3=LineByLevel
4=MapByLevel
5=FileOfAddr
6=ModuleOfAddr
7=ProcOfAddr
8=LineOfAddr
9=MapOfAddr
<DECL>--------------------------------------------------------------------------
[Declaration]
function ProcByLevel(const Level: Integer = 0): string;
[ShortDescr]
Returns the name of the routine at a specified level.
[Description]
__PROC__ returns the name of the procedure at the specified Level. Level 0 denotes
the currently executing routine, 1 denotes the caller of the routine, 2 the caller
of the caller, etc.
[Parameters]
Count=1
1=Level:Integer=Caller level for which you want to know the name. 0 is the
currently executing routine, 1 is the caller, 2 is the caller of the caller, etc.
[Result]
Name of the routine at the specified level.
[Notes]
Count=1
1=Usage of this function requires building the module with a detailed map file.
Use the Linker tab in the Project Options dialog to enable creation of a map file.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Requirements=A detailed map file.
[SeeAlso]
Count=9
1=FileByLevel
2=ModuleByLevel
3=LineByLevel
4=MapByLevel
5=FileOfAddr
6=ModuleOfAddr
7=ProcOfAddr
8=LineOfAddr
9=MapOfAddr
<DECL>--------------------------------------------------------------------------
[Declaration]
function LineByLevel(const Level: Integer = 0): Integer;
[ShortDescr]
Returns the line number in the source code file at which a routine is executing.
[Description]
__LINE__ returns the line number within the source code file at which the routine
specified by Level is currently executing. Level 0 denotes the currently executing
routine, 1 denotes the caller of the routine, 2 the caller of the caller, etc.
[Parameters]
Count=1
1=Level:Integer=Caller level for which you want to know the line number. 0 is the
currently executing routine, 1 is the caller, 2 is the caller of the caller, etc.
[Result]
Line number of the routine specified by Level.
[Notes]
Count=1
1=Usage of this function requires building the module with a detailed map file.
Use the Linker tab in the Project Options dialog to enable creation of a map file.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Requirements=A detailed map file.
[SeeAlso]
Count=9
1=FileByLevel
2=ModuleByLevel
3=ProcByLevel
4=MapByLevel
5=FileOFAddr
6=ModuleOfAddr
7=ProcOfAddr
8=LineOfAddr
9=MapOfAddr
<DECL>--------------------------------------------------------------------------
[Declaration]
function MapByLevel(const Level: Integer; var _File, _Module, _Proc: string;
  var _Line: Integer): Boolean;
[ShortDescr]
Returns the file name, unit name, procedure name and line number at which a
routine is executing.
[Description]
MapByLevel combines the FileByLevel, ModuleByLevel, ProcByLevel and LineByLevel routines into a
single call.
[Parameters]
Count=5
1=Level:Integer=Caller level for which you want to get location information. 0 is the
currently executing routine, 1 is the caller, 2 is the caller of the caller, etc.
2=_File:string=File name of the routine specified by Level
3=_Module:string=Unit name of the routine specified by Level
4=_Proc:string=Procedure name of the routine specified by Level
5=_Line:Integer=Line number of the routine specified by Level
[Result]
Returns True if the information was found, otherwise False.
[Notes]
Count=1
1=Usage of this function requires building the module with a detailed map file.
Use the Linker tab in the Project Options dialog to enable creation of a map file.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Requirements=A detailed map file.
[SeeAlso]
Count=9
1=FileByLevel
2=ModuleByLevel
3=ProcByLevel
4=LineByLevel
5=FileOFAddr
6=ModuleOfAddr
7=ProcOfAddr
8=LineOfAddr
9=MapOfAddr
<DECL>--------------------------------------------------------------------------
[Declaration]
function FileOfAddr(const Addr: Pointer): string;
[ShortDescr]
Returns the filename for an address.
[Description]
FileOfAddr returns the name of the source code file given an address.
[Parameters]
Count=1
1=Addr:Pointer=The address for which you want to know the source code file.
[Result]
Name of the source code file in which the specified address is defined.
[Notes]
Count=1
1=Usage of this function requires building the module with a detailed map file.
Use the Linker tab in the Project Options dialog to enable creation of a map file.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Requirements=A detailed map file.
[SeeAlso]
Count=9
1=FileByLevel
2=ModuleByLevel
3=ProcByLevel
4=LineByLevel
5=MapByLevel
6=ModuleOfAddr
7=ProcOfAddr
8=LineOfAddr
9=MapOfAddr
<DECL>--------------------------------------------------------------------------
[Declaration]
function ModuleOfAddr(const Addr: Pointer): string;
[ShortDescr]
Returns the module name for an address.
[Description]
__MODULE_OF_ADDR__ returns the name of the module given an address.
[Parameters]
Count=1
1=Addr:Pointer=The address for which you want to know the module name.
[Result]
Name of module in which the specified address is defined.
[Notes]
Count=1
1=Usage of this function requires building the module with a detailed map file.
Use the Linker tab in the Project Options dialog to enable creation of a map file.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Requirements=A detailed map file.
[SeeAlso]
Count=9
1=FileByLevel
2=ModuleByLevel
3=ProcByLevel
4=LineByLevel
5=MapByLevel
6=FileOfAddr
7=ProcOfAddr
8=LineOfAddr
9=MapOfAddr
<DECL>--------------------------------------------------------------------------
[Declaration]
function ProcOfAddr(const Addr: Pointer): string;
[ShortDescr]
Returns the procedure name for an address.
[Description]
__PROC_OF_ADDR__ returns the name of the procedure given an address.
[Parameters]
Count=1
1=Addr:Pointer=Address for which you want to know the procedure.
[Result]
Name of the procedure in which Addr is defined.
[Notes]
Count=1
1=Usage of this function requires building the module with a detailed map file.
Use the Linker tab in the Project Options dialog to enable creation of a map file.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Requirements=A detailed map file.
[SeeAlso]
Count=9
1=FileByLevel
2=ModuleByLevel
3=ProcByLevel
4=LineByLevel
5=MapByLevel
6=FileOfAddr
7=ModuleOfAddr
8=LineOfAddr
9=MapOfAddr
<DECL>--------------------------------------------------------------------------
[Declaration]
function LineOfAddr(const Addr: Pointer): Integer;
[ShortDescr]
Returns the line number given an address.
[Description]
__LINE_OF_ADDR__ returns the line number in a source code file given an address.
[Parameters]
Count=1
1=Addr:Pointer=The address for which you want to know the line number.
[Result]
Line number at which the address is defined.
[Notes]
Count=1
1=Usage of this function requires building the module with a detailed map file.
Use the Linker tab in the Project Options dialog to enable creation of a map file.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Requirements=A detailed map file.
[SeeAlso]
Count=9
1=FileByLevel
2=ModuleByLevel
3=ProcByLevel
4=LineByLevel
5=MapByLevel
6=FileOfAddr
7=ModuleOfAddr
8=ProcOfAddr
9=MapOfAddr
<DECL>--------------------------------------------------------------------------
[Declaration]
function MapOfAddr(const Addr: Pointer; var _File, _Module, _Proc: string;
  var _Line: Integer): Boolean;
[ShortDescr]
Returns the file name, unit name, procedure name and line number given an address.
[Description]
__MAP_OF_ADDR__ combines the __FILE_OF_ADDR__, __MODULE_OF_ADDR__, __PROC_OF_ADDR__
and __LINE_OF_ADDR__ routines into a single call.
[Parameters]
Count=5
1=Addr:Pointer=The address for which you want to know the location information.
2=_File:string=File name of the routine specified by Level
3=_Module:string=Unit name of the routine specified by Level
4=_Proc:string=Procedure name of the routine specified by Level
5=_Line:Integer=Line number of the routine specified by Level
[Result]
Returns True if the information was found, otherwise False.
[Notes]
Count=1
1=Usage of this function requires building the module with a detailed map file.
Use the Linker tab in the Project Options dialog to enable creation of a map file.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Requirements=A detailed map file.
[SeeAlso]
Count=9
1=FileByLevel
2=ModuleByLevel
3=ProcByLevel
4=LineByLevel
5=MapByLevel
6=FileOfAddr
7=ModuleOfAddr
8=ProcOfAddr
9=LineOfAddr
<DECL>--------------------------------------------------------------------------
[Declaration]
PStackFrame = ^TStackFrame;
TStackFrame = record
  CallersEBP: DWORD;
  CallerAdr: DWORD;
end;
[ShortDescr]
Stack frame information
[Description]
TStackFrame holds stack frame information.
[RecordFields]
Count=2
1=CallersEBP:DWORD=Callers EBP register
2=CallerAdr:DWORD=Address of caller
[Quick Info]
Kind=Type
BCB=4,5
Kind=Type
Unit=JclDebug
Category=Debugging
SubCat=Stack info routines
Author=Hallvard Vassbotn;hallvard.vassbotn@c2i.net
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
TStackInfo = record
  CallerAdr: DWORD;
  Level: DWORD;
  CallersEBP: DWORD;
  DumpSize: DWORD;
  ParamSize: DWORD;
  ParamPtr: PDWORDArray;
  case Integer of
    0: (StackFrame: <REF>PStackFrame</REF>);
    1: (DumpPtr: PByteArray);
end;
[ShortDescr]
Stack information
[Description]
TStackInfo holds stack information.
[RecordFields]
Count=8
1=CallerAdr:DWORD=Return address  (the address of the caller)
2=Level:DWORD=Caller level
3=CallersEBP:DWORD=EBP register of caller (only filled if the trace was not a raw stack trace)
4=DumpSize:DWORD=Length of memory block between callers frame and this frame (only filled if the trace was not a raw stack trace)
5=ParamSize:DWORD=Number of DWORD parameters (only filled if the trace was not a raw stack trace)
6=ParamPtr:PDWORDArray=Points to the parameters (only filled if the trace was not a raw stack trace)
7=StackFrame:PStackFrame=Current stack frame (only filled if the trace was not a raw stack trace)
8=DumpPtr:PByteArray=Points to the memory block of the stack frame (only filled if the trace was not a raw stack trace)
[Quick Info]
Kind=Type
BCB=4,5
Kind=Type
Unit=JclDebug
Category=Debugging
SubCat=Stack info routines
Author=Hallvard Vassbotn;hallvard.vassbotn@c2i.net
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
TJclStackInfoItem = class (TObject)
[ShortDescr]
Stack information item
[Description]
TStackInfoItem holds stack information.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Stack info routines\TJclStackInfoItem
Author=Hallvard Vassbotn;hallvard.vassbotn@c2i.net
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
property LogicalAddress: DWORD read GetLogicalAddress;
[ShortDescr]
Retreives the logical address for the caller
[Description]
LogicalAddress retreives teh logical address for the caller. It does so by
subtracting the caller's module base address from the caller's address.
[Quick Info]
BCB=4,5
Kind=Property
Visibility=Public
Unit=JclDebug
Category=Debugging
SubCat=Stack info routines\TJclStackInfoItem
Author=Hallvard Vassbotn;hallvard.vassbotn@c2i.net
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
property StackInfo: TStackInfo read FStackInfo;
[ShortDescr]
Stack information.
[Description]
StackInfo holds the actual stack information.
[Quick Info]
BCB=4,5
Kind=Property
Visibility=Public
Unit=JclDebug
Category=Debugging
SubCat=Stack info routines\TJclStackInfoItem
Author=Hallvard Vassbotn;hallvard.vassbotn@c2i.net
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
TJclStackBaseList = class (TObjectList)
[ShortDescr]
Base stack information list
[Description]
TJclStackBaseList is the base class for the track list's (TJclStackInfoList and
TJclExceptFrameList). It provides properties that hold information on the thread
and timestamp of the info list.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Tracking routines\TJclStackBaseList
Author=Petr Vones
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
property ThreadID: DWORD read FThreadID;
[ShortDescr]
ID of thread that made the trace.
[Description]
ThreadID is ID of the thread that executed the trace.
[Quick Info]
BCB=4,5
Kind=Property
Visibility=Public
Unit=JclDebug
Category=Debugging
SubCat=Tracking routines\TJclStackBaseList
Author=Hallvard Vassbotn;hallvard.vassbotn@c2i.net
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
property TimeStamp: TDateTime read FTimeStamp;
[ShortDescr]
Time stamp of list creation
[Description]
TimeStamp holds the date and time of creation of the list.
[Quick Info]
BCB=4,5
Kind=Property
Visibility=Public
Unit=JclDebug
Category=Debugging
SubCat=Tracking routines\TJclStackBaseList
Author=Hallvard Vassbotn;hallvard.vassbotn@c2i.net
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
TJclStackInfoList = class (TJclStackBaseList)
[ShortDescr]
Stack information list
[Description]
TStackInfoList holds a list of stack information items (<REF Target"..\TJclStackInfoItem\TJclStackInfoItem"TJclStackInfoItem</REF>).
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Stack info routines\TJclStackInfoList
Author=Hallvard Vassbotn;hallvard.vassbotn@c2i.net
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
constructor Create(Raw: Boolean; AIgnoreLevels: DWORD; FirstCaller: Pointer);
[ShortDescr]
Instantiates a stack list.
[Description]
Create instantiates a stack list and immediately executes the trace.
[Parameters]
Count=3
1=Raw:Boolean=When set to False, the stack is traced by means of the EBP frame,
when set to True, all DWORDs are checked for valid caller addresses.
2=AIgnoreLevels:DWORD=Number of callers to ignore upon tracing.
3=FirstCaller:Pointer=If not nil, an explicit TJclStackInfoItem is added to the
list, pointing to the FirstCaller.
[Quick Info]
BCB=4,5
Kind=Method
Visibility=Public
Unit=JclDebug
Category=Debugging
SubCat=Stack info routines\TJclStackInfoList
Author=Hallvard Vassbotn;hallvard.vassbotn@c2i.net
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure AddToStrings(const Strings: TStrings; IncludeModuleName: Boolean = False);
[ShortDescr]
Adds all stack info items a list.
[Description]
AddToStrings adds all stack info items to a TStrings descendant. For each stack
info item it stores the result of the call GetLocationInfoStr(CallerAddress,
IncludeModuleName).
[Parameters]
Count=2
1=String:TStrings=TStrings descendant to retreive the stack trace in.
2=IncludeModuleName:Boolean=Should the module name be included in each string.
If this parameter is set to True, the module name is inserted right after the
address.
[Quick Info]
BCB=4,5
Kind=Method
Visibility=Public
Unit=JclDebug
Category=Debugging
SubCat=Stack info routines\TJclStackInfoList
Author=Hallvard Vassbotn;hallvard.vassbotn@c2i.net
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
property Items[Index: Integer]: TJclStackInfoItem read GetItems; default;
[ShortDescr]
List of stack info items
[Description]
Items is a reference to all stack info items obtained during the trace.
[Quick Info]
BCB=4,5
Kind=Property
Visibility=Public
Unit=JclDebug
Category=Debugging
SubCat=Stack info routines\TJclStackInfoList
Author=Hallvard Vassbotn;hallvard.vassbotn@c2i.net
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
property IgnoreLevels: DWORD read FIgnoreLevels;
[ShortDescr]
Number of levels ignored in the trace
[Description]
IgnoreLevels is the number of levels that were ignored when the trace started. This
number was given upon creation of the list.
[Quick Info]
BCB=4,5
Kind=Property
Visibility=Public
Unit=JclDebug
Category=Debugging
SubCat=Stack info routines\TJclStackInfoList
Author=Hallvard Vassbotn;hallvard.vassbotn@c2i.net
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
property ThreadID: DWORD read FThreadID;
[ShortDescr]
ID of thread that made the trace.
[Description]
ThreadID is ID of the thread that executed the trace.
[Quick Info]
BCB=4,5
Kind=Property
Visibility=Public
Unit=JclDebug
Category=Debugging
SubCat=Stack info routines\TJclStackInfoList
Author=Hallvard Vassbotn;hallvard.vassbotn@c2i.net
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
property TimeStamp: TDateTime read FTimeStamp;
[ShortDescr]
Time stamp of list creation
[Description]
TimeStamp holds the date and time of creation of the list.
[Quick Info]
BCB=4,5
Kind=Property
Visibility=Public
Unit=JclDebug
Category=Debugging
SubCat=Stack info routines\TJclStackInfoList
Author=Hallvard Vassbotn;hallvard.vassbotn@c2i.net
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
function JclCreateStackList(Raw: Boolean; AIgnoreLevels: Integer; FirstCaller: Pointer): TJclStackInfoList;
[ShortDescr]
Creates a stack list.
[Description]
JclCreateStackList creates a list of all stack frames. The resulting TJclStackInfoList
is also stored internally and can be obtained again by calling <REF>JclLastExceptStackList</REF>.
[Parameters]
Count=3
1=Raw:Boolean=When set to False, the stack is traced by means of the EBP frame,
when set to True, all DWORDs are checked for valid caller addresses.
2=AIgnoreLevels:Integer=Number of callers to ignore upon tracing.
3=FirstCaller:Pointer=If not nil, an explicit TJclStackInfoItem is added to the
list, pointing to the FirstCaller.
[Result]
A reference to the stack list.
[Notes]
Count=1
1=Do not free this object, it's freed internally when a new one needs to be created.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Stack info routines
Author=Hallvard Vassbotn;hallvard.vassbotn@c2i.net
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
function JclLastExceptStackList: TJclStackInfoList;
[ShortDescr]
Retreives the last generated stack info list.
[Description]
JclLastExceptStackList retreives the last generated stack info list by a call
through JclCreateStackList. Note that JclCreateStackList also get's called when
an exception occurs and the global variable StackTrackingEnable is set to True.
[Result]
A reference to the last generated stack list.
[Notes]
Count=1
1=Do not free this object, it's freed internally when a new one needs to be created.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Stack info routines
Author=Hallvard Vassbotn;hallvard.vassbotn@c2i.net
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
JmpInstruction = packed record
  opCode: Byte;
  distance: Longint;
end;
[ShortDescr]
Disected jump instruction
[Description]
JmpInstruction represents a assembler JMP instruction.
[RecordFields]
Count=2
1=opCode:Byte=opCode for the JMP instruction.
2=distance:Longint=Offset in the JMP instruction.
[Notes]
Count=1
1=This type is copied from System.pas
[Quick Info]
BCB=4,5
Kind=Type
Unit=JclDebug
Category=Debugging
SubCat=Except frame info routines
Author=Borland
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
TExcDescEntry = record
  vTable: Pointer;
  handler: Pointer;
end;
[ShortDescr]
Except on... handler item
[Description]
TExcDescEntry represents an item in an except on... handler.
[RecordFields]
Count=2
1=vTable:Pointer=Pointer to the Virtual Method table of an Exception class.
2=handler:Pointer=Pointer to the handler for the exception class.
[Notes]
Count=1
1=This type is copied from System.pas
[Quick Info]
BCB=4,5
Kind=Type
Unit=JclDebug
Category=Debugging
SubCat=Except frame info routines
Author=Borland
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
PExcDesc = ^TExcDesc;
TExcDesc = packed record
  jmp: <REF>JmpInstruction</REF>;
  case Integer of
    0:      (instructions: array [0..0] of Byte);
    1:      (cnt: Integer; excTab: array [0..0] of <REF>TExcDescEntry</REF>);
end;
[ShortDescr]
Except frame descriptor
[Description]
TExcDesc is an except frame descriptor.<BR>For Borland modules this usually means
a JMP instruction to either HandleFinally, HandleAnyException, HandleOnException or
HandleAutoException. Incase of an HandleOnException, the JMP is followed by a table
containing the Exception classes to handle and their handlers. In other cases
the JMP is followed by the code to execute.</P><P>For non-Borland modules, the frame
descriptor is undefined (but it always starts with executable code).
[RecordFields]
Count=4
1=jmp:JmpInstruction=Holds the JMP-instruction incase of Borland code
2=instructions: array[0..0] of Byte=Handler instructions for non "except on..."-blocks
3=cnt:Integer=Number of exception classes defined in an "except on..."-block
4=excTab:array[0..0] of TExcDescEntry=Table of on-definitions and there handlers in an "except on..."-block
[Notes]
Count=1
1=This type is copied from System.pas
[Quick Info]
BCB=4,5
Kind=Type
Unit=JclDebug
Category=Debugging
SubCat=Except frame info routines
Author=Borland
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
PExcFrame = ^TExcFrame;
TExcFrame =  record
  next: PExcFrame;
  desc: <REF>PExcDesc</REF>;
  hEBP: Pointer;
  case Integer of
  0:  ( );
  1:  ( ConstructedObject: Pointer );
  2:  ( SelfOfMethod: Pointer );
end;
[ShortDescr]
Except frame
[Description]
TExcFrame is an except frame. It holds a reference to the next frame (if any), the
location of the frame (which should always start with executable code) and the
handlers EBP frame. Incase of Borland modules, it could also contain a reference to
the object being constructed (this is the case for the implicit except frame for
constructors) or a reference to Self of the method containing the handler.
[RecordFields]
Count=5
1=next:PExcFrame=Link to next except frame or -1(!) if there is no next frame.
2=desc:PExcDesc=Pointer to handler (non-Borland modules) or frame descriptor (Borland modules)
3=hEBP:Pointer=Value of the handlers EBP-frame
4=ConstructedObject:Pointer=Pointer to object being constructed. This is used by
the compiler to allow for destruction of the object when an exception occured.
5=SelfOfMethod:Pointer=Pointer to Self of the method containing the handler.
[Notes]
Count=1
1=This type is copied from System.pas
[Quick Info]
BCB=4,5
Kind=Type
Unit=JclDebug
Category=Debugging
SubCat=Except frame info routines
Author=Borland
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
TExceptFrameKind = (efkUnknown, efkFinally, efkAnyException, efkOnException,
  efkAutoException);
[ShortDescr]
Exception frame kind.
[Description]
TExceptFrameKind determines the exception frame type. Note that the compiler
often inserts implicit frames around a method, function or procedure. For these
frames source code location routines can be of by 1 line.
[Enumeration]
Count=5
1=efkUnknown=Unknown exception frame (most likely an exception frame inside a
non-Borland library.
2=efkFinally=A try...finally frame. Note that the compiler inserts implicit
try...finally blocks for any method, function or procedure with parameters
and/or variables that need clean up (eg. long strings, dynamic arrays, interface
references).
3=efkAnyException=A try...except frame.
4=efkOnException=A try...except on.... frame.
5=efkAutoException=A try..except frame for an automated method declared with
the safecall directive (these are implicit frames inserted by the compiler).
[Quick Info]
BCB=4,5
Kind=Type
Unit=JclDebug
Category=Debugging
SubCat=Except frame info routines
Author=Marcel Bestebroer;marcelb@zeelandnet.nl
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
TJclExceptFrame = class(TObject)
[ShortDescr]
Except frame item.
[Description]
TJclExceptFrame holds information on an except frame.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Except frame info routines\TJclExceptFrame
Author=Marcel Bestebroer;marcelb@zeelandnet.nl
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
constructor Create(AExcFrame: <REF Target"..\Types\PExcFrame">PExcFrame</REF>);
[ShortDescr]
Instantiates an except frame object.
[Description]
Create instantiates an except frame object, links it to a <REF Target"..\Types\PExcFrame">PExcFrame</REF>
and determines it's type.
[Parameters]
Count=1
1=AExcFrame:PExcFrame=Reference to the except frame on the stack to create this
item for.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Except frame info routines\TJclExceptFrame
Author=Marcel Bestebroer;marcelb@zeelandnet.nl
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
function Handles(ExceptObj: TObject): Boolean;
[ShortDescr]
Checks if an exception will be handled by the frame.
[Description]
Handles checks if an exception would be handled by the frame. An efkFinally frame
will never handle an exception (although the code would be executed). efkUnknown
frames are assumed to handle the exception (there's no way of knowing for sure)
as are efkAnyException and efkAutoException frames. For efkOnException the handler
table is scanned to check for an appropiate handler.
[Parameters]
Count=1
1=ExceptObj:TObject=Exception object to check.
[Result]
If the frame will handle the exception the function returns True, otherwise it
returns False.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Except frame info routines\TJclExceptFrame
Author=Marcel Bestebroer;marcelb@zeelandnet.nl
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
function HandlerInfo(ExceptObj: TObject; var HandlerAt: Pointer): Boolean;
[ShortDescr]
Checks if an exception will be handled by the frame and at which location.
[Description]
HandlerInfo checks if an exception would be handled by the frame and where the
handler is located. An efkFinally frame will never handle an exception (although
the code would be executed). efkUnknown frames are assumed to handle the exception
(there's no way of knowing for sure) as are efkAnyException and efkAutoException
frames. For efkOnException the handler table is scanned to check for an appropiate
handler.
[Parameters]
Count=2
1=ExceptObj:TObject=Exception object to check.
2=HandlerAt:Pointer=Pointer to handler for the exception object (if one exists).
[Result]
If the frame will handle the exception the function returns True and the HandlerAt
parameter will contain the address of the handler. If the frame won't handle the
exception the function returns False and HandlerAt will be undefined.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Except frame info routines\TJclExceptFrame
Author=Marcel Bestebroer;marcelb@zeelandnet.nl
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
function CodeLocation: Pointer;
[ShortDescr]
Returns the location of the code for non efkOnException frames.
[Description]
CodeLocation determines the location of the code for non efkOnException frames.
The Delphi linker sometimes adds a JMP-instruction that jumps to the handler.
With this method you'll always get the location of the handler, inspite of a
JMP instruction being inserted or not.
[Result]
If there's a JMP instruction at the "official" location, the function will
return the destination of that address, otherwise the function just returns
the "official" location.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Except frame info routines\TJclExceptFrame
Author=Marcel Bestebroer;marcelb@zeelandnet.nl
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
property ExcFrame: PExcFrame read FExcFrame;
[ShortDescr]
Reference to the ExceptFrame on the stack.
[Description]
ExcFrame is a reference to except frame on the stack. It is not wise to modify
the memory pointed to by ExcFrame
[Quick Info]
Kind=Property
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Except frame info routines\TJclExceptFrame
Author=Marcel Bestebroer;marcelb@zeelandnet.nl
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
property FrameKind: TExceptFrameKind read FFrameKind;
[ShortDescr]
Holds the frame kind.
[Description]
FrameKind holds the kind of except frame this object references. The type is
determined when the object is created by checking the code and see if it jumps
to any of the known Borland handlers.
[Quick Info]
Kind=Property
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Except frame info routines\TJclExceptFrame
Author=Marcel Bestebroer;marcelb@zeelandnet.nl
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
TJclExceptFrameList = class(TJclStackBaseList)
[ShortDescr]
List of except frame item.
[Description]
TJclExceptFrameList holds a list of <REF Target"..\TJclExceptFrame\TJclExceptFrame">except frame items</REF>.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Except frame info routines\TJclExceptFrameList
Author=Marcel Bestebroer;marcelb@zeelandnet.nl
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
[SeeAlso]
Count=1
1=TJclExceptFrame;..\TJclExceptFrame\TJclExceptFrame
<DECL>--------------------------------------------------------------------------
[Declaration]
constructor Create(AIgnoreLevels: Integer);
[ShortDescr]
Instantiates an except frame list object.
[Description]
Create instantiates an except frame list object, set's an initial value for
the IgnoreLevels-property and starts the trace by calling TraceExceptionFrames.
[Parameters]
Count=1
1=AIgnoreLevels:Integer=Number of levels to ignore on tracing.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Except frame info routines\TJclExceptFrameList
Author=Marcel Bestebroer;marcelb@zeelandnet.nl
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure TraceExceptionFrames;
[ShortDescr]
Traces the except frames.
[Description]
TraceExceptionFrames clears the current list and traces the except frames stack.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Except frame info routines\TJclExceptFrameList
Author=Marcel Bestebroer;marcelb@zeelandnet.nl
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
property Items[Index: Integer]: TJclExceptFrame read GetItems;
[ShortDescr]
Reference to the except frame objects.
[Description]
Items is a reference to the list of except frame object found during the last
trace.
[Quick Info]
Kind=Property
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Except frame info routines\TJclExceptFrameList
Author=Marcel Bestebroer;marcelb@zeelandnet.nl
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
property IgnoreLevels: Integer read FIgnoreLevels write FIgnoreLevels;
[ShortDescr]
Number of levels to ignore on tracing.
[Description]
IgnoreLevels shows the number of levels ignored on the last trace or sets the
number of levels to ignore on the next trace.
[Quick Info]
Kind=Property
Visibility=Public
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Except frame info routines\TJclExceptFrameList
Author=Marcel Bestebroer;marcelb@zeelandnet.nl
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
property ThreadID: DWORD read FThreadID;
[ShortDescr]
ID of thread that made the trace.
[Description]
ThreadID is ID of the thread that executed the trace.
[Quick Info]
BCB=4,5
Kind=Property
Visibility=Public
Unit=JclDebug
Category=Debugging
SubCat=Except frame info routines\TJclExceptFrameList
Author=Hallvard Vassbotn;hallvard.vassbotn@c2i.net
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
property TimeStamp: TDateTime read FTimeStamp;
[ShortDescr]
Time stamp of list creation
[Description]
TimeStamp holds the date and time of creation of the list.
[Quick Info]
BCB=4,5
Kind=Property
Visibility=Public
Unit=JclDebug
Category=Debugging
SubCat=Except frame info routines\TJclExceptFrameList
Author=Hallvard Vassbotn;hallvard.vassbotn@c2i.net
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
function JclCreateExceptFrameList(AIgnoreLevels: Integer): <REF Target"TJclExceptFrameList\TJclExceptFrameList">TJclExceptFrameList</REF>;
[ShortDescr]
Creates an exception frame list.
[Description]
JclCreateExceptFrameList creates a list of all try...except and / or try...finally
frames currently set. The resulting <REF Target"TJclExceptFrameList\TJclExceptFrameList">TJclExceptFrameList</REF>
is also stored internally and can be obtained again by calling <REF>JclLastExceptFrameList</REF>.
[Parameters]
Count=1
1=AIgnoreLevels:Integer=Number of levels to ignore. This is useful to strip-out
any try...except/finally blocks in the currently executing routine.
[Result]
A reference to the exception frame list.
[Notes]
Count=1
1=Do not free this object, it's freed internally when a new one needs to be created.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Except frame info routines
Author=Marcel Bestebroer;marcelb@zeelandnet.nl
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
function JclLastExceptFrameList: TJclExceptFrameList;
[ShortDescr]
Retreives the last generated except frame list.
[Description]
JclLastExceptFrameList retreives the last generated except frame list by a call
through <REF>JclCreateExceptFrameList</REF>. Note that JclCreateExceptFrameList also 
get's called when an exception occurs and the global variable 
 <REF Target"Global Variables\ExceptionFrameTrackingEnable">ExceptionFrameTrackingEnable</REF> 
is set to True.
[Result]
A reference to the last generated exception frame list.
[Notes]
Count=1
1=Do not free this object, it's freed internally when a new one needs to be created.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Except frame info routines
Author=Marcel Bestebroer;marcelb@zeelandnet.nl
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
TJclExceptNotifyProc = procedure (ExceptObj: TObject; ExceptAddr: Pointer; OSException: Boolean);
[ShortDescr]
Exception notify procedure type.
[Description]
TJclExceptNotifyProc is the exception notify procedure type.
[Parameters]
Count=3
1=ExceptObj:TObject=Exception object
2=ExceptAddr:Pointer=Address where exception occured
3=OSException:Boolean=If the exception occured outside of any Borland module,
this parameter is True, otherwise it is False.
[Quick Info]
Kind=Type
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Exception hooking
Author=Hallvard Vassbotn;hallvard.vassbotn@c2i.net
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
[SeeAlso]
Count=3
1=TJclExceptNotifyMethod
2=ExceptNotifyProc;Global Variables\ExceptNotifyProc
3=ExceptNotifyMethod;Global Variables\ExceptNotifyMethod
<DECL>--------------------------------------------------------------------------
[Declaration]
TJclExceptNotifyMethod = procedure (ExceptObj: TObject; ExceptAddr: Pointer; OSException: Boolean) of object;
[ShortDescr]
Exception notify method type.
[Description]
TJclExceptNotifyMethod is the exception notify method type.
[Parameters]
Count=3
1=ExceptObj:TObject=Exception object
2=ExceptAddr:Pointer=Address where exception occured
3=OSException:Boolean=If the exception occured outside of any Borland module,
this parameter is True, otherwise it is False.
[Quick Info]
Kind=Type
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Exception hooking
Author=Marcel Bestebroer;marcelb@zeelandnet.nl
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
[SeeAlso]
Count=3
1=TJclExceptNotifyProc
2=ExceptNotifyProc;Global Variables\ExceptNotifyProc
3=ExceptNotifyMethod;Global Variables\ExceptNotifyMethod
<DECL>--------------------------------------------------------------------------
[Declaration]
function JclHookExceptions: Boolean;
[ShortDescr]
Enables exception hooking.
[Description]
JclHookExceptions enables exception hooking. After a succesful call, all
exceptions will be routed through an internal handler first. Note that to actually
get notified of exceptions you should set at least one of the notify event
variables to your own handler. Additionally you can also enable stack tracking
and / or except frame tracking to occur automatically on any exception.
[Result]
If the hook was succesful, the function returns True, otherwise it returns False.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Exception hooking
Author=Hallvard Vassbotn;hallvard.vassbotn@c2i.net
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
[SeeAlso]
Count=5
1=JclUnhookExceptions
2=JclExceptionsHooked
3=ExceptNotifyProc;Global Variables\ExceptNotifyProc
4=ExceptNotifyMethod;Global Variables\ExceptNotifyMethod
5=ExceptionFrameTrackingEnable;Global Variables\ExceptionFrameTrackingEnable
<DECL>--------------------------------------------------------------------------
[Declaration]
function JclUnhookExceptions: Boolean;
[ShortDescr]
Disables exception hooking.
[Description]
JclUnhookExceptions disables the exception hooking.
[Result]
If exceptions where hooked and the function succeeded in unhooking them, the
function returns True, otherwise it returns False.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Exception hooking
Author=Hallvard Vassbotn;hallvard.vassbotn@c2i.net
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
[SeeAlso]
Count=5
1=JclHookExceptions
2=JclExceptionsHooked
3=ExceptNotifyProc;Global Variables\ExceptNotifyProc
4=ExceptNotifyMethod;Global Variables\ExceptNotifyMethod
5=ExceptionFrameTrackingEnable;Global Variables\ExceptionFrameTrackingEnable
<DECL>--------------------------------------------------------------------------
[Declaration]
function JclExceptionsHooked: Boolean;
[ShortDescr]
Determines if exceptions are hooked.
[Description]
JclExceptionsHooked determines if exceptions are currently hooked.
[Result]
If exceptions are hooked, the function returns True, otherwise it returns False.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Exception hooking
Author=Hallvard Vassbotn;hallvard.vassbotn@c2i.net
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
[SeeAlso]
Count=5
1=JclHookExceptions
2=JclUnhookExceptions
3=ExceptNotifyProc;Global Variables\ExceptNotifyProc
4=ExceptNotifyMethod;Global Variables\ExceptNotifyMethod
5=ExceptionFrameTrackingEnable;Global Variables\ExceptionFrameTrackingEnable
<DECL>--------------------------------------------------------------------------
[Declaration]
ExceptNotifyProc: TJclExceptNotifyProc;
[ShortDescr]
Exception notify routine place holder.
[Description]
ExceptNotifyProc is a procedural type variable pointing to a notifier routine
which gets called when an exception occurs and exceptions are hooked through a
previous call to JclHookExceptions.
[Quick Info]
Kind=Variable
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Exception hooking
Author=Hallvard Vassbotn;hallvard.vassbotn@c2i.net
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
[SeeAlso]
Count=5
1=JclHookExceptions
2=JclUnhookExceptions
3=JclExceptionsHooked
4=ExceptNotifyMethod;Global Variables\ExceptNotifyMethod
5=ExceptionFrameTrackingEnable;Global Variables\ExceptionFrameTrackingEnable
<DECL>--------------------------------------------------------------------------
[Declaration]
ExceptNotifyMethod: TJclExceptNotifyMethod;
[ShortDescr]
Exception notify method place holder.
[Description]
ExceptNotifyMethod is a procedural type variable pointing to a notifier method
which gets called when an exception occurs and exceptions are hooked through a
previous call to JclHookExceptions.
[Quick Info]
Kind=Variable
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Exception hooking
Author=Marcel Bestebroer;marcelb@zeelandnet.nl
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
[SeeAlso]
Count=5
1=JclHookExceptions
2=JclUnhookExceptions
3=JclExceptionsHooked
4=ExceptNotifyProc;Global Variables\ExceptNotifyProc
5=ExceptionFrameTrackingEnable;Global Variables\ExceptionFrameTrackingEnable
<DECL>--------------------------------------------------------------------------
[Declaration]
StackTrackingEnable: Boolean;
[ShortDescr]
Stack tracking enabled for hooked exceptions.
[Description]
StackTrackingEnable is a flag that enables or disables automatic stack tracking
when exception hooking is on.
[Quick Info]
Kind=Variable
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Exception hooking
Author=Hallvard Vassbotn;hallvard.vassbotn@c2i.net
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
[SeeAlso]
Count=5
1=ExceptionFrameTrackingEnable
2=RawStackTracking
3=JclHookExceptions;..\JclHookExceptions
4=JclUnhookExceptions;..\JclUnhookExceptions
5=JclExceptionsHooked;..\JclExceptionsHooked
<DECL>--------------------------------------------------------------------------
[Declaration]
RawStackTracking: Boolean;
[ShortDescr]
Raw tack tracking enabled for hooked exceptions.
[Description]
RawStackTracking is a flag that enables or disables raw stack tracking
when exception hooking is on and stack tracking is enabled.
[Quick Info]
Kind=Variable
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Exception hooking
Author=Hallvard Vassbotn;hallvard.vassbotn@c2i.net
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
[SeeAlso]
Count=4
1=StackTrackingEnable
2=JclHookExceptions;..\JclHookExceptions
3=JclUnhookExceptions;..\JclUnhookExceptions
4=JclExceptionsHooked;..\JclExceptionsHooked
<DECL>--------------------------------------------------------------------------
[Declaration]
ExceptionFrameTrackingEnable: Boolean;
[ShortDescr]
Except frame tracking enabled for hooked exceptions.
[Description]
ExceptionFrameTrackingEnable is a flag that enables or disables exception frame
tracking when exception hooking is on.
[Quick Info]
Kind=Variable
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Exception hooking
Author=Marcel Bestebroer;marcelb@zeelandnet.nl
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
[SeeAlso]
Count=6
1=JclHookExceptions;..\JclHookExceptions
2=JclUnhookExceptions;..\JclUnhookExceptions
3=JclExceptionsHooked;..\JclExceptionsHooked
4=ExceptNotifyProc
5=ExceptNotifyMethod
6=StackTrackingEnable
<DECL>--------------------------------------------------------------------------
[Declaration]
TrackAllModules: Boolean;
[ShortDescr]
Track all modules or Borland modules only.
[Description]
TrackAllModules is a flag that enables or disables tracking of all modules
when exception hooking is on and stack tracking is enabled. When set to True all
modules are reported in the stack list, otherwise only addresses that are within
a Borland module are reported.
[Quick Info]
Kind=Variable
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Exception hooking
Author=Petr Vones
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
function InsertDebugDataIntoExecutableFile(const ExecutableFileName,
  MapFileName: TFileName; var LinkerBugUnit: string;
  var MapFileSize, JclDebugDataSize: Integer): Boolean; overload;
function InsertDebugDataIntoExecutableFile(const ExecutableFileName: TFileName;
  BinDebug: TJclBinDebugGenerator; var LinkerBugUnit: string;
  var MapFileSize, JclDebugDataSize: Integer): Boolean; overload;
[ShortDescr]
Insert binary debug data into an executable.
[Description]
InsertDebugDataIntoExecutableFile inserts binary debug data as a resource into
the executable. With the first overloaded method you can specify a linker map
file while the second overloaded method allow you to specify a binary debug
generator. When the insertion succeeded True will be returned, otherwise False
is returned.
[Result]
If the binary debug data was succesfully inserted into the executable the
function returns True, otherwise it returns False. In addition to the function
result, it will also return the unit for the linker bug (if any found), the map
file size and the binary debug data size.
[Parameters]
Count=6
1=ExecutableFileName:TFileName=File name of executable you want the debug data
to be inserted in.
2=MapFileName:TFileName=Name of the map file to convert to binary debug data.
3=BinDebug:TJclBinDebugGenerator=The binary debug data generator.
4=LinkerBugUnit:string=Variable where the name of the unit where the linker bug
was first encountered should be stored. If there was no linker bug present, this
variable will be set to empty.
5=MapFileSize:Integer=Variable where the size of the linker map file will be
stored.
6=JclDebugDataSize:Integer=Variable where the size of the binary debug data will
be stored.
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Helpers
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
function ExtractClassName(const ProcedureName: string): string;
[ShortDescr]
Extracts the class name from a procedure name.
[Description]
ExtractClassName extracts the class name from the given procedure name (ie.
anything before the period). If the procedure name does not contain a class name
an empty string will be returned.
[Result]
If the given procedure name contains a '.', the string before the '.' will be
returned, otherwise an empty string is returned.
[Parameters]
Count=1
1=ProcedureName:string=Name of a procedure as returned by ProcOfAddr/ProcByLevel
or the _Proc parameter of MapByLevel/MapOfAddr
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
function ExtractMethodName(const ProcedureName: string): string;
[ShortDescr]
Extracts the method name from a procedure name.
[Description]
ExtractMethodName extracts the method name from the given procedure name (ie.
anything after the period). If the procedure name does not contain a class name
the entire string is returned.
[Result]
If the given procedure name contains a '.', the string after the '.' is returned,
otherwise the entire string is returned.
[Parameters]
Count=1
1=ProcedureName:string=Name of a procedure as returned by ProcOfAddr/ProcByLevel
or the _Proc parameter of MapByLevel/MapOfAddr
[Quick Info]
BCB=4,5
Unit=JclDebug
Category=Debugging
SubCat=Source Locations
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
