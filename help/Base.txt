<DECL>--------------------------------------------------------------------------
[Declaration]
JclVersion = (JclVersionMajor shl 24) or (JclVersionMinor shl 16) or (JclVersionRelease shl 15) or (JclVersionBuild shl 0);
JclVersionMajor   = Major;
JclVersionMinor   = Minor;
JclVersionRelease = Release;
JclVersionBuild   = Build;
[ShortDescr]
Constants describing the JCL version.
[Description]
The JclVersion constants define the version of JCL. Major, Minor, Release and
Build are merely placeholders, you can lookup the actual value in JclBase.pas.
  <TABLE>
  <TR VALIGN="top">
  <TH align=left width=30%>Constant</TH>
  <TH align=left width=70%>Description</TH>
  </TR>
  <TR VALIGN="top">
  <TD width=30%>JclVersion</TD>
  <TD width=70%>All of the other version values packed into a single integer.
    The separate values are moved into the individual bytes. From the most significant
    byte towards the least significant: Major, Minor, Release, Build</TD>
  </TR>
  <TR VALIGN="top">
  <TD width=30%>JclVersionMajor</TD>
  <TD width=70%>Major version of JCL</TD>
  </TR>
  <TR VALIGN="top">
  <TD width=30%>JclVersionMinor</TD>
  <TD width=70%>Minor version of JCL. Incremented for each minor release such
    as when minor additions and/or bug fixes have been made</TD>
  </TR>
  <TR VALIGN="top">
  <TD width=30%>JclVersionBuild</TD>
  <TD width=70%>Build number of JCL. This is roughly equivalent to the number
    of days that JCL has been worked on (starting February 2000)</TD>
  </TR>
  <TR VALIGN="top">
  <TD width=30%>JclVersionRelease</TD>
  <TD width=70%>If set to 1 this is an official release. If 0 this is a preview
    or beta version.</TD>
  </TR>
  </TABLE>
[Quick Info]
Kind=Constant
Unit=JclBase
Category=Base Services
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=4,5,6
Kylix=1
FPC=1.x
<DECL>--------------------------------------------------------------------------
[Declaration]
PResStringRec = ^string;
[ShortDescr]
ResStringRec is a pointer to a resource string.
[Description]
ResStringRec is a pointer to a resource string used with the creation of exceptions.
This type is provided for compatibility with FPC. When compiling with Delphi or
Kylix use the type defined in SysUtils.pas instead.
[Quick Info]
Kind=Type
Unit=JclBase
Category=Base Services
SubCat=FPC Compatibility
Author=JCL Team;jcl@delphi-jedi.org
FPC=1.x
<DECL>--------------------------------------------------------------------------
[Declaration]
function SysErrorMessage(ErrNo: Integer): string;
[ShortDescr]
Converts OS error codes into strings.
[Description]
SysErrorMessage returns an error message string that corresponds to the specified
OS error code. This routine is provided for compatibility with FPC. When compiling
with Delphi or Kylix use the SysErrorMessage from the RTL instead (SysUtils.pas).
[Parameters]
Count=1
1=ErrNo:Integer=The Windows API error code for which to retrieve the associated
error message.
[Result]
The error message string associated with the specified Windows API error code.
[Quick Info]
Unit=JclBase
Category=Base Services
SubCat=FPC Compatibility
Author=JCL Team;jcl@delphi-jedi.org
FPC=1.x
<DECL>--------------------------------------------------------------------------
[Declaration]
EJclError = class (Exception);
[ShortDescr]
Base exception class for all JCL exceptions.
[Description]
EJclError is the base class used for all exception classes in the JCL. It inherits
directly from Exception without adding any new functionality. It only exists to
provide a distinction between exceptions raised by the JCL and those raised by
the RTL/VCL and 3rd parties. It does introduce two constructors, CreateResRec and
CreateResRecFmt, which are replacements for the Exception class methods CreateRes
and CreateResFmt respectively (to remove the need for overloads and backwards
compatibility).
[Quick Info]
Kind=Type
Unit=JclBase
Category=Base Services
SubCat=EJclError
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=4,5,6
Kylix=1
FPC=1.x
<DECL>--------------------------------------------------------------------------
[Declaration]
constructor CreateResRecFmt(ResStringRec: PResStringRec; const Args: array of const);
[ShortDescr]
Creates an instance of EJclError with a message loaded from the application's resource and then formatted.
[Description]
Creates an instance of EJclError with a message loaded from the application's
resource and then formatted with additional information. The message is specified
using the ResStringRec parameter and is used as:<br>
  <p class="syntax">
  resourcestring<br>
    RsMyResource = 'Oops, an error occurred with code %u';<br>
  raise EJclError.CreateResRecFmt(@RsMyResource, [GetLastError]);<br>
  </p>
[Parameters]
Count=2
1=ResStringRec:PResStringRec=Pointer to a resource string. See the example above.
2=Args:array of const=Array of value used to format the message string with. See
the Format function for more information on how to use these parameters (internally
Format is used to do the formatting so the semantics are identical).
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclBase
Category=Base Services
SubCat=EJclError
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=4,5,6
Kylix=1
FPC=1.x
[SeeAlso]
Count=1
1=CreateResRec
<DECL>--------------------------------------------------------------------------
[Declaration]
constructor CreateResRec(ResStringRec: PResStringRec);
[ShortDescr]
Creates an instance of EJclError with a simple message loaded from the application's resource.
[Description]
Creates an instance of EJclError with a simple message loaded from the application's
resource. The message is specified using the ResStringRec parameter and is used as:<BR>
  <p class="syntax">
  resourcestring<br>
    RsMyResource = 'Oops, an error occurred';<br>
  raise EJclError.CreateResRec(@RsMyResource);<br>
  </p>
[Parameters]
Count=1
1=ResStringRec:PResStringRec=Pointer to a resource string. See the example above.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclBase
Category=Base Services
SubCat=EJclError
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=4,5,6
Kylix=1
FPC=1.x
[SeeAlso]
Count=1
1=CreateResRecFmt
<DECL>--------------------------------------------------------------------------
[Declaration]
EJclWin32Error = class (<REF Target"..\Types\EJclError">EJclError</REF>)
[ShortDescr]
Base class for exceptions raised in response to Win32 errors.
[Description]
The EJclWin32Error exception class is used as the base class for exceptions that
are raised in response to the failure of a Win32 API function that sets LastError.
The EJclWin32Error constructors automatically call GetLastError, the result of which
is made available to the programmer through the LastError property. Additionally it
appends a human-readable string to the passed in exception Msg corresponding to
the last error. This message is separated from the passed in Msg by a carriage
return and is made available through the LastErrorMsg property.
[Quick Info]
Unit=JclBase
Category=Base Services
SubCat=EJclWin32Error
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=4,5,6
Kylix=1
FPC=1.x
<DECL>--------------------------------------------------------------------------
[Declaration]
constructor Create(const Msg: string);
[ShortDescr]
Instantiates an EJclWin32Error with a simple string.
[Description]
Create instantiates an EJclWin32Error exception class. The Msg
parameter is the string which is displayed in the exception dialog box and is
also available through the Message property.
[Parameters]
Count=1
1=Msg:string=The string to be associated with the exception. The programmer can
query the class for this string using the Message property. If the exception is
unhandled the RTL displays this message in the exception dialog box.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclBase
Category=Base Services
SubCat=EJclWin32Error
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=4,5,6
Kylix=1
FPC=1.x
<DECL>--------------------------------------------------------------------------
[Declaration]
constructor CreateFmt(const Msg: string; const Args: array of const);
[ShortDescr]
Instantiates an EJclWin32Error with a formatted string.
[Description]
CreateFmt instantiates EJclWin32Error exception class. The Msg
parameter is the string which is displayed in the exception dialog box and is
also available through the Message property. See the Format function for more
information about formatting a string.
[Parameters]
Count=2
1=Msg:string=String containing format specifiers to be replaced with values from
the Args array.
2=Args:array of const=Array of constants which are formatted according to the format
specifiers in the Msg parameter.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclBase
Category=Base Services
SubCat=EJclWin32Error
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=4,5,6
Kylix=1
FPC=1.x
[SeeAlso]
Count=3
1=Create
2=CreateRes
3=CreateResRec
<DECL>--------------------------------------------------------------------------
[Declaration]
constructor CreateRes(Ident: Integer);
[ShortDescr]
Instantiates an instance of EJclWin32Error with a string loaded from the application's resource.
[Description]
CreateRes instantiates an EJclWin32Error exception class. Ident must be the unique
ID of a string resource which is displayed in the exception dialog box and is
also available through the Message property.
[Parameters]
Count=1
1=Ident:Integer=Unique ID of a string resource.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclBase
Category=Base Services
SubCat=EJclWin32Error
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=4,5,6
Kylix=1
FPC=1.x
[SeeAlso]
Count=3
1=Create
2=CreateFmt
3=CreateResRec
<DECL>--------------------------------------------------------------------------
[Declaration]
constructor CreateResRec(ResStringRec: PResStringRec);
[ShortDescr]
Instantiates an instance of EJclWin32Error with a string loaded from the application's resource.
[Description]
CreateRes instantiates an EJclWin32Error exception class. ResStringRec is a pointer
to a message which is loaded from the application's resource.
[Parameters]
Count=1
1=ResStringRec:PResStringRec=ResStringRec is a pointer to a resource string.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclBase
Category=Base Services
SubCat=EJclWin32Error
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=4,5,6
Kylix=1
FPC=1.x
[SeeAlso]
Count=3
1=Create
2=CreateFmt
3=CreateRes
<DECL>--------------------------------------------------------------------------
[Declaration]
property LastError: DWORD read FLastError;
[ShortDescr]
Contains the LastError.
[Description]
The LastError property returns the error code retrieved by a call to GetLastError
at the time the exception was raised.
[Quick Info]
Kind=Property
Visibility=Public
Unit=JclBase
Category=Base Services
SubCat=EJclWin32Error
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=4,5,6
Kylix=1
FPC=1.x
[SeeAlso]
Count=1
1=LastErrorMsg
<DECL>--------------------------------------------------------------------------
[Declaration]
property LastErrorMsg: string read FLastErrorMsg;
[ShortDescr]
Error string corresponding to LastError.
[Description]
The LastErrorMsg property contains the error message string associated with the last
error code.
[Quick Info]
Kind=Property
Visibility=Public
Unit=JclBase
Category=Base Services
SubCat=EJclWin32Error
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=4,5,6
Kylix=1
FPC=1.x
[SeeAlso]
Count=1
1=LastError
<DECL>--------------------------------------------------------------------------
[Declaration]
Float = Extended
[ShortDescr]
Generic floating point type.
[Description]
Float represents a generic floating point type and is used mostly in JclMath.
Float is conditionally defined as either Extended, Double or Single with Extended
being the default. You can change the type that Float is defined as globally
by using the MATH_PRECISION_X compiler directives.
See <REF Target"..\..\About JCL\Compiler Directives">Compiler Directives</REF>
for more information.
[Quick Info]
Kind=Type
Unit=JclBase
Category=Base Services
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=4,5,6
Kylix=1
FPC=1.x
<DECL>--------------------------------------------------------------------------
[Declaration]
LongWord = Cardinal;
[ShortDescr]
Alias for Cardinal.
[Description]
LongWord is an alias for Cardinal and as such represents an unsigned 32-bit
integer. For Delphi 4 and C++ Builder 4 up this type is 'defined' in System.pas,
in earlier versions this type didn't exist so it is defined in JclBase.
[Quick Info]
Kind=Type
Unit=JclBase
Category=Base Services
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=
Kylix=1
FPC=1.x
<DECL>--------------------------------------------------------------------------
[Declaration]
TSysCharSet = set of Char;
[ShortDescr]
A set of characters.
[Description]
TSysCharSet represents a set of characters. For Delphi 4 and C++ Builder 4 up this
type is defined in SysUtils, in earlier versions this type didn't exist so it is
defined in JclBase.
[Quick Info]
Kind=Type
Unit=JclBase
Category=Base Services
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=
Kylix=1
FPC=1.x
<DECL>--------------------------------------------------------------------------
[Declaration]
Int64 = packed record
  case Integer of
  0: (
    LowPart: DWORD;
    HighPart: Longint);
  {$IFNDEF BCB3}
  1: (
    QuadPart: LONGLONG);
  {$ENDIF}
end;
[ShortDescr]
Int64 is used to simulate an unsigned 64-bit value in compilers which do not
natively support this type. All supported compilers except Delphi 3 and
C++ Builder 3 natively support Int64 in which case Int64 is not redefined. Various
support routines have been defined to assist manipulating an Int64.
[RecordFields]
Count=3
1=LowPart:DWORD=The low-order 32-bits
2=HighPart:DWORD=The high-order 32-bits
3=QuadPart:LONGLONG=The 64-bit unsigned integer
[Quick Info]
Kind=Type
Unit=JclBase
Category=Base Services
SubCat=Int64 support
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=
Kylix=1
FPC=1.x
[SeeAlso]
Count=3
1=I64Copy
2=I64Compare
3=I64Assign
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure I64Assign(var I: Int64; Low, High: Longint);
[ShortDescr]
Initializes an Int64 to the supplied values.
[Description]
I64Assign implements initialization for an Int64 from the supplied long integers.
[Parameters]
Count=3
1=I:Int64=The Int64 to initialize
2=Low:Longint=Low 32 bits for the Int64
3=High:Longint=High 32 bits for the Int64
[Quick Info]
Unit=JclBase
Category=Base Services
SubCat=Int64 support
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=
Kylix=1
FPC=1.x
[SeeAlso]
Count=2
1=I64Copy
2=I64Compare
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure I64Copy(var Dest: Int64; const Source: Int64);
[ShortDescr]
Copies an Int64
[Description]
I64Copy copies the value of Source into Dest. Source is unaffected by this.
[Parameters]
Count=2
1=Dest:Int64=Destination Int64
2=Source:Int64=Source Int64
[Quick Info]
Unit=JclBase
Category=Base Services
SubCat=Int64 support
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=
Kylix=1
FPC=1.x
[SeeAlso]
Count=2
1=I64Assign
2=I64Compare
<DECL>--------------------------------------------------------------------------
[Declaration]
function I64Compare(const I1, I2: Int64): Integer;
[ShortDescr]
Compares two 64 bit integers.
[Description]
I64Compares the two supplied 64-bit integers for equality.
[Parameters]
Count=2
1=I1:Int64=First Int64
2=I2:Int64=Second Int64
[Result]
If I1 equals I2 the result is 0, if I1 is larger than I2 the result is greater than
0 (specifically 1) and if I1 is smaller than I2 the result is smaller than 0
(specifically -1).
[Quick Info]
Unit=JclBase
Category=Base Services
SubCat=Int64 support
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=
Kylix=1
FPC=1.x
[SeeAlso]
Count=2
1=I64Assign
2=I64Copy
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure CardinalsToI64(var I: Int64; LowPart, HighPart: Cardinal);
[ShortDescr]
Packs the supplied 32 bit values in an Int64
[Description]
CardinalsToInt64 packs the two supplied 32 bit values into a single Int64. Note
that this routine is only available for compilers that natively support Int64.
[Parameters]
Count=3
1=I:Int64=The 64 bit value into which to pack the high and low parts.
2=LowPart:Cardinal=Low 32 bits for the supplied Int64
3=HighPart:Cardinal=High 32 bits for the supplied Int64
[Quick Info]
Unit=JclBase
Category=Base Services
SubCat=Int64 support
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=5,6
Kylix=1
FPC=1.x
[SeeAlso]
Count=1
1=I64ToCardinals
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure I64ToCardinals(I: Int64; var LowPart, HighPart: Cardinal);
[ShortDescr]
Extracts the high and low 32 bit values from an Int64.
[Description]
I64ToCardinals extracts the high and low 32 bit values from the supplied Int64.
Note that this routine is only available for compilers that natively support Int64.
[Parameters]
Count=3
1=I:Int64=The 64 bit value from which to extract the high and low parts.
2=LowPart:Cardinal=Low 32 bits of the supplied Int64
3=HighPart:Cardinal=High 32 bits of the supplied Int64
[Quick Info]
Unit=JclBase
Category=Base Services
SubCat=Int64 support
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=5,6
Kylix=1
FPC=1.x
[SeeAlso]
Count=1
1=CardinalsToI64
<DECL>--------------------------------------------------------------------------
[Declaration]
TDynArray = array of Type;
[ShortDescr]
A dynamic array of some type.
[Description]
TDynArray represents a dynamic array. Depending on the compiler version this is an
actual dynamic array or a simulated dynamic array. The tables below show the
declaration of the dynamic array types. When the compiler natively supports
dynamic arrays you can work with types just as if they were declared using the
array of Type syntax. <P>If the compiler doesn't support dynamic arrays you
must use the various DynArrayXxx routines. Before you can use a TDynArray you
must initialize it using <REF Target"..\DynArrayInitialize">DynArrayInitialize</REF>.
To query or change the length of the array you use <REF Target"..\DynArrayLength">DynArrayLength</REF>
and <REF Target"..\DynArraySetLength">DynArraySetLength</REF> respectively. To
reference an element of the array you use MyArray^[Index] where Index is the index
of the element between 0 and the length of the array minus 1. When you are done
with the array you must release it's memory by calling <REF Target"..\DynArrayFinalize">DynArrayFinalize</REF>.
  <P><B>Compiler supports dynamic arrays</B> (Note that routines that take a TDynArray
  as a parameter need an actual TDynArray so you can't declare the parameter using
  the "array of Type" syntax):
  <TABLE>
  <TR VALIGN="top">
  <TH align=left width=50%>Type</TH>
  <TH align=left width=50%>Declaration</TH>
  </TR>
  <TR VALIGN="top"><TD width=30%>TDynByteArray</TD><TD width=50%>array of Byte</TD></TR>
  <TR VALIGN="top"><TD width=30%>TDynShortArray</TD><TD width=50%>array of Shortint</TD></TR>
  <TR VALIGN="top"><TD width=30%>TDynSmallintArray</TD><TD width=50%>array of Smallint</TD></TR>
  <TR VALIGN="top"><TD width=30%>TDynWordArray</TD><TD width=50%>array of Word</TD></TR>
  <TR VALIGN="top"><TD width=30%>TDynIntegerArray</TD><TD width=50%>array of Integer</TD></TR>
  <TR VALIGN="top"><TD width=30%>TDynLongintArray</TD><TD width=50%>array of Longint</TD></TR>
  <TR VALIGN="top"><TD width=30%>TDynCardinalArray</TD><TD width=50%>array of Cardinal</TD></TR>
  <TR VALIGN="top"><TD width=30%>TDynInt64Array</TD><TD width=50%>array of Int64</TD></TR>
  <TR VALIGN="top"><TD width=30%>TDynExtendedArray</TD><TD width=50%>array of Extended</TD></TR>
  <TR VALIGN="top"><TD width=30%>TDynDoubleArray</TD><TD width=50%>array of Double</TD></TR>
  <TR VALIGN="top"><TD width=30%>TDynSingleArray</TD><TD width=50%>array of Single</TD></TR>
  </TABLE>
  <P><B>Compiler does not support dynamic arrays</B> (See the various DynArrayXxx routines).
    The TDynXxxArray types are declared as a pointer to PDynXxxArray types. The
    use of the 'P' and 'T' prefix are reversed here to maintain consistency with
    the situation where dynamic arrays are supported. As an example the full
    declaration of TDynByteArray is:<BR>
    PDynByteArray = array [0..DynByteArrayHigh] of Byte; <BR>
    TDynByteArray = ^PDynByteArray; <BR>
    Keep in mind that it is the TDynArray variant that actually use in your code
    but that in reality this is a pointer and as such must be dereferenced before
    you can access an element of the array.
  <TABLE>
  <TR VALIGN="top">
  <TH align=left width=50%>Type</TH>
  <TH align=left width=50%>Declaration</TH>
  </TR>
  <TR VALIGN="top"><TD width=30%>TDynByteArray</TD><TD width=50%>^array [0..DynByteArrayHigh] of Byte</TD></TR>
  <TR VALIGN="top"><TD width=30%>TDynShortArray</TD><TD width=50%>^array [0..DynShortintArrayHigh] of Shortint</TD></TR>
  <TR VALIGN="top"><TD width=30%>TDynSmallintArray</TD><TD width=50%>^array [0..DynSmallintArrayHigh] of Smallint</TD></TR>
  <TR VALIGN="top"><TD width=30%>TDynWordArray</TD><TD width=50%>^array [0..DynWordArrayHigh] of Word</TD></TR>
  <TR VALIGN="top"><TD width=30%>TDynIntegerArray</TD><TD width=50%>^array [0..DynIntegerArrayHigh] of Integer</TD></TR>
  <TR VALIGN="top"><TD width=30%>TDynLongintArray</TD><TD width=50%>^array [0..DynLongintArrayHigh] of Longint</TD></TR>
  <TR VALIGN="top"><TD width=30%>TDynCardinalArray</TD><TD width=50%>^array [0..DynCardinalArrayHigh] of Cardinal</TD></TR>
  <TR VALIGN="top"><TD width=30%>TDynInt64Array</TD><TD width=50%>^array [0..DynInt64ArrayHigh] of Int64</TD></TR>
  <TR VALIGN="top"><TD width=30%>TDynExtendedArray</TD><TD width=50%>^array [0..DynExtendedArrayHigh] of Extended</TD></TR>
  <TR VALIGN="top"><TD width=30%>TDynDoubleArray</TD><TD width=50%>^array [0..DynDoubleArrayHigh] of Double</TD></TR>
  <TR VALIGN="top"><TD width=30%>TDynSingleArray</TD><TD width=50%>^array [0..DynSingleArrayHigh] of Single</TD></TR>
  </TABLE>
[Quick Info]
Kind=Type
Unit=JclBase
Category=Base Services
SubCat=Dynamic arrays
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=4,5,6
Kylix=1
FPC=1.x
<DECL>--------------------------------------------------------------------------
[Declaration]
DynArrayHigh = 2^31 div SizeOf(ArrayType);
[ShortDescr]
Upper bound for dynamic array of some type.
[Description]
DynArrayHigh contains the upper bound for a dynamic array of some type. The table
below shows these values for each supported type. These value are obtained by
dividing 2GB (the maximum array size) by the size of the type (in bytes). Note
that DynFloatArrayHigh depends on the MATH_PRECISION_X compiler directive and
as such equals DynExtendedArrayHigh, DynDoubleArrayHigh or DynSingleArrayHigh.
  <TABLE>
  <TR VALIGN="top">
  <TH align=left width=50%>Constant</TH>
  <TH align=left width=50%>Value</TH>
  </TR>
  <TR VALIGN="top"><TD width=30%>DynByteArrayHigh</TD><TD width=50%>2147483646</TD></TR>
  <TR VALIGN="top"><TD width=30%>DynShortArrayHigh</TD><TD width=50%>2147483646</TD></TR>
  <TR VALIGN="top"><TD width=30%>DynSmallintArrayHigh</TD><TD width=50%>1073741822</TD></TR>
  <TR VALIGN="top"><TD width=30%>DynWordArrayHigh</TD><TD width=50%>1073741822</TD></TR>
  <TR VALIGN="top"><TD width=30%>DynIntegerArrayHigh</TD><TD width=50%>536870908</TD></TR>
  <TR VALIGN="top"><TD width=30%>DynLongintArrayHigh</TD><TD width=50%>536870908</TD></TR>
  <TR VALIGN="top"><TD width=30%>DynCardinalArrayHigh</TD><TD width=50%>536870908</TD></TR>
  <TR VALIGN="top"><TD width=30%>DynInt64ArrayHigh</TD><TD width=50%>268435448</TD></TR>
  <TR VALIGN="top"><TD width=30%>DynExtendedArrayHigh</TD><TD width=50%>214748363</TD></TR>
  <TR VALIGN="top"><TD width=30%>DynDoubleArrayHigh</TD><TD width=50%>536870908</TD></TR>
  <TR VALIGN="top"><TD width=30%>DynSingleArrayHigh</TD><TD width=50%>268435448</TD></TR>
  </TABLE>
[Quick Info]
Kind=Constant
Unit=JclBase
Category=Base Services
SubCat=Dynamic arrays
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=
Kylix=1
FPC=1.x
<DECL>--------------------------------------------------------------------------
[Declaration]
function DynArrayAllocSize(const A): Longint;
[ShortDescr]
Returns the allocation size for a dynamic array.
[Description]
DynArrayAllocSize returns the amount of memory, in bytes, that are allocated for
the supplied dynamic array. Since dynamic arrays are allocated with some additional
maintenance data the return value will always be at least 12 bytes more than the
memory needed to hold the actual elements.
[Parameters]
Count=1
1=A:TDynXxxArray=The dynamic array for which you want to know the allocation size.
This array <U>must</U> have been previously initialized with <REF>DynArrayInitialize</REF>
or the result will be unpredictable.
[Result]
The amount of dynamic memory, in bytes, reserved for the dynamic array.
[Quick Info]
Unit=JclBase
Category=Base Services
SubCat=Dynamic arrays
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=
Kylix=1
FPC=1.x
[SeeAlso]
Count=5
1=DynArrayLength
2=DynArrayElemSize
3=DynArrayInitialize
4=DynArrayFinalize
5=DynArraySetLength
<DECL>--------------------------------------------------------------------------
[Declaration]
function DynArrayLength(const A): Longint;
[ShortDescr]
Returns the length of a dynamic array.
[Description]
DynArrayLength returns the length of the supplied dynamic array in terms of the
number of elements contained in the array. This is always the value supplied to
the last call to <REF>DynArraySetLength</REF> or <REF>DynArrayInitialize</REF>.
Note that a dynamic array is allowed to have a length of 0.
[Parameters]
Count=1
1=A:TDynXxxArray=The dynamic array whose length you want.
[Result]
The length of the supplied dynamic array in terms of number of elements.
[Quick Info]
Unit=JclBase
Category=Base Services
SubCat=Dynamic arrays
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=
Kylix=1
FPC=1.x
[SeeAlso]
Count=5
1=DynArrayAllocSize
2=DynArrayElemSize
3=DynArrayInitialize
4=DynArrayFinalize
5=DynArraySetLength
<DECL>--------------------------------------------------------------------------
[Declaration]
function DynArrayElemSize(const A): Longint;
[ShortDescr]
Returns the size of an element in the array.
[Description]
DynArrayElemSize returns the size, in bytes, of the elements contained in the
dynamic array. This function is not very useful for application programmers but
is used internally.
[Parameters]
Count=1
1=A:TDynXxxArray=The dynamic array you want to query for its element size.
[Result]
The size of an individual element, in bytes.
[Quick Info]
Unit=JclBase
Category=Base Services
SubCat=Dynamic arrays
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=
Kylix=1
FPC=1.x
[SeeAlso]
Count=5
1=DynArrayAllocSize
2=DynArrayLength
3=DynArrayInitialize
4=DynArrayFinalize
5=DynArraySetLength
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure DynArrayInitialize(var A; ElementSize, InitialLength: Longint);
[ShortDescr]
Initializes a dynamic array for use.
[Description]
DynArrayInitialize initializes a dynamic array variable for use. You must call
this function before using the dynamic array. The function allocates memory
for the maintenance data and initial elements, if directed to do so. Initial
elements are initialized to 0 and can be used immediately without having to
call <REF>DynArraySetLength</REF>. When you are done using the array you must
release its memory by calling <REF>DynArrayFinalize</REF>.
[Parameters]
Count=3
1=A:TDynXxxArray=The dynamic array variable to initialize;
2=ElementSize:Longint=Size, in bytes, of the elements contained in the dynamic
array. Always use the SizeOf operator for this parameter. For example, if A is
declared as a TDynIntegerArray then use SizeOf(Integer) for this parameter.
3=InitialLength:Longint=Initial size of the array. That is, the number of elements
in the array. The function allocates enough memory to hold at least InitialLength
number of elements and initializes them to 0. You can immediately start to use
them without the need to call <REF>DynArraySetLength</REF>. You can pass 0 if you
don't want to initialize the length of the array.
[Quick Info]
Unit=JclBase
Category=Base Services
SubCat=Dynamic arrays
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=
Kylix=1
FPC=1.x
[SeeAlso]
Count=5
1=DynArrayAllocSize
2=DynArrayLength
3=DynArrayElemSize
4=DynArrayFinalize
5=DynArraySetLength
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure DynArrayFinalize(var A);
[ShortDescr]
Releases the memory reserved for the dynamic array.
[Description]
DynArrayFinalize releases the memory reserved for the dynamic array. You must
always call this function when done using the dynamic array. Note that setting
the array's length to 0 with <REF>DynArraySetLength</REF> does not release all
memory associated with the dynamic array.
[Parameters]
Count=1
1=A:TDynXxxArray=The dynamic array variable to finalize. 
[Quick Info]
Unit=JclBase
Category=Base Services
SubCat=Dynamic arrays
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=
Kylix=1
FPC=1.x
[SeeAlso]
Count=5
1=DynArrayAllocSize
2=DynArrayLength
3=DynArrayElemSize
4=DynArrayInitialize
5=DynArraySetLength
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure DynArraySetLength(var A; NewLength: Integer);
[ShortDescr]
Sets the length of the dynamic array.
[Description]
DynArraySetLength sets the length of the specified dynamic array. The array
must have previously been initialized with <REF>DynArrayInitialize</REF>. This
function maintains the contents of the elements in the array before resizing it
and in the situation where the array grows, the new elements are initialized to 0.
[Parameters]
Count=2
1=A:TDynXxxArray=The dynamic array to resize.
2=NewLength:Integer=The new length, in terms of number of elements, of the array.
This value must be greater than or equal to 0. Note that setting the array's
length to 0 does not release all of it's associated memory. You must
call <REF>DynArrayFinalize</REF> when done using the dynamic array.
[Quick Info]
Unit=JclBase
Category=Base Services
SubCat=Dynamic arrays
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=
Kylix=1
FPC=1.x
[SeeAlso]
Count=5
1=DynArrayAllocSize
2=DynArrayLength
3=DynArrayElemSize
4=DynArrayInitialize
5=DynArrayFinalize
<DECL>--------------------------------------------------------------------------
[Declaration]
TObjectList = class (TList)
[ShortDescr]
TList descendent to maintain a list of TObject descendants.
[Description]
TObjectList is a TList descendant adapted to maintain a list of TObject descendants
which can optionally be owned by the class. If the class owns the items, it will
automatically free the objects when the list is cleared. This class is only provided 
for backward compatibility and is not a full-fledged implementation of TObjectList
as found in Delphi 5 and up.
[Quick Info]
Unit=JclBase
Category=Base Services
SubCat=TObjectList
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4
Kylix=1
FPC=1.x
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure Clear; override;
[ShortDescr]
Deletes all items from the list.
[Description]
Clear empties the list, frees the memory used to store the Objects array, and
sets Count and Capacity to 0. If OwnsObjects is True, Clear also frees the objects
in the list.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclBase
Category=Base Services
SubCat=TObjectList
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5,6
Kylix=1
FPC=1.x
<DECL>--------------------------------------------------------------------------
[Declaration]
constructor Create(AOwnsObjects: Boolean = False);
[ShortDescr]
Creates an instance of TObjectList
[Description]
Creates an instance of TObjectList and initializes the OwnsObjects property.
[Parameters]
Count=1
1=AOwnsObjects:Boolean=Initial value for the OwnsObjects property. 
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclBase
Category=Base Services
SubCat=TObjectList
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5,6
Kylix=1
FPC=1.x
<DECL>--------------------------------------------------------------------------
[Declaration]
property OwnsObjects: Boolean read FOwnsObjects write FOwnsObjects;
[ShortDescr]
Determines whether the class owns it's items.
[Description]
The OwnsObjects property determines whether the class owns the objects it stores.
If set to True, clearing the list through the Clear method will free all objects
in addition to removing them from the list. If set to False, clearing the list
through the Clear method merely removes the items from the list but does not free
the objects.
[Quick Info]
Kind=Property
Visibility=Public
Unit=JclBase
Category=Base Services
SubCat=TObjectList
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5,6
Kylix=1
FPC=1.x
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure RaiseLastOSError;
[ShortDescr]
Raises an exception for the last occurring OS or system library error.
[Description]
Call RaiseLastOSError to raise an EWin32Error exception for the last OS API call that
failed. RaiseLastOSError retrieves the code for the last occurring API call error,
if any. If this belongs to a previously occurring error, RaiseLastOSError raises an
EWin32Error exception with the error code and message associated with that error.
This routine is provided for backwards compatibility.
[Quick Info]
Unit=JclBase
Category=Base Services
SubCat=Compatibility
Author=JCL Team;jcl@delphi-jedi.org
Delphi=4,5
Kylix=1
FPC=1.x
<DECL>--------------------------------------------------------------------------
[Declaration]
IInterface = IUnknown;
[ShortDescr]
IInterface is the base class for all Object Pascal interfaces.
[Description]
IInterface is the base class for all Object Pascal interfaces. This interface
declaration is provided for backwards compatibility. When compiling with a pre
Delphi 6 compiler it is declared as an alias for IUnknown. In Delphi 6 and above,
this interface is declared in the System.pas unit and IUnknown is declared as an
alias for IInterface. For more information see the Delphi for IUnknown or IInterface
depending on your Delphi version.
[Quick Info]
Kind=Type
Unit=JclBase
Category=Base Services
SubCat=Compatibility
Author=JCL Team;jcl@delphi-jedi.org
Delphi=4,5
Kylix=1
FPC=1.x
