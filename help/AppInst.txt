<DECL>--------------------------------------------------------------------------
[Declaration]
TJclAppInstances = class (TObject)
[ShortDescr]
TJclAppInstances allows you to control the number of application instances the user can run.
[Description]
TJclAppInstances is a class which allows you to control the number of instances
of your application that the user can run simultaneously. In addition the class
has a built in method for simple communication among running instances. The
application programmer can use this as desired but it's also used to send notifications.
For example, when an application starts running or terminates, the class automatically
sends a notification about this event to all other instances. To use TJclAppInstances
include JclAppInst and somewhere during start up (eg in the project source before
the Application.Initialize call) call JclAppInstances.CheckInstance(X) or
JclAppInstances.CheckSingleInstance. The first call determines whether or not
at most X instances are already running, but does nothing else, while the second
call immediately terminates the application when another instance is already running.
 <P>To receive notifications you must override the WndProc of your main form and
include the following code (or something along those lines):<BR>
  <PRE Class=Syntax>
procedure TForm1.WndProc(var Msg: TMessage);<BR>
begin<BR>
  if Msg.Msg = JclAppInstances.MessageId then<BR>
    case Msg.WParam of<BR>
      AI_INSTANCECREATED: [another instance was created]<BR>
      AI_INSTANCEDESTROYED: [another instance was destroyed]<BR>
      AI_USERMSG: [user defined message (UserNotify)]<BR>
    end;
  inherited WndProc(Msg);
end;
  </PRE>
Note that in both instance creation and instance destruction the Msg.LParam
field contains the process ID of the affected instance (which could be the instance
itself). Also, notifications as well as user messages are sent to both the main
form and to the application message queue. Therefore instead of overriding
WndProc you could have also used the TApplication.OnMessage event.
[Quick Info]
Unit=JclAppInst
Category=Libraries, Processes and Threads
SubCat=TJclAppInstances
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5,6
Kylix=1
FPC=1.x
<DECL>--------------------------------------------------------------------------
[Declaration]
AI_INSTANCECREATED = $0001;
[ShortDescr]
WParam field for instance creation notifications
[Description]
When an application instance is created TJclAppInstances sends a notification message
to all other running instances. The message value is determined by the MessageId
property, the WParam field is set to AI_INSTANCECREATED, and the LParam field is
set to the Process ID of the instance being created. Note that the message is also
sent to the application instance under construction.
[Quick Info]
Kind=Constant
Unit=JclAppInst
Category=Libraries, Processes and Threads
SubCat=TJclAppInstances
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5,6
Kylix=1
FPC=1.x
[SeeAlso]
Count=2
1=AI_INSTANCEDESTROYED
2=AI_USERMSG
<DECL>--------------------------------------------------------------------------
[Declaration]
AI_INSTANCEDESTROYED = $0002;
[ShortDescr]
WParam field for instance destruction notifications
[Description]
When an application instance is destroyed TJclAppInstances sends a notification message
to all other running instances. The message value is determined by the MessageId
property, the WParam field is set to AI_INSTANCEDESTROYED, and the LParam field is
set to the Process ID of the instance being destroyed. Note that the message is also
sent to the application instance which is exiting.
[Quick Info]
Kind=Constant
Unit=JclAppInst
Category=Libraries, Processes and Threads
SubCat=TJclAppInstances
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5,6
Kylix=1
FPC=1.x
[SeeAlso]
Count=2
1=AI_INSTANCECREATED
2=AI_USERMSG
<DECL>--------------------------------------------------------------------------
[Declaration]
AI_USERMSG = $0003;
[ShortDescr]
WParam field for user-defined notification messages.
[Description]
When an application uses the UserNotify method of TJclAppInstances the class
sends a message to all running instances with a message value determined by the
MessageID property, WParam set to AI_USERMSG and LParam set to the parameter
specified in the method call.
[Quick Info]
Kind=Constant
Unit=JclAppInst
Category=Libraries, Processes and Threads
SubCat=TJclAppInstances
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5,6
Kylix=1
FPC=1.x
[SeeAlso]
Count=2
1=AI_INSTANCECREATED
2=AI_INSTANCEDESTROYED
<DECL>--------------------------------------------------------------------------
[Declaration]
class function BringAppWindowToFront(const Wnd: HWND): Boolean;
[ShortDescr]
Brings the specified window to the foreground.
[Description]
BringAppWindowToFront puts the thread that created the specified window to the
foreground and activates the window. Keyboard input is directed
to the window, and various visual cues are changed for the user. The system
assigns a slightly higher priority to the thread that created the foreground
window than it does to other threads (from the Platform SDK).
[Parameters]
Count=1
1=Wnd:HWND=Handle of the window to bring to the foreground.
[Result]
If the function succeeds it returns True, otherwise it returns False.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclAppInst
Category=Libraries, Processes and Threads
SubCat=TJclAppInstances
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5,6
Kylix=1
FPC=1.x
[SeeAlso]
Count=1
1=SetForegroundWindow98
<DECL>--------------------------------------------------------------------------
[Declaration]
class function GetApplicationWnd(const ProcessID: DWORD): HWND;
[ShortDescr]
Returns a handle to the application window of a process. 
[Description]
Returns a handle to the invisible window created by the process with the
specified ProcessID.
[Parameters]
Count=1
1=ProcessID:DWORD=Process ID of the application for which you want to retrieve
a handle to the application window. This specified application must be a Delphi
application otherwise the function fails.
[Result]
If the function succeeds it returns the requested handle, otherwise it returns 0.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclAppInst
Category=Libraries, Processes and Threads
SubCat=TJclAppInstances
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5,6
Kylix=1
FPC=1.x
<DECL>--------------------------------------------------------------------------
[Declaration]
class procedure KillInstance;
[ShortDescr]
Terminates the application.
[Description]
KillInstance terminates the application by calling Halt.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclAppInst
Category=Libraries, Processes and Threads
SubCat=TJclAppInstances
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5,6
Kylix=1
FPC=1.x
<DECL>--------------------------------------------------------------------------
[Declaration]
class function SetForegroundWindow98(const Wnd: HWND): Boolean;
[ShortDescr]
Brings the specified window to the foreground.
[Description]
SetForegroundWindow98 puts the thread that created the specified window to the
foreground and activates the window. Keyboard input is directed
to the window, and various visual cues are changed for the user. The system
assigns a slightly higher priority to the thread that created the foreground
window than it does to other threads (from the Platform SDK).
[Parameters]
Count=1
1=Wnd:HWND=Handle of the window to bring into the foreground.
[Result]
If the function succeeds it returns True, otherwise it returns False.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclAppInst
Category=Libraries, Processes and Threads
SubCat=TJclAppInstances
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5,6
Kylix=1
FPC=1.x
[SeeAlso]
Count=1
1=BringAppWindowToFront
<DECL>--------------------------------------------------------------------------
[Declaration]
function CheckInstance(const MaxInstances: Word): Boolean;
[ShortDescr]
Check the number of running instances.
[Description]
CheckInstance determines whether fewer than MaxInstances application instances
are running. If this is true, the process is registered as a running instance
and a notification is sent to all other running instances, otherwise the function
does nothing. Note that unlike CheckSingleInstance, the application is not
terminated and none of the already running instances is brought to the foreground.
It's up to the application programmer to decide what to do if the function fails.
You could, for example, terminate the application yourself by
calling <REF>KillInstance</REF>.
[Result]
If fewer than MaxInstances applications are running the result is True,
otherwise the result is False.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclAppInst
Category=Libraries, Processes and Threads
SubCat=TJclAppInstances
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5,6
Kylix=1
FPC=1.x
[SeeAlso]
Count=3
1=CheckSingleInstance
2=CheckMultipleInstances
3=KillInstance
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure CheckMultipleInstances(const MaxInstances: Word);
[ShortDescr]
Check the number of running instances.
[Description]
CheckMultipleInstances determines whether fewer than MaxInstances application
instances are running. If this is true, the process is registered as a running
instance and a notification is sent to all other running instances, otherwise the
method brings the first instance of the application to the foreground and then
terminates itself (as such the routine never returns).
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclAppInst
Category=Libraries, Processes and Threads
SubCat=TJclAppInstances
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5,6
Kylix=1
FPC=1.x
[SeeAlso]
Count=3
1=CheckSingleInstance
2=CheckInstance
3=KillInstance
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure CheckSingleInstance;
[ShortDescr]
Checks whether this is the one and only running instance.
[Description]
CheckSingleInstance checks whether the caller is the only instance of this process.
If it's not, the application is immediately terminated and the existing instance
of the process is brought into the foreground.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclAppInst
Category=Libraries, Processes and Threads
SubCat=TJclAppInstances
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5,6
Kylix=1
FPC=1.x
[SeeAlso]
Count=1
1=CheckInstance
<DECL>--------------------------------------------------------------------------
[Declaration]
function SwitchTo(const Index: Integer): Boolean;
[ShortDescr]
SwitchTo brings the application determined by ProcessIDs[Index] to the foreground.
[Description]
SwitchTo brings the application determined by ProcessIDs[Index] to the foreground.
[Parameters]
Count=1
1=Index:Integer=Zero based index into the ProcessIDs array property of the instance
to switch to.
[Result]
If the function succeeds it returns True, otherwise it returns False.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclAppInst
Category=Libraries, Processes and Threads
SubCat=TJclAppInstances
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5,6
Kylix=1
FPC=1.x
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure UserNotify(const Param: Longint);
[ShortDescr]
Sends a user defined message to all running instances.
[Description]
UserNotify sends a notification message to all running instances with WParam set
to AI_USERMSG and LParam set to the specified parameter.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclAppInst
Category=Libraries, Processes and Threads
SubCat=TJclAppInstances
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5,6
Kylix=1
FPC=1.x
<DECL>--------------------------------------------------------------------------
[Declaration]
property MessageID: DWORD read FMessageID;
[ShortDescr]
Returns the message ID used for sending notification messages.
[Description]
Read MessageId to learn the message ID used by TJclAppInstances to send
notification messages (ie instance creation and destruction).
[Quick Info]
Kind=Property
Visibility=Public
Unit=JclAppInst
Category=Libraries, Processes and Threads
SubCat=TJclAppInstances
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5,6
Kylix=1
FPC=1.x
<DECL>--------------------------------------------------------------------------
[Declaration]
property ProcessIDs[Index: Integer]: DWORD read GetProcessIDs;
[ShortDescr]
Process IDs of all application instances which are sharing the TJclAppInstances.
[Description]
The ProcessIDs array property contains the process IDs of all application instances
which are sharing the TJclAppInstances. In effect it contains the process IDs
of all running instances. The array is zero based and the highest valid index
is given by <REF>InstanceCount</REF> property. If an invalid index is specified
the property reads 0. Note that it is possible that in between reading InstanceCount
and ProcessIDs, or reading ProcessIDs and it, an instance terminates thereby
invalidating the process ID. Always check the result before and after using the
returned process ID.
[Quick Info]
Kind=Property
Visibility=Public
Unit=JclAppInst
Category=Libraries, Processes and Threads
SubCat=TJclAppInstances
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5,6
Kylix=1
FPC=1.x
[SeeAlso]
Count=3
1=InstanceCount
2=AppWnds
3=InstanceIndex
<DECL>--------------------------------------------------------------------------
[Declaration]
property AppWnds[Index: Integer]: HWND read GetAppWnds;
[ShortDescr]
Returns the HWND of a specific application index.
[Description]
Use the AppWnds property to determine the handle of the invisible window created
by one of the application instances. Index is zero based and determines for
which application instance a handle is returned. It can be at
most <REF>InstanceCount</REF> - 1 and selects one of the application instances
from the <REF>ProcessIDs</REF> property.
[Quick Info]
Kind=Property
Visibility=Public
Unit=JclAppInst
Category=Libraries, Processes and Threads
SubCat=TJclAppInstances
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5,6
Kylix=1
FPC=1.x
[SeeAlso]
Count=2
1=InstanceCount
2=ProcessIDs
<DECL>--------------------------------------------------------------------------
[Declaration]
property InstanceIndex[ProcessID: DWORD]: Integer read GetInstanceIndex;
[ShortDescr]
Returns the index into the ProcessIDs array for a process. 
[Description]
Read the InstanceIndex property to determine the zero based index into the
ProcessIDs array property of a specific application instance. The array index is
the process ID of the application instance for which you want to know the index.
Upon failure the property reads -1.
[Quick Info]
Kind=Property
Visibility=Public
Unit=JclAppInst
Category=Libraries, Processes and Threads
SubCat=TJclAppInstances
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5,6
Kylix=1
FPC=1.x
[SeeAlso]
Count=1
1=ProcessIDs
<DECL>--------------------------------------------------------------------------
[Declaration]
property InstanceCount: Integer read GetInstanceCount;
[ShortDescr]
Returns the number of application instances.
[Description]
The InstanceCount property returns the number of application instances that
registered with the TJclAppInstances. Among others you can use this to determine
the highest valid index into the <REF>ProcessIDs</REF> array property.
[Quick Info]
Kind=Property
Visibility=Public
Unit=JclAppInst
Category=Libraries, Processes and Threads
SubCat=TJclAppInstances
Author=Petr Vones;petr.v@mujmail.cz
Delphi=4,5,6
Kylix=1
FPC=1.x
[SeeAlso]
Count=2
1=ProcessIDs
2=AppWnds
