## Help groups that do not belong to a specific documentation file.
--------------------------------------------------------------------------------
@@JCL
<title JEDI Code Library>

The JEDI Code Library (JCL) consists of a set of utility
functions and non-visual classes which can be instantly
reused in your Delphi and C++ Builder projects.

The library is built upon code donated from the JEDI
community. It is reformatted to achieve a common
look-and-feel, tested, documented and merged into the
library. The library is grouped into several categories (see
below). The library is released to the public under the terms
\of the Mozilla Public License (MPL) and as such can be
freely used in both freeware/shareware, opensource and
commercial projects.

The entire JEDI Code Library is distributed under the terms
\of the Mozilla Public License (MPL). This includes, but is
not limited to, this document and all source code and
ancillary files. Source code files included in the JCL have a
header which explicitly states this (as is required) however,
unless noted otherwise, all files including those without an
MPL header, are subject to the MPL license.

For more information visit our http://jcl.delphi-jedi.org/
homepage.


Note
This documentation has been created using Doc-O-Matic
Professional 5.0.2. Many thanks to
http://www.toolsfactory.com/ toolsfactory for generously
granting free licenses to the JEDI team!

@@Algorithms
<GROUP JCL>
<TITLE Algorithms>
<TOPICORDER 100>
--------------------------------------------------------------------------------
@@Algorithms.Searching
<GROUP Algorithms>
<TITLE Searching>
<TOPICORDER 100>
--------------------------------------------------------------------------------
@@Algorithms.Sorting
<GROUP Algorithms>
<TITLE Sorting>
<TOPICORDER 200>
--------------------------------------------------------------------------------
@@Containers
<GROUP JCL>
<TITLE Containers>
<TOPICORDER 300>
--------------------------------------------------------------------------------
@@Containers.Interfaces
<GROUP Containers>
<TITLE Container interfaces>
<TOPICORDER 100>
--------------------------------------------------------------------------------
@@Containers.Sequence
<GROUP Containers>
<TITLE Sequence containers>
<TOPICORDER 200>
These containers hold sequences of data elements.
--------------------------------------------------------------------------------
@@Containers.Sequence.Vectors
<GROUP Containers.Sequence>
<TITLE Vectors>
<TOPICORDER 100>
Vectors provide a dynamic array structure with fast random access to any element.
Inserting and deleting elements at the end is fast. Can do subscript bounds checking.
--------------------------------------------------------------------------------
@@Containers.Sequence.LinkedLists
<GROUP Containers.Sequence>
<TITLE Linked Lists>
<TOPICORDER 200>
Doubly linked list. There is no random access to the elements.
Insertion and deletion anywhere is fast.
--------------------------------------------------------------------------------
@@Containers.Associative
<GROUP Containers>
<TITLE Associative containers>
<TOPICORDER 300>
Associative containers contain key/value pairs, providing access to each value
using a key. The elements are sorted by the key. Usually implemented as a
balanced binary tree.
--------------------------------------------------------------------------------
@@Containers.Associative.Maps
<GROUP Containers.Associative>
<TITLE Maps>
<TOPICORDER 100>
Maps provide access to elements using any type of key. This is a generalization
of the idea of accessing a vector with an integer subscript.
--------------------------------------------------------------------------------
@@Containers.Associative.Multimaps
<GROUP Containers.Associative>
<TITLE Multimaps>
<TOPICORDER 200>
Multimaps are maps which allow a key to map into more than one element.
--------------------------------------------------------------------------------
@@Containers.OrderedSets
<GROUP Containers>
<TITLE Ordered sets>
<TOPICORDER 400>
The set containers keep the elements in them in order, and are usually
implemented as balanced binary trees. They implement standard set
operations (union, intersection, ...) as you might expect from the name.
--------------------------------------------------------------------------------
@@Containers.Adapters
<GROUP Containers>
<TITLE Container adapters>
<TOPICORDER 500>
These are based on other containers, and are used only to enforce access rules.
Because there are special access restrictions, they have no iterators.
--------------------------------------------------------------------------------
@@Containers.Adapters.Stacks
<GROUP Containers.Adapters>
<TITLE Stacks>
<TOPICORDER 100>
Stacks allow only LIFO (Last In, First Out) access.
--------------------------------------------------------------------------------
@@Containers.Adapters.Queues
<GROUP Containers.Adapters>
<TITLE Queues>
<TOPICORDER 200>
Queues allow only FIFO (First In, First Out) access.
--------------------------------------------------------------------------------
@@Containers.Specialized
<GROUP Containers>
<TITLE Specialized containers>
<TOPICORDER 600>
The following containers are specialized in some ways: specific data type,
special utility routines, limited, but fast, implementations.
--------------------------------------------------------------------------------
@@Containers.Specialized.Arrays
<GROUP Containers.Specialized>
<TITLE Arrays>
<TOPICORDER 100>
valarray is an especially efficient implementation of arrays, but it doesn't
have all the standard container behavior.
--------------------------------------------------------------------------------
@@BaseServices
<GROUP JCL>
<TITLE Base Services>
<TOPICORDER 200>
--------------------------------------------------------------------------------
@@DateandTime
<GROUP JCL>
<TITLE Date and Time>
<TOPICORDER 400>
--------------------------------------------------------------------------------
@@Debugging
<GROUP JCL>
<TITLE Debugging>
<TOPICORDER 500>
--------------------------------------------------------------------------------

@@ExprEval
<GROUP JCL>
<TITLE Expression Evaluation>
<TOPICORDER 700>
--------------------------------------------------------------------------------
@@FilesandIO
<GROUP JCL>
<TITLE Files and IO>
<TOPICORDER 800>
--------------------------------------------------------------------------------
@@Graphics
<GROUP JCL>
<TITLE Graphics>
<TOPICORDER 900>
--------------------------------------------------------------------------------
@@Internationalisation
<GROUP JCL>
<TITLE Internationalisation>
<TOPICORDER 1000>
--------------------------------------------------------------------------------
@@InternetandE-mail
<GROUP JCL>
<TITLE Internet and E-mail>
<TOPICORDER 1100>
--------------------------------------------------------------------------------
@@LibrariesProcessesandThreads
<GROUP JCL>
<TITLE Libraries\, Processes and Threads>
<TOPICORDER 1300>
--------------------------------------------------------------------------------
@@MathRoutines
<GROUP JCL>
<TITLE Math Routines>
<TOPICORDER 1400>
--------------------------------------------------------------------------------
@@MemoryClassesandObjects
<GROUP JCL>
<TITLE Memory\, Classes and Objects>
<TOPICORDER 1500>
--------------------------------------------------------------------------------
@@MIME
<GROUP JCL>
<TITLE MIME>
<TOPICORDER 1600>
--------------------------------------------------------------------------------
@@Miscellaneous
<GROUP JCL>
<TITLE Miscellaneous>
<TOPICORDER 1700>
--------------------------------------------------------------------------------
@@MultiMedia
<GROUP JCL>
<TITLE MultiMedia>
<TOPICORDER 1800>
--------------------------------------------------------------------------------
@@BaseServices.Notifications
<GROUP BaseServices>
<TITLE Notifier/listener pattern>
<TOPICORDER 1850>
The notifier/listener pattern allows for both generalizing the sending of
notifications to multiple interested parties (listeners) and ease of adding new
ways of processing notifications without needing to change any code.

An example of this pattern can be found in .NET, where one can find a
Trace class and a number of derived TraceListener classes. Using that example,
the Trace class is an IJclNotifier implementer and the TraceListener an
IJclListener interface. However, the .NET Trace and TraceListener setup is a
specific implementation and doesn't need an IJclNotificationMessage implementer;
the Trace class simply calls specific methods of the TraceListener. The JEDI
Code Library provides a more generic approach to this pattern.

* Notifiers *
A notifier (any class implementing IJclNotifier) has only two distinct tasks:

* Managing a list of listeners (IJclListener implementing classes)
* Notify all registered listeners

The first task is generally performed before a certain process within an
application is started or after it has finished.

The second task is performed by the class or methods that are part of a process.
At any moment a message (IJclNotificationMessage implementing class) can be
constructed and passed on to the Notification method.

* Listeners *
A listener (any class implementing IJclListener) has a single method that will
be called by a notifier whenever its notify method is called. The method will
specify the message that was passed to the notifier's notify method. A listener
can check incoming notifications for additional or derived interface(s) and
either process the notification or ignore it based on those interface(s).

During processing the additional or derived interface(s) may provide additional
information regarding the nature of the notification.

* Notification messages *
A notification message (any class implementing IJclNotificationMessage) is just
place holder. Normally, one would either create a derived interface or add
additional interfaces to the message implementation class, adding such
information as context or other data that may be of interest to listeners.

* Setting up a notifier/listener pattern *
In general setting up a specific notification sub system involves the steps as
outlined below. It's not unthinkable that for certain situations you'll need
additional steps or may skip steps.

1 create a notifier
    The JEDI Code Library simplifies this task: create an instance of
    TJclBaseNotifier and you're good to go in most cases. Assign the instance
    to a variable declared as IJclNotifier, so that you can use the notifier
    (the class itself declares the methods protected since it is assumed they
    will be used through the interface reference at all times).

2 create notification messages
    Notification messages describe to the listener what has happened. If all you
    need is a simple notification a proces has finished, you could suffice with
    TJclBaseNotificationMessage. In most cases, however, you will need to
    declare additional interfaces (use Ctrl+Shift+G to create a GUID). These
    interfaces can have additional properties and/or functions to provide data
    to the listener, but a message supporting a certain interface could be all
    the information you'd need. Then you'll need to create one or more classes
    that will implement these interfaces (in whatever combination you need).

3 create a listener
    In most cases you could simply derive a class from TJclBaseListener.
    Alternatively you could create a new class to implement the IJclListener
    interface, or - in case of a VCL application - have your MainForm implement
    the interface. The interface has only one method and it will be passed an
    IJclNotificationMessage instance.
--------------------------------------------------------------------------------
@@OrdinalMathandLogic
<GROUP JCL>
<TITLE Ordinal Math and Logic>
<TOPICORDER 1900>
--------------------------------------------------------------------------------
@@RegistryandInifiles
<GROUP JCL>
<TITLE Registry and Ini files>
<TOPICORDER 2000>
--------------------------------------------------------------------------------
@@RuntimeTypeInformation
<GROUP JCL>
<TITLE Runtime Type Information>
<TOPICORDER 2100>
--------------------------------------------------------------------------------
@@StringManipulation
<GROUP JCL>
<TITLE String Manipulation>
<TOPICORDER 2400>
--------------------------------------------------------------------------------
@@SystemInformationRoutines
<GROUP JCL>
<TITLE System Information Routines>
<TOPICORDER 2500>
--------------------------------------------------------------------------------
@@Unicode
<GROUP JCL>
<TITLE Unicode>
<TOPICORDER 2600>
--------------------------------------------------------------------------------
@@UnitConversions
<GROUP JCL>
<TITLE Unit Conversions>
<TOPICORDER 2700>
--------------------------------------------------------------------------------
@@Windows_Specific
<GROUP JCL>
<TITLE Windows Specific>
<TOPICORDER 2800>
--------------------------------------------------------------------------------
@@JclCounter.pas
Summary:
  This unit contains a high performance counter class which can be used for highly
  accurate timing
--------------------------------------------------------------------------------
@@JclDateTime.pas
Summary:
  Routines for working with dates and times. Mostly conversion between the
  different formats but also some date testing routines (is leap year? etc)
Contributors:
  Anthony Steele
  Charlie Calvert
  Heri Bender
  Marc Convents
  Marcel van Brakel
  Matthias Thoma
  Michael Schnell
  Nick Hodges
  Anonymous
  Petr Vones
  Robert Marquardt
  Robert Rossmair
--------------------------------------------------------------------------------
@@JclDebug.pas
Summary:
 Various debugging support routines and classes. This includes: Diagnostics
 routines, Trace routines, Stack tracing and Source Locations a la the C/C++
 __FILE__ and __LINE__ macros.
Contributors:
  Marcel van Brakel
  Flier Lu
  Robert Marquardt
  Robert Rossmair
  Petr Vones
--------------------------------------------------------------------------------
@@JclFileUtils.pas
Description:
  This unit contains routines and classes for working with
  files, directories and path strings. Additionally it contains
  wrapper classes for file mapping objects and version
  resources.

  Generically speaking, everything that has to do with files
  and directories. Note that filesystem specific functionality
  has been extracted into external units, for example JclNTFS.pas
  which contains NTFS specific utility routines, and that the JclShell.pas
  unit contains some file related routines as well but they
  are specific to the Windows shell.
--------------------------------------------------------------------------------
@@JclGraphics.pas
Description:
  The resampling algorithms and methods used in this library
  were adapted by Anders Melander from the article "General
  Filtered Image Rescaling" by Dale Schumacher which appeared
  in the book Graphics Gems III, published by Academic Press, Inc.
  Additional improvements were done by David Ullrich,
  Josha Beukema and Mike Lischke.
--------------------------------------------------------------------------------
@@JclMidi.pas
<GROUP MultiMedia.MIDI>
Summary:
  Unit JclMIDI supplies platform-independent MIDI declarations.
--------------------------------------------------------------------------------
@@JclNTFS.pas
Summary:
  Contains routines to perform filesystem related tasks available only with NTFS.
  These are mostly relatively straightforward wrappers for various IOCTs related
  to compression, sparse files, reparse points, volume mount points and so forth.
Notes:
  Note that some functions require NTFS 5 or higher!
--------------------------------------------------------------------------------
@@JclRegistry.pas
Summary:
  Unit JclRegistry contains useful routines for registry
  manipulation in addition to standard routines provided by
  several Delphi classes.
Description:
  Contains various utility routines to read and write registry values. Using these routines
  prevents you from having to instantiate temporary TRegistry objects and since the routines
  directly call the registry API they do not suffer from the resource overhead as TRegistry does.
Donators:
  John C Molyneux
  Marcel van Brakel
  Charlie Calvert
Contributors:
  Marcel van Brakel
  Stephane Fillon
  Eric S. Fisher
  Peter Friese
  Anonymous
  Andreas Hausladen
  Manlio Laschena
  Robert Marquardt
  Robert Rossmair
  Olivier Sannier
  Petr Vones
--------------------------------------------------------------------------------
@@JclStrings.pas
Summary:
  The module JclStrings contains routines for strings
  manipulation, conversion and transformation.
--------------------------------------------------------------------------------
@@JclSvcCtrl.pas
Summary:
  This unit contains routines and classes to control Windows NT services
--------------------------------------------------------------------------------
@@RegularExpressions
  TODO
--------------------------------------------------------------------------------
@@IncludedFiles
<title Included files and configuration>

\TODO

@@UnitVersioning
  TODO
--------------------------------------------------------------------------------
@@Streams
  TODO


@@String bases
\ \ 

@@64-bit support
\ \ 

@@Generics
\ \ 

@@Version numbers
\ \ 

@@Dynamic arrays
\ \ 

@@Containers.files
<title Container files>

\ \ 

@@Containers.functions
<title Container functions>

\ \ 

@@Containers.exceptions
<title Container exceptions>

\ \ 

@@Containres.Interfaces.Maps
<title Maps>

\ \ 
