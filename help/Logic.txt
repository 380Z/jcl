<DECL>--------------------------------------------------------------------------
[Declaration]
procedure BooleansToBits(var Dest: Byte; const B: array of Boolean); overload;
procedure BooleansToBits(var Dest: Word; const B: array of Boolean); overload;
procedure BooleansToBits(var Dest: Integer; const B: array of Boolean); overload;
procedure BooleansToBits(var Dest: Cardinal; const B: array of Boolean); overload;
procedure BooleansToBits(var Dest: Int64; const B: array of Boolean); overload;
[ShortDescr]
Packs an array of booleans into a set of bits.
[Description]
BooleansToBits packs the array of booleans into a set of bits. Each boolean in
the array which is set to True results in a 1 bit in the Dest variable while
each False valued boolean results in a 0 bit. The <REF>BitsToBooleans</REF>
routine performs the inverse operation.
[Parameters]
Count=2
1=Dest:Integer=Integer type variable in which the appropriate bits are set/cleared.
2=B:array of Boolean=The array of Booleans to pack into a set of bits. Note that
the upper bound of this array must not be larger then the size of the Dest parameters,
in bits. Thus, for the Byte variant this array must not be larger then 8 elements.
[Quick Info]
BCB=4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Bit Manipulation
Author=Robert Marquardt;robert_marquardt@gmx.de
Delphi=3,4,5
[SeeAlso]
Count=1
1=BitsToBooleans
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure BitsToBooleans(const Bits: Byte; B: TBooleanArray); overload;
procedure BitsToBooleans(const Bits: Word; B: TBooleanArray); overload;
procedure BitsToBooleans(const Bits: Integer; B: TBooleanArray); overload;
procedure BitsToBooleans(const Bits: Cardinal; B: TBooleanArray); overload;
procedure BitsToBooleans(const Bits: Int64; B: TBooleanArray); overload;
[ShortDescr]
Unpacks a set of bits into an array of booleans.
[Description]
BitsToBooleans unpacks a set of bits into an array of booleans. Each set bit in
the Bits parameter results in a True valued boolean while each cleared bit
results in a False valued boolean. The resulting array has one element for each
bit in the Bits parameter where bit 0 corresponds to B[0], bit 1 to B[1] etc.
See also <REF>BooleansToBits</REF> for the inverse operation.
[Parameters]
Count=2
1=Bits:Integer=The set of bits to unpack to an array of Booleans.
2=B:TBooleanArray=Array which receives the bits in Bits unpacked as Booleans.
[Quick Info]
BCB=4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Bit Manipulation
Author=Robert Marquardt;robert_marquardt@gmx.de
Delphi=3,4,5
[SeeAlso]
Count=1
1=BooleansToBits
<DECL>--------------------------------------------------------------------------
[Declaration]
function CountBitsCleared(X: Cardinal): Integer; overload;
function CountBitsCleared(X: Int64): Integer; overload;
function CountBitsCleared(X: Integer): Integer; overload;
function CountBitsCleared(X: Byte): Integer; overload;
function CountBitsCleared(X: Word): Integer; overload;
[ShortDescr]
Returns the number of 0 bits in the passed value.
[Description]
CountBitsCleared returns the number of bits that are cleared (value 0) in the binary
representation of the passed in Value. Note that signed integers are stored in two's
complement form.
[Parameters]
Count=1
1=X:Integer=The value for which to determine the number of bits that are cleared.
This can be an Integer, Cardinal, Byte, Word or Int64.
[Result]
The number of cleared bits or -1 if no bits are cleared.
[Quick Info]
BCB=4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Bit Manipulation
Author=Robert Marquardt;robert_marquardt@gmx.de
Delphi=3,4,5
[SeeAlso]
Count=2
1=BitsLowest
2=BitsHighest
3=CountBitsSet
<DECL>--------------------------------------------------------------------------
[Declaration]
function CountBitsSet(X: Cardinal): Integer; assembler; overload;
function CountBitsSet(X: Int64): Integer; overload;
function CountBitsSet(X: Integer): Integer; overload;
function CountBitsSet(X: Byte): Integer; overload;
function CountBitsSet(X: Word): Integer; overload;
[ShortDescr]
Returns the number of 1 bits in the passed value.
[Description]
CountBitsSet returns the number of bits that are set (value 1) in the binary
representation of the passed in Value. For example, CountBitsSet(1) returns 1,
CountBitsSet(3) returns 2 etc. Note that signed integers are stored in two's
complement form and therefore, for example, CountBitsSet(-1) will return 32.
[Parameters]
Count=1
1=X:Integer=The value for which to determine the number of bits that are set. This
can be an Integer, Cardinal, Byte, Word or Int64.
[Result]
The number of set bits or -1 if no bits are set.
[Quick Info]
BCB=4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Bit Manipulation
Author=Michael Schnell;Michael.Schnell@MARIANNE.gihub.de
Delphi=3,4,5
[SeeAlso]
Count=2
1=BitsLowest
2=BitsHighest
<DECL>--------------------------------------------------------------------------
[Declaration]
function BitsHighest(X: Cardinal): Integer; overload;
function BitsHighest(X: Int64): Integer; overload;
function BitsHighest(X: Integer): Integer; overload;
function BitsHighest(X: Byte): Integer; overload;
function BitsHighest(X: Word): Integer; overload;
[ShortDescr]
Returns the highest bit set in the passed in value.
[Description]
BitsHighest returns the number of the highest bit which is set in the passed in
value. Note that bits are numbered right to left starting with 0. For example,
BitsHighest(5) returns 2 (5 is 00000101 in binary).
[Parameters]
Count=1
1=X:Integer=The value to test.
[Result]
The number of the highest bit set, or -1 if no bits are set.
[Quick Info]
BCB=4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Bit Manipulation
Author=Michael Schnell;Michael.Schnell@MARIANNE.gihub.de
Delphi=3,4,5
[SeeAlso]
Count=2
1=BitsLowest
2=CountBitsSet
<DECL>--------------------------------------------------------------------------
[Declaration]
function BitsLowest(X: Cardinal): Integer; overload;
function BitsLowest(X: Int64): Integer; overload;
function BitsLowest(X: Integer): Integer; overload;
function BitsLowest(X: Word): Integer; overload;
function BitsLowest(X: Byte): Integer; overload;
[ShortDescr]
Returns the lowest bit set in the passed in value.
[Description]
BitsLowest returns the number of the lowest bit which is set in the passed in
value. Note that bits are numbered right to left starting with 0. For example,
BitsLowest(9) returns 2 (9 is 00001100 in binary).
[Parameters]
Count=1
1=X:Integer=The value to test.
[Result]
The number of the lowest bit set, or -1 if no bits are set.
[Quick Info]
BCB=4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Bit Manipulation
Author=Michael Schnell;Michael.Schnell@MARIANNE.gihub.de
Delphi=3,4,5
[SeeAlso]
Count=2
1=BitsHighest
2=CountBitsSet
<DECL>--------------------------------------------------------------------------
[Declaration]
function Digits(const X: Cardinal): Integer;
[ShortDescr]
Returns the number of digits in a given positive integer.
[Description]
Returns the number of digits in a given positive integer.
[Parameters]
Count=1
1=X:Cardinal=The value for which you want to know how many digits it has.
[Result]
The number of digits in the specified value.
[Quick Info]
BCB=3,4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Bit Manipulation
Author=ESB Consultancy;glenn@esbconsult.com.au
Delphi=3,4,5
[SeeAlso]
Count=1
1=BitsNeeded
<DECL>--------------------------------------------------------------------------
[Declaration]
function BitsNeeded(const X: Byte): Integer; overload;
function BitsNeeded(const X: Word): Integer; overload;
function BitsNeeded(const X: Integer): Integer; overload;
function BitsNeeded(const X: Cardinal): Integer; overload;
function BitsNeeded(const X: Int64): Integer; overload;
[ShortDescr]
Returns the number of Bits needed to represent a given positive integer.
[Description]
Returns the number of Bits needed to represent a given positive integer.
[Parameters]
Count=1
1=X:Cardinal=The value for which you want to now how many bits are needed to represent it.
[Result]
The number of bits needed to represent the value.
[Quick Info]
BCB=3,4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Bit Manipulation
Author=ESB Consultancy;glenn@esbconsult.com.au
Delphi=3,4,5
[SeeAlso]
Count=1
1=Digits
<DECL>--------------------------------------------------------------------------
[Declaration]
function Max(const B1, B2: Byte): Byte; overload;
function Max(const B1, B2: Shortint): Shortint; overload;
function Max(const B1, B2: Word): Word; overload;
function Max(const B1, B2: Integer): Integer; overload;
function Max(const B1, B2: Cardinal): Cardinal; overload;
function Max(const B1, B2: Int64): Int64; overload;
[ShortDescr]
Returns the larger of two values.
[Description]
Max returns the larger of the two passed values.
[Parameters]
Count=2
1=B1:IntegerType=The first value.
2=B2:IntegerType=The second value.
[Result]
The larger of the two values.
[Quick Info]
BCB=3,4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Arithmetic
Author=ESB Consultancy;glenn@esbconsult.com.au
Delphi=3,4,5
[SeeAlso]
Count=1
1=Min
<DECL>--------------------------------------------------------------------------
[Declaration]
function Min(const B1, B2: Byte): Byte; overload;
function Min(const B1, B2: Shortint): Shortint; overload;
function Min(const B1, B2: Word): Word; overload;
function Min(const B1, B2: Integer): Integer; overload;
function Min(const B1, B2: Cardinal): Cardinal; overload;
function Min(const B1, B2: Int64): Int64; overload;
[ShortDescr]
Returns the smaller of two values.
[Description]
Min returns the smaller of the two passed values.
[Parameters]
Count=2
1=B1:IntegerType=The first value.
2=B2:IntegerType=The second value.
[Result]
The smaller of the two values.
[Quick Info]
BCB=3,4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Arithmetic
Author=ESB Consultancy;glenn@esbconsult.com.au
Delphi=3,4,5
[SeeAlso]
Count=1
1=Max
<DECL>--------------------------------------------------------------------------
[Declaration]
function DecLimit(var B: Byte; const Limit: Byte; const Decr: Byte = 1): Byte; overload;
function DecLimit(var B: ShortInt; const Limit: Shortint; const Decr: ShortInt = 1): Shortint; overload;
function DecLimit(var B: Word; const Limit: Word; const Decr: Word = 1): Word; overload;
function DecLimit(var B: Integer; const Limit: Integer; const Decr: Integer = 1): Integer; overload;
function DecLimit(var B: Cardinal; const Limit: Cardinal; const Decr: Cardinal = 1): Cardinal; overload;
function DecLimit(var B: Int64; const Limit: Int64; const Decr: Int64 = 1): Int64; overload;
[ShortDescr]
Decrements an ordinal up to limit.
[Description]
DecLimit decrements the specified ordinal variable by the specified value if and
only if the operation will not decrement beyond the limit. For example, suppose
that X equals 10, now calling DecLimit(X, 5, 2) will decrement X by 2 leaving it
with 8 on return. However, calling DecLimit(X, 5, 6) will not decrement X by 6
because that would decrement X beyond the limit. On return X still contains 10.
[Parameters]
Count=3
1=B:IntegerType=The value to conditionally decrement.
2=Limit:IntegerType=The decrementation limit, this is inclusive.
3=Decr:IntegerType=The amount to decrement.
[Result]
B contains the decremented value if within limit, otherwise it contains the original value.
This same valus is returned as the function result.
[Quick Info]
BCB=3,4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Arithmetic
Author=ESB Consultancy;glenn@esbconsult.com.au
Delphi=3,4,5
[SeeAlso]
Count=3
1=IncLimit
2=IncLimitClamp
3=DecLimitClamp
<DECL>--------------------------------------------------------------------------
[Declaration]
function IncLimit(var B: Byte; const Limit: Byte; const Incr: Byte = 1): Byte; overload;
function IncLimit(var B: Shortint; const Limit: Shortint; const Incr: Shortint = 1): Shortint; overload;
function IncLimit(var B: Word; const Limit: Word; const Incr: Word = 1): Word; overload;
function IncLimit(var B: Integer; const Limit: Integer; const Incr: Integer = 1): Integer; overload;
function IncLimit(var B: Cardinal; const Limit: Cardinal; const Incr: Cardinal = 1): Cardinal; overload;
function IncLimit(var B: Int64; const Limit: Int64; const Incr: Int64 = 1): Int64; overload;
[ShortDescr]
Increments an ordinal up to limit.
[Description]
IncLimit increments the specified ordinal variable by the specified value if and
only if the operation will not increment beyond the limit. For example, suppose
that X equals 5, now calling IncLimit(X, 10, 2) will increment X by 2 leaving it
with 7 on return. However, calling IncLimit(X, 10, 6) will not increment X by 6
because that would increment X beyond the limit. On return X still contains 5.
[Parameters]
Count=3
1=B:IntegerType=The value to conditionally increment.
2=Limit:IntegerType=The incrementation limit.
3=Incr:IntegerType=The amount to increment.
[Result]
B contains the incremented value if within limit, otherwise it contains the original value.
This same value is returned as the function result.
[Quick Info]
BCB=3,4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Arithmetic
Author=ESB Consultancy;glenn@esbconsult.com.au
Delphi=3,4,5
[SeeAlso]
Count=3
1=DecLimit
2=DecLimitClamp
3=IncLimitClamp
<DECL>--------------------------------------------------------------------------
[Declaration]
function DecLimitClamp(var B: Byte; const Limit: Byte; const Decr: Byte = 1): Byte; overload;
function DecLimitClamp(var B: ShortInt; const Limit: Shortint; const Decr: ShortInt = 1): Shortint; overload;
function DecLimitClamp(var B: Word; const Limit: Word; const Decr: Word = 1): Word; overload;
function DecLimitClamp(var B: Integer; const Limit: Integer; const Decr: Integer = 1): Integer; overload;
function DecLimitClamp(var B: Cardinal; const Limit: Cardinal; const Decr: Cardinal = 1): Cardinal; overload;
function DecLimitClamp(var B: Int64; const Limit: Int64; const Decr: Int64 = 1): Int64; overload;
[ShortDescr]
Decrements an ordinal up to limit.
[Description]
DecLimitClamp decrements the specified ordinal variable by the specified value. If
this decrement would decreate the value beyond the specified limit, the variable is
clamped to the limit. For example, suppose
that X equals 10, now calling DecLimitClamp(X, 5, 2) will decrement X by 2 leaving it
with 8 on return. However, calling DecLimitClamp(X, 5, 6) will not decrement X by 6
because that would decrement X beyond the limit. X is set to 5 (the limit) instead.
[Parameters]
Count=3
1=B:IntegerType=The value to conditionally decrement.
2=Limit:IntegerType=The decrementation limit, this is inclusive.
3=Decr:IntegerType=The amount to decrement.
[Result]
B contains the decremented value if within limit, otherwise it is set to the limit
value. This same value is returned as the function result.
[Notes]
Count=1
1=If upon entry the B variable is already smaller than the limit the variable is
set to Limit.
[Quick Info]
BCB=3,4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Arithmetic
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
[SeeAlso]
Count=3
1=IncLimit
2=DecLimit
3=IncLimitClamp
<DECL>--------------------------------------------------------------------------
[Declaration]
function IncLimitClamp(var B: Byte; const Limit: Byte; const Incr: Byte = 1): Byte; overload;
function IncLimitClamp(var B: Shortint; const Limit: Shortint; const Incr: Shortint = 1): Shortint; overload;
function IncLimitClamp(var B: Word; const Limit: Word; const Incr: Word = 1): Word; overload;
function IncLimitClamp(var B: Integer; const Limit: Integer; const Incr: Integer = 1): Integer; overload;
function IncLimitClamp(var B: Cardinal; const Limit: Cardinal; const Incr: Cardinal = 1): Cardinal; overload;
function IncLimitClamp(var B: Int64; const Limit: Int64; const Incr: Int64 = 1): Int64; overload;
[ShortDescr]
Increments an ordinal up to limit.
[Description]
IncLimitClamp increments the specified ordinal variable by the specified value. If
this increment would increase the value beyond the specified limit, the variable is
clamped to the limit. For example, suppose
that X equals 5, now calling IncLimitClamp(X, 10, 2) will increment X by 2 leaving it
with 7 on return. However, calling IncLimitClamp(X, 10, 6) will not increment X by 6
because that would increment X beyond the limit. X is set to 10 (the limit) instead.
[Parameters]
Count=3
1=B:IntegerType=The value to conditionally increment.
2=Limit:IntegerType=The incrementation limit.
3=Incr:IntegerType=The amount to increment.
[Result]
B contains the incremented value if within limit, otherwise it is set to the limit
value. This same value is returned as the function result.
[Notes]
Count=1
1=If upon entry the B variable is already larger than the limit the variable is
set to Limit.
[Quick Info]
BCB=3,4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Arithmetic
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
[SeeAlso]
Count=3
1=DecLimit
2=IncLimit
3=DecLimitClamp
<DECL>--------------------------------------------------------------------------
[Declaration]
function ReverseBits(const Value: Byte): Byte; overload;
function ReverseBits(const Value: Word): Word; overload;
function ReverseBits(const Value: Integer): Integer; overload;
function ReverseBits(const Value: Int64): Int64; overload;
function ReverseBits(P: Pointer; Count: Integer): Pointer; overload;
[ShortDescr]
Reverses the bits of Value.
[Description]
ReverseBits reverses the bits in the passed parameter. That is, assuming a byte,
bit 0 is swapped with bit 7, bit 1 is swapped with bit 6 and so on. This function
exist in 4 forms, one for each Integer type. The last overload is a generalisation
of this which reverse the bits in the past in buffer, <i>for each byte individually<i>.
[Parameters]
Count=3
1=Value:IntegerType=The integer type whose bits to reverse.
2=P:Pointer=Address of a buffer whose bits to reverse.
3=Count:Integer=Size of the buffer, in bytes, specified by P.
[Result]
Copy of Value with it's bits reversed.
[Notes]
Count=1
1=Reversing is not the same as toggling. To toggle bits use the <REF>ToggleBit</REF> function.
[Quick Info]
BCB=3,4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Bit Manipulation
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function OrdToBinary(const Value: Byte): string; overload;
function OrdToBinary(const Value: Word): string; overload;
function OrdToBinary(const Value: Integer): string; overload;
function OrdToBinary(const Value: Cardinal): string; overload;
function OrdToBinary(const Value: Int64): string; overload;
[ShortDescr]
Returns the supplied value in it's binary form.
[Description]
OrdToBinary returns a string representation of the specified Value in it's
binary form, that is: ones and zeros. The resulting string length is always
equal to the number of bits in the supplied value (leading 0's aren't stripped).
[Parameters]
Count=1
1=Value:IntegerType=The value whose binary string you want.
[Result]
Binary string representation of the supplied value.
[Quick Info]
BCB=3,4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Conversion
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure SwapOrd(var I, J: Byte); overload;
procedure SwapOrd(var I, J: Cardinal); overload;
procedure SwapOrd(var I, J: Integer); overload;
procedure SwapOrd(var I, J: Int64); overload;
procedure SwapOrd(var I, J: Shortint); overload;
procedure SwapOrd(var I, J: Smallint); overload;
procedure SwapOrd(var I, J: Word); overload;
[ShortDescr]
Swaps two integer-typed variables.
[Description]
The Swap function swaps the two supplied arguments. When the function returns
I has the value of J and J has the value of I. This function exist in 7 forms,
one for each Integer type. A function to swap floating point values exist as well
in the JclMath unit, see <REF Target"..\Math\Float support\SwapFloat">SwapFloat</REF>.
[Parameters]
Count=2
1=I:IntegerType=First of the two variables to swap.
2=J:IntegerType=Second of the two variables to swap.
[Result]
At the end of this routine I will contain the original value of J and J will contain the original value of I.
[Quick Info]
BCB=3,4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Arithmetic
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function RRot(const Value: Byte; const Count: TBitRange): Byte; overload;
function RRot(const Value: Word; const Count: TBitRange): Word; overload;
function RRot(const Value: Integer; const Count: TBitRange): Integer; overload;
[ShortDescr]
Right rotates bits.
[Description]
RRot shifts the bits in Value the specified Count number of times to the right.
On each shift the bit in the lowest bit position wraps around into the highest.
This function exist in 3 forms, one for each Integer type.
[Parameters]
Count=2
1=Value:TIntegerType=The Value whose bits to rotate.
2=Mask:TIntegerType=The number of times to rotate.
[Result]
The resulting integer after the rotate is performed.
[Quick Info]
BCB=3,4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Bit Manipulation
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
[SeeAlso]
Count=1
1=LRot
<DECL>--------------------------------------------------------------------------
[Declaration]
function Sar(const Value: Shortint; const Count: TBitRange): Shortint; overload;
function Sar(const Value: Smallint; const Count: TBitRange): Smallint; overload;
function Sar(const Value: Integer; const Count: TBitRange): Integer; overload;
[ShortDescr]
Performs an arithmetic right shift.
[Description]
Sar performs an arithmetic right shift on the operand. An arithmetic right shift
is similar to a logical right shift (shr) except that shr operates on unsigned
values while Sar operates on signed values (and as such preserves the sign).
[Parameters]
Count=2
1=Value:TIntegerType=The Value whose bits to arithmetically shift.
2=Count:TBitRange=Number of positions to right shift.
[Result]
A copy of value after the arithmetic right shift operation.
[Quick Info]
BCB=3,4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Bit Manipulation
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function LRot(const Value: Byte; const Count: TBitRange): Byte; overload;
function LRot(const Value: Word; const Count: TBitRange): Word; overload;
function LRot(const Value: Integer; const Count: TBitRange): Integer; overload;
[ShortDescr]
Left rotates bits.
[Description]
LRot shifts the bits in Value the specified Count number of times to the left.
On each shift the bit in the highest bit position wraps around into the first.
This function exist in 3 forms, one for each Integer type.
[Parameters]
Count=2
1=Value:TIntegerType=The Value whose bits to rotate.
2=Mask:TIntegerType=The number of times to rotate.
[Result]
The resulting integer after the rotate is performed.
[Quick Info]
BCB=3,4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Bit Manipulation
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
[SeeAlso]
Count=1
1=RRot
<DECL>--------------------------------------------------------------------------
[Declaration]
function TestBits(const Value, Mask: Byte): Boolean; overload;
function TestBits(const Value, Mask: Word): Boolean; overload;
function TestBits(const Value, Mask: Integer): Boolean; overload;
function TestBits(const Value, Mask: Int64): Boolean; overload;
[ShortDescr]
Test multiple bits.
[Description]
TestBits performs a bitwise and operation on Value and Mask. This in effect tests
whether all bits that are set in Mask are also set in Value. This function
exists in 4 different forms, one for each integer type.
[Parameters]
Count=2
1=Value:TIntegerType=The Value whose bits to test.
2=Mask:TIntegerType=The Mask containing the bits to test.
[Result]
If all the bits in the Mask are set in Value the result is True, otherwise it's
False.
[Quick Info]
BCB=3,4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Bit Manipulation
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
[SeeAlso]
Count=4
1=TestBit
2=ClearBit
3=ToggleBit
4=SetBit
<DECL>--------------------------------------------------------------------------
[Declaration]
function ClearBit(const Value: Byte; const Bit: TBitRange): Byte; overload;
function ClearBit(const Value: Word; const Bit: TBitRange): Word; overload;
function ClearBit(const Value: Integer; const Bit: TBitRange): Integer; overload;
function ClearBit(const Value: Int64; const Bit: TBitRange): Int64; overload;
[ShortDescr]
Clears a bit in an integer-type value.
[Description]
ClearBit clears the specified bit position of the passed integer typed variable.
In other words it sets the bit at position Bit for Value to 0. This function
exists in 4 different forms, one for each integer type.
[Parameters]
Count=2
1=Value:TIntegerType=The integer-typed variable for which to clear a bit.
2=Bit:TBitRange=The 0 based bit position of the bit to clear. This is a modulo N
bit position where N is the number of bits in the Value parameter. For example,
if Value is a Byte, then Bit position is interpreted as Bit mod 8.
[Result]
Copy of Value with the bit at position Bit cleared.
[Quick Info]
BCB=3,4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Bit Manipulation
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
[SeeAlso]
Count=4
1=TestBit
2=TestBits
3=ToggleBit
4=SetBit
<DECL>--------------------------------------------------------------------------
[Declaration]
function SetBit(const Value: Byte; const Bit: TBitRange): Byte; overload;
function SetBit(const Value: Word; const Bit: TBitRange): Word; overload;
function SetBit(const Value: Integer; const Bit: TBitRange): Integer; overload;
function SetBit(const Value: Int64; const Bit: TBitRange): Int64; overload;
[ShortDescr]
Sets a bit in an integer-type value.
[Description]
SetBit sets the specified bit position of the passed integer typed variable.
In other words it sets the bit at position Bit for Value to 1. This function
exists in 4 different forms, one for each integer type.
[Parameters]
Count=2
1=Value:TIntegerType=The integer-typed variable for which to set a bit.
2=Bit:TBitRange=The 0 based bit position of the bit to set. This is a modulo N
bit position where N is the number of bits in the Value parameter. For example,
if Value is a Byte, then Bit position is interpreted as Bit mod 8.
[Result]
Copy of Value with the bit at position Bit set.
[Quick Info]
BCB=3,4,5
Unit=JclLogic
Category=Ordinal Math and Logic
Author=Marcel van Brakel;brakelm@bart.nl
SubCat=Bit Manipulation
Delphi=3,4,5
[SeeAlso]
Count=4
1=TestBit
2=ClearBit
3=ToggleBit
4=TestBits
<DECL>--------------------------------------------------------------------------
[Declaration]
function ToggleBit(const Value: Byte; const Bit: TBitRange): Byte; overload;
function ToggleBit(const Value: Word; const Bit: TBitRange): Word; overload;
function ToggleBit(const Value: Integer; const Bit: TBitRange): Integer; overload;
function ToggleBit(const Value: Int64; const Bit: TBitRange): Int64; overload;
[ShortDescr]
Toggles a bit in an integer-type value.
[Description]
ToggleBit toggles the specified bit position of the passed integer typed variable.
In other words, if the bit at the specified position is 0, then it is set to 1, if
it's 1 then it is set to 0. This function exists in 4 different forms, one for each
integer type.
[Parameters]
Count=2
1=Value:TIntegerType=The integer-typed variable for which to toggle a bit.
2=Bit:TBitRange=The 0 based bit position of the bit to toggle. This is a modulo N
bit position where N is the number of bits in the Value parameter. For example,
if Value is a Byte then Bit position is interpreted as Bit mod 8.
[Result]
Copy of Value with the bit at position Bit toggled.
[Quick Info]
BCB=3,4,5
Unit=JclLogic
Category=Ordinal Math and Logic
Author=Marcel van Brakel;brakelm@bart.nl
SubCat=Bit Manipulation
Delphi=3,4,5
[SeeAlso]
Count=4
1=TestBit
2=ClearBit
3=TestBits
4=SetBit
<DECL>--------------------------------------------------------------------------
[Declaration]
function TestBit(const Value: Byte; const Bit: TBitRange): Boolean; overload;
function TestBit(const Value: Word; const Bit: TBitRange): Boolean; overload;
function TestBit(const Value: Integer; const Bit: TBitRange): Boolean; overload;
function TestBit(const Value: Int64; const Bit: TBitRange): Boolean; overload;
[ShortDescr]
Tests a bit in an integer-type value.
[Description]
TestBit tests the specified bit position of the passed integer typed variable.
In other words if the bit at the specified position is 0 then the function returns
True, if it is 0 the function returns False. This function exists in 4 different
forms, one for each
integer type.
[Parameters]
Count=2
1=Value:TIntegerType=The integer-typed variable for which to test a bit.
2=Bit:TBitRange=The 0 based bit position of the bit to test. This is a modulo N
bit position where N is the number of bits in the Value parameter. For example,
if Value is a Byte then Bit position is interpreted as Bit mod 8.
[Result]
True if the bit at the specified position is set, False if it is not set.
[Quick Info]
BCB=3,4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Bit Manipulation
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
[SeeAlso]
Count=4
1=TestBits
2=ClearBit
3=ToggleBit
4=SetBit
