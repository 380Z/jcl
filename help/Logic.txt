<DECL>--------------------------------------------------------------------------
[Declaration]
function OrdToBinary(const Value: Byte): string; overload;
function OrdToBinary(const Value: Shortint): string; overload;
function OrdToBinary(const Value: Smallint): string; overload;
function OrdToBinary(const Value: Word): string; overload;
function OrdToBinary(const Value: Integer): string; overload;
function OrdToBinary(const Value: Cardinal): string; overload;
function OrdToBinary(const Value: Int64): string; overload;
[ShortDescr]
Returns the supplied value in its binary form.
[Description]
OrdToBinary returns a string representation of the specified value in its
binary form. That is, a string of '1' and '0' characters representing the bits
in the supplied value. The resulting string length is always equal to the number
of bits in the supplied value (leading 0's aren't stripped).
[Parameters]
Count=1
1=Value:IntegerType=The value whose binary string representation to retrieve.
[Result]
Binary string representation of the supplied value. The string has a length equal
to the number of bits in the supplied value and each character in the string
represents a single bit. The highest bit is placed in Result[1] and the lowest
bit in Result[Length(Result)].
[Quick Info]
BCB=3,4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Conversion
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function BitsHighest(X: Byte): Integer; overload;
function BitsHighest(X: ShortInt): Integer; overload;
function BitsHighest(X: SmallInt): Integer; overload;
function BitsHighest(X: Word): Integer; overload;
function BitsHighest(X: Integer): Integer; overload;
function BitsHighest(X: Cardinal): Integer; assembler; overload;
function BitsHighest(X: Int64): Integer; overload;
[ShortDescr]
Returns the highest bit set in the supplied value.
[Description]
BitsHighest returns the index of the highest bit which is set in the supplied
value. Note that bits are numbered right to left starting with 0. For example,
BitsHighest(5) returns 2 (5 equals 00000101 in binary).
[Parameters]
Count=1
1=X:Integer=The value for which to return the highest set bit.
[Result]
The index of the highest bit set, or -1 if no bits are set.
[Quick Info]
BCB=4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Bit Manipulation
Author=Michael Schnell;Michael.Schnell@MARIANNE.gihub.de
Delphi=3,4,5
[SeeAlso]
Count=2
1=BitsLowest
2=CountBitsSet
<DECL>--------------------------------------------------------------------------
[Declaration]
function BitsLowest(X: Byte): Integer; overload;
function BitsLowest(X: Shortint): Integer; overload;
function BitsLowest(X: Smallint): Integer; overload;
function BitsLowest(X: Word): Integer; overload;
function BitsLowest(X: Cardinal): Integer; assembler; overload;
function BitsLowest(X: Integer): Integer; overload;
function BitsLowest(X: Int64): Integer; overload;
[ShortDescr]
Returns the lowest bit set in the supplied value.
[Description]
BitsLowest returns the index of the lowest bit which is set in the supplied
value. Note that bits are numbered right to left starting with 0. For example,
BitsLowest(9) returns 2 (9 is 00001100 in binary).
[Parameters]
Count=1
1=X:Integer=The value for which to return the lowest set bit.
[Result]
The index of the lowest bit set, or -1 if no bits are set.
[Quick Info]
BCB=4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Bit Manipulation
Author=Michael Schnell;Michael.Schnell@MARIANNE.gihub.de
Delphi=3,4,5
[SeeAlso]
Count=2
1=BitsHighest
2=CountBitsSet
<DECL>--------------------------------------------------------------------------
[Declaration]
function ClearBit(const Value: Byte; const Bit: TBitRange): Byte; overload;
function ClearBit(const Value: Shortint; const Bit: TBitRange): Shortint; overload;
function ClearBit(const Value: Smallint; const Bit: TBitRange): Smallint; overload;
function ClearBit(const Value: Word; const Bit: TBitRange): Word; overload;
function ClearBit(const Value: Integer; const Bit: TBitRange): Integer; overload;
function ClearBit(const Value: Cardinal; const Bit: TBitRange): Cardinal; overload;
function ClearBit(const Value: Int64; const Bit: TBitRange): Int64; overload;
[ShortDescr]
Clears a bit in an integer-type value.
[Description]
ClearBit clears the specified bit position of the passed integer typed variable.
In other words, it sets the bit at position Bit for Value to 0. This function
exists in 7 different forms, one for each integer type.
[Parameters]
Count=2
1=Value:TIntegerType=The integer-typed variable for which to clear a bit.
2=Bit:TBitRange=The 0 based bit position of the bit to clear. This is a modulo N
bit position where N is the number of bits in the Value parameter. For example,
if Value is a Byte, then Bit position is interpreted as Bit mod 8.
[Result]
Copy of Value with the bit at position Bit cleared.
[Quick Info]
BCB=3,4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Bit Manipulation
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
[SeeAlso]
Count=4
1=TestBit
2=TestBits
3=ToggleBit
4=SetBit
<DECL>--------------------------------------------------------------------------
[Declaration]
function CountBitsSet(X: Byte): Integer; assembler; overload;
function CountBitsSet(X: Word): Integer; assembler; overload;
function CountBitsSet(X: Smallint): Integer; overload;
function CountBitsSet(X: ShortInt): Integer; overload;
function CountBitsSet(X: Integer): Integer; overload;
function CountBitsSet(X: Cardinal): Integer; assembler; overload;
function CountBitsSet(X: Int64): Integer; overload;
[ShortDescr]
Returns the number of set bits in the passed value.
[Description]
CountBitsSet returns the number of bits that are set (value 1) in the binary
representation of the supplied Value. For example, CountBitsSet(1) returns 1,
CountBitsSet(3) returns 2 etc. Note that signed integers are stored in two's
complement form and therefore, for example, CountBitsSet(-1) will return 32!
[Parameters]
Count=1
1=X:Integer=The value for which to determine the number of bits that are set.
[Result]
The number of set bits or 0 if no bits are set.
[Quick Info]
BCB=4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Bit Manipulation
Author=Michael Schnell;Michael.Schnell@MARIANNE.gihub.de
Delphi=3,4,5
[SeeAlso]
Count=2
1=BitsLowest
2=BitsHighest
<DECL>--------------------------------------------------------------------------
[Declaration]
function CountBitsCleared(X: Byte): Integer; overload;
function CountBitsCleared(X: Shortint): Integer; overload;
function CountBitsCleared(X: Smallint): Integer; overload;
function CountBitsCleared(X: Word): Integer; overload;
function CountBitsCleared(X: Integer): Integer; overload;
function CountBitsCleared(X: Cardinal): Integer; overload;
function CountBitsCleared(X: Int64): Integer; overload;
[ShortDescr]
Returns the number of cleared bits in the supplied value.
[Description]
CountBitsCleared returns the number of bits that are cleared (value 0) in the binary
representation of the supplied Value. Note that signed integers are stored in two's
complement form and therefore, for example, CountBitsCleared(Integer(-1)) will
return 0!
[Parameters]
Count=1
1=X:Integer=The value for which to determine the number of bits that are cleared.
This can be an Integer, Cardinal, Byte, Word or Int64.
[Result]
The number of cleared bits or 0 if no bits are cleared.
[Quick Info]
BCB=4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Bit Manipulation
Author=Robert Marquardt;robert_marquardt@gmx.de
Delphi=3,4,5
[SeeAlso]
Count=2
1=BitsLowest
2=BitsHighest
3=CountBitsSet
<DECL>--------------------------------------------------------------------------
[Declaration]
function LRot(const Value: Byte; const Count: TBitRange): Byte; overload;
function LRot(const Value: Word; const Count: TBitRange): Word; overload;
function LRot(const Value: Integer; const Count: TBitRange): Integer; overload;
[ShortDescr]
Left rotates bits.
[Description]
LRot shifts the bits in Value the specified number (Count) of times to the left.
On each shift the bit in the highest bit position wraps around into the lowest.
[Parameters]
Count=2
1=Value:TIntegerType=The Value whose bits to rotate.
2=Mask:TIntegerType=The number of times to rotate.
[Result]
The resulting integer after the rotation is performed.
[Quick Info]
BCB=3,4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Bit Manipulation
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
[SeeAlso]
Count=1
1=RRot
<DECL>--------------------------------------------------------------------------
[Declaration]
function ReverseBits(Value: Byte): Byte; overload;
function ReverseBits(Value: Shortint): Shortint; overload;
function ReverseBits(Value: Smallint): Smallint; overload;
function ReverseBits(Value: Word): Word; overload;
function ReverseBits(Value: Integer): Integer; overload;
function ReverseBits(Value: Cardinal): Cardinal; overload;
function ReverseBits(Value: Int64): Int64; overload;
function ReverseBits(P: Pointer; Count: Integer): Pointer; overload;
[ShortDescr]
Reverses the bits of Value.
[Description]
ReverseBits reverses the bits in the passed parameter. That is, assuming a byte,
bit 0 is swapped with bit 7, bit 1 is swapped with bit 6 and so on. This function
exists in 5 forms, one for each Integer type. The last overload is a generalisation
of this which reverses the bits in the supplied buffer. Note that all overloads
use a table based approach to reversing the bits. The simple types overloads use
only a 15 byte table while the pointer overload uses a 255 byte table. Due to
this the pointer overload is much faster when used on large buffers.<br>
[Parameters]
Count=3
1=Value:IntegerType=The integer type whose bits to reverse.
2=P:Pointer=Address of a buffer whose bits to reverse.
3=Count:Integer=Size of the buffer, in bytes, specified by P.
[Notes]
Count=3
1=<b>Warning</b> Keep in mind that some of the ReverseBits overloads accept signed
integers as their argument but that reversing the bits of a signed integer is
somewhat akward. Be sure that you understand the meaning of reversing the bits in
a signed integer and that's what you want.
2=The pointer returned by the Pointer overload points to the same buffer passed
in as it's argument, iow it's not a newly allocated buffer.
3=The ReverseBits(Pointer, Integer) overload was originally written by Mike Lischke.
[Result]
Copy of Value with it's bits reversed.
[Notes]
Count=1
1=Reversing is not the same as toggling. To toggle bits use the <REF>ToggleBit</REF> function.
[Quick Info]
BCB=3,4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Bit Manipulation
Author=Team JCL;jcl@delphi-jedi.org
Delphi=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function RRot(const Value: Byte; const Count: TBitRange): Byte; overload;
function RRot(const Value: Word; const Count: TBitRange): Word; overload;
function RRot(const Value: Integer; const Count: TBitRange): Integer; overload;
[ShortDescr]
Right rotates bits.
[Description]
RRot shifts the bits in Value the specified number (Count) of times to the right.
On each shift the bit in the lowest bit position wraps around into the highest.
[Parameters]
Count=2
1=Value:TIntegerType=The Value whose bits to rotate.
2=Mask:TIntegerType=The number of times to rotate.
[Result]
The resulting integer after the rotation is performed.
[Quick Info]
BCB=3,4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Bit Manipulation
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
[SeeAlso]
Count=1
1=LRot
<DECL>--------------------------------------------------------------------------
[Declaration]
function Sar(const Value: Shortint; const Count: TBitRange): Shortint; overload;
function Sar(const Value: Smallint; const Count: TBitRange): Smallint; overload;
function Sar(const Value: Integer; const Count: TBitRange): Integer; overload;
[ShortDescr]
Performs an arithmetic right shift.
[Description]
Sar performs an arithmetic right shift on the operand. An arithmetic right shift
is similar to a logical right shift (shr) except that shr operates on unsigned
values while Sar operates on signed values (and as such preserves the sign).
[Parameters]
Count=2
1=Value:TIntegerType=The Value whose bits to arithmetically shift.
2=Count:TBitRange=Number of positions to right shift.
[Result]
A copy of value after the arithmetic right shift operation.
[Quick Info]
BCB=3,4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Bit Manipulation
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function SetBit(const Value: Byte; const Bit: TBitRange): Byte; overload;
function SetBit(const Value: Shortint; const Bit: TBitRange): Shortint; overload;
function SetBit(const Value: Smallint; const Bit: TBitRange): Smallint; overload;
function SetBit(const Value: Word; const Bit: TBitRange): Word; overload;
function SetBit(const Value: Cardinal; const Bit: TBitRange): Cardinal; overload;
function SetBit(const Value: Integer; const Bit: TBitRange): Integer; overload;
function SetBit(const Value: Int64; const Bit: TBitRange): Int64; overload;
[ShortDescr]
Sets a bit in an integer-type value.
[Description]
SetBit sets the specified bit position of the supplied integer typed variable.
In other words it sets the bit at position Bit for Value to 1.
[Parameters]
Count=2
1=Value:TIntegerType=The integer-typed variable for which to set a bit.
2=Bit:TBitRange=The 0 based bit position of the bit to set. This is a modulo N
bit position where N is the number of bits in the Value parameter. For example,
if Value is a Byte, then Bit position is interpreted as Bit mod 8.
[Result]
Copy of Value with the bit at position Bit set.
[Quick Info]
BCB=3,4,5
Unit=JclLogic
Category=Ordinal Math and Logic
Author=Marcel van Brakel;brakelm@bart.nl
SubCat=Bit Manipulation
Delphi=3,4,5
[SeeAlso]
Count=4
1=TestBit
2=ClearBit
3=ToggleBit
4=TestBits
<DECL>--------------------------------------------------------------------------
[Declaration]
function TestBit(const Value: Byte; const Bit: TBitRange): Boolean; overload;
function TestBit(const Value: Shortint; const Bit: TBitRange): Boolean; overload;
function TestBit(const Value: Smallint; const Bit: TBitRange): Boolean; overload;
function TestBit(const Value: Word; const Bit: TBitRange): Boolean; overload;
function TestBit(const Value: Cardinal; const Bit: TBitRange): Boolean; overload;
function TestBit(const Value: Integer; const Bit: TBitRange): Boolean; overload;
function TestBit(const Value: Int64; const Bit: TBitRange): Boolean; overload;
[ShortDescr]
Tests a bit in an integer-type value.
[Description]
TestBit tests the specified bit position of the passed integer typed variable.
In other words if the bit at the specified position is 1 then the function returns
True, if it is 0 the function returns False.
[Parameters]
Count=2
1=Value:TIntegerType=The integer-typed variable for which to test a bit.
2=Bit:TBitRange=The 0 based bit position of the bit to test. This is a modulo N
bit position where N is the number of bits in the Value parameter. For example,
if Value is a Byte then Bit position is interpreted as Bit mod 8. <b>Warning: </b>
When calling this function you must cast a value passed to this parameter to a
TBitRange as in: "TestBit(Value, TBitRange(1))" otherwise Delphi will incorrectly
use the TestBit(Byte, TBitRange) overload instead of the correct overload. This
is a known problem in the compiler, not an error in the JCL.
[Result]
True if the bit at the specified position is set, False if it is cleared.
[Quick Info]
BCB=3,4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Bit Manipulation
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
[SeeAlso]
Count=4
1=TestBits
2=ClearBit
3=ToggleBit
4=SetBit
<DECL>--------------------------------------------------------------------------
[Declaration]
function TestBits(const Value, Mask: Byte): Boolean; overload;
function TestBits(const Value, Mask: Shortint): Boolean; overload;
function TestBits(const Value, Mask: Smallint): Boolean; overload;
function TestBits(const Value, Mask: Word): Boolean; overload;
function TestBits(const Value, Mask: Cardinal): Boolean; overload;
function TestBits(const Value, Mask: Integer): Boolean; overload;
function TestBits(const Value, Mask: Int64): Boolean; overload;
[ShortDescr]
Test multiple bits.
[Description]
TestBits performs a bitwise and operation on Value and Mask. This in effect tests
whether all bits that are set in Mask are also set in Value.
[Parameters]
Count=2
1=Value:TIntegerType=The Value whose bits to test.
2=Mask:TIntegerType=The Mask containing the bits to test.
[Result]
If all the bits in the Mask are also set in Value the result is True, otherwise it's False.
[Quick Info]
BCB=3,4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Bit Manipulation
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
[SeeAlso]
Count=4
1=TestBit
2=ClearBit
3=ToggleBit
4=SetBit
<DECL>--------------------------------------------------------------------------
[Declaration]
function ToggleBit(const Value: Byte; const Bit: TBitRange): Byte; overload;
function ToggleBit(const Value: Shortint; const Bit: TBitRange): Shortint; overload;
function ToggleBit(const Value: Smallint; const Bit: TBitRange): Smallint; overload;
function ToggleBit(const Value: Word; const Bit: TBitRange): Word; overload;
function ToggleBit(const Value: Cardinal; const Bit: TBitRange): Cardinal; overload;
function ToggleBit(const Value: Integer; const Bit: TBitRange): Integer; overload;
function ToggleBit(const Value: Int64; const Bit: TBitRange): Int64; overload;
[ShortDescr]
Toggles a bit in an integer-type value.
[Description]
ToggleBit toggles the specified bit position of the supplied integer typed variable.
In other words, if the bit at the specified position is 0, then it is set to 1, if
it's 1 then it is set to 0.
[Parameters]
Count=2
1=Value:TIntegerType=The integer-typed variable for which to toggle a bit.
2=Bit:TBitRange=The 0 based bit position of the bit to toggle. This is a modulo N
bit position where N is the number of bits in the Value parameter. For example,
if Value is a Byte then Bit position is interpreted as Bit mod 8.
[Result]
Copy of Value with the bit at position Bit toggled.
[Quick Info]
BCB=3,4,5
Unit=JclLogic
Category=Ordinal Math and Logic
Author=Marcel van Brakel;brakelm@bart.nl
SubCat=Bit Manipulation
Delphi=3,4,5
[SeeAlso]
Count=4
1=TestBit
2=ClearBit
3=TestBits
4=SetBit
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure BooleansToBits(var Dest: Byte; const B: array of Boolean); overload;
procedure BooleansToBits(var Dest: Word; const B: array of Boolean); overload;
procedure BooleansToBits(var Dest: Integer; const B: array of Boolean); overload;
procedure BooleansToBits(var Dest: Int64; const B: array of Boolean); overload;
[ShortDescr]
Packs an array of booleans into a set of bits.
[Description]
BooleansToBits packs the array of booleans into a set of bits. Each boolean in
the array which is set to True results in a 1 bit in the Dest variable while
each False valued boolean results in a 0 bit. The <REF>BitsToBooleans</REF>
routine performs the inverse operation. Note that if the array contains more
elements than can fit into the destination variable, the elements in the array
with index larger than the highest bit (i.e. 7 for a byte) in the destination
variable will be ignored.
[Parameters]
Count=2
1=Dest:Integer=Integer type variable in which the appropriate bits are set/cleared.
2=B:array of Boolean=The array of Booleans to pack into a set of bits. Note that
the upper bound of this array must not be larger then the size of the Dest parameters,
in bits. Thus, for the Byte variant this array must not be larger then 8 elements.
[Quick Info]
BCB=4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Bit Manipulation
Author=Robert Marquardt;robert_marquardt@gmx.de
Delphi=3,4,5
[SeeAlso]
Count=1
1=BitsToBooleans
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure BitsToBooleans(const Bits: Byte; var B: TBooleanArray; AllBits: Boolean {$IFDEF SUPPORTS_DEFAULTPARAMS} = False {$ENDIF}); overload;
procedure BitsToBooleans(const Bits: Word; var B: TBooleanArray; AllBits: Boolean {$IFDEF SUPPORTS_DEFAULTPARAMS} = False {$ENDIF}); overload;
procedure BitsToBooleans(const Bits: Integer; var B: TBooleanArray; AllBits: Boolean {$IFDEF SUPPORTS_DEFAULTPARAMS} = False {$ENDIF}); overload;
procedure BitsToBooleans(const Bits: Int64; var B: TBooleanArray; AllBits: Boolean {$IFDEF SUPPORTS_DEFAULTPARAMS} = False {$ENDIF}); overload;
[ShortDescr]
Unpacks a set of bits into an array of booleans.
[Description]
BitsToBooleans unpacks a set of bits into an array of Booleans. Each set bit in
the Bits parameter results in a True valued Boolean while each cleared bit
results in a False valued boolean. The resulting array has one element for each
bit in the Bits parameter where bit 0 corresponds to B[0], bit 1 to B[1] etc.
See also <REF>BooleansToBits</REF> for the inverse operation. If the AllBits
parameter is True, the number of elements in the resulting array is the same as
the number of bits in the Bits parameter, if set to False (the default) the
resulting array has only as many elements as is required to hold the highest
set bit position. For example, if Bits equals 2 than the highest set bit is bit 1
and the resulting array has only two elements: [True, False].
[Parameters]
Count=2
1=Bits:Integer=The set of bits to unpack to an array of Booleans.
2=B:TBooleanArray=Array which receives the bits in Bits unpacked as Booleans.
3=AllBits:Boolean=If set to True the number of elements in the resulting array
equals the number of bits in the Bits parameter (ie 8 for Byte, 16 for Word, etc).
If False the number of elements in the resulting array equals the position of the
highest set bit.
[Quick Info]
BCB=4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Bit Manipulation
Author=Robert Marquardt;robert_marquardt@gmx.de
Delphi=3,4,5
[SeeAlso]
Count=1
1=BooleansToBits
<DECL>--------------------------------------------------------------------------
[Declaration]
function BitsNeeded(const X: Byte): Integer; overload;
function BitsNeeded(const X: Word): Integer; overload;
function BitsNeeded(const X: Integer): Integer; overload;
function BitsNeeded(const X: Int64): Integer; overload;
[ShortDescr]
Returns the number of Bits needed to represent a given positive integer.
[Description]
Returns the number of Bits needed to represent a given positive integer.
[Parameters]
Count=1
1=X:Cardinal=The value for which you want to now how many bits are needed to represent it.
[Result]
The number of bits needed to represent the value.
[Quick Info]
BCB=3,4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Bit Manipulation
Author=ESB Consultancy;glenn@esbconsult.com.au
Delphi=3,4,5
[SeeAlso]
Count=1
1=Digits
<DECL>--------------------------------------------------------------------------
[Declaration]
function Digits(const X: Cardinal): Integer;
[ShortDescr]
Returns the number of digits in a given positive integer.
[Description]
Returns the number of digits in a given positive integer.
[Parameters]
Count=1
1=X:Cardinal=The value for which you want to know how many digits it has.
[Result]
The number of digits in the specified value.
[Quick Info]
BCB=3,4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Bit Manipulation
Author=ESB Consultancy;glenn@esbconsult.com.au
Delphi=3,4,5
[SeeAlso]
Count=1
1=BitsNeeded
<DECL>--------------------------------------------------------------------------
[Declaration]
function ReverseBytes(Value: Word): Word; overload;
function ReverseBytes(Value: Smallint): Smallint; overload;
function ReverseBytes(Value: Integer): Integer; overload;
function ReverseBytes(Value: Cardinal): Cardinal; overload;
function ReverseBytes(Value: Int64): Int64; overload;
function ReverseBytes(P: Pointer; Count: Integer): Pointer; overload;
[ShortDescr]
Reverses the bytes of Value.
[Description]
ReverseBytes reverses the bytes in the supplied parameter. That is, assuming an Integer,
byte 0 is swapped with byte 3, byte 1 is swapped with byte 2. This function
exists in 5 forms, one for each Integer type. The last overload is a generalisation
of this which reverses the bytes in the supplied buffer.
[Parameters]
Count=3
1=Value:IntegerType=The integer type whose bytes to reverse.
2=P:Pointer=Address of a buffer whose bytes to reverse.
3=Count:Integer=Size of the buffer, in bytes, specified by P.
[Notes]
Count=2
1=The pointer returned by the Pointer overload points to the same buffer passed
in as it's argument, iow it's not a newly allocated buffer.
2=The ReverseBytes function was inspired by code from Liran Shahar
[Result]
Copy of Value with it's bits reversed.
[Quick Info]
BCB=3,4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Bit Manipulation
Author=Team JCL;jcl@delphi-jedi.org
Delphi=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function Max(const B1, B2: Byte): Byte; overload;
function Max(const B1, B2: Shortint): Shortint; overload;
function Max(const B1, B2: Word): Word; overload;
function Max(const B1, B2: Integer): Integer; overload;
function Max(const B1, B2: Cardinal): Cardinal; overload;
function Max(const B1, B2: Int64): Int64; overload;
[ShortDescr]
Returns the larger of two values.
[Description]
Max returns the larger of the two passed values.
[Parameters]
Count=2
1=B1:IntegerType=The first value.
2=B2:IntegerType=The second value.
[Result]
The larger of the two values.
[Quick Info]
BCB=3,4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Arithmetic
Author=ESB Consultancy;glenn@esbconsult.com.au
Delphi=3,4,5
[SeeAlso]
Count=1
1=Min
<DECL>--------------------------------------------------------------------------
[Declaration]
function Min(const B1, B2: Byte): Byte; overload;
function Min(const B1, B2: Shortint): Shortint; overload;
function Min(const B1, B2: Word): Word; overload;
function Min(const B1, B2: Integer): Integer; overload;
function Min(const B1, B2: Cardinal): Cardinal; overload;
function Min(const B1, B2: Int64): Int64; overload;
[ShortDescr]
Returns the smaller of two values.
[Description]
Min returns the smaller of the two passed values.
[Parameters]
Count=2
1=B1:IntegerType=The first value.
2=B2:IntegerType=The second value.
[Result]
The smaller of the two values.
[Quick Info]
BCB=3,4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Arithmetic
Author=ESB Consultancy;glenn@esbconsult.com.au
Delphi=3,4,5
[SeeAlso]
Count=1
1=Max
<DECL>--------------------------------------------------------------------------
[Declaration]
function DecLimit(var B: Byte; const Limit: Byte; const Decr: Byte = 1): Byte; overload;
function DecLimit(var B: ShortInt; const Limit: Shortint; const Decr: ShortInt = 1): Shortint; overload;
function DecLimit(var B: Word; const Limit: Word; const Decr: Word = 1): Word; overload;
function DecLimit(var B: Integer; const Limit: Integer; const Decr: Integer = 1): Integer; overload;
function DecLimit(var B: Cardinal; const Limit: Cardinal; const Decr: Cardinal = 1): Cardinal; overload;
function DecLimit(var B: Int64; const Limit: Int64; const Decr: Int64 = 1): Int64; overload;
[ShortDescr]
Decrements an ordinal up to limit.
[Description]
DecLimit decrements the specified ordinal variable by the specified value if and
only if the operation will not decrement beyond the limit. For example, suppose
that X equals 10, now calling DecLimit(X, 5, 2) will decrement X by 2 leaving it
with 8 on return. However, calling DecLimit(X, 5, 6) will not decrement X by 6
because that would decrement X beyond the limit. On return X still contains 10.
[Parameters]
Count=3
1=B:IntegerType=The value to conditionally decrement.
2=Limit:IntegerType=The decrementation limit, this is inclusive.
3=Decr:IntegerType=The amount to decrement.
[Result]
B contains the decremented value if within limit, otherwise it contains the original value.
This same value is returned as the function result.
[Quick Info]
BCB=3,4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Arithmetic
Author=ESB Consultancy;glenn@esbconsult.com.au
Delphi=3,4,5
[SeeAlso]
Count=3
1=IncLimit
2=IncLimitClamp
3=DecLimitClamp
<DECL>--------------------------------------------------------------------------
[Declaration]
function IncLimit(var B: Byte; const Limit: Byte; const Incr: Byte = 1): Byte; overload;
function IncLimit(var B: Shortint; const Limit: Shortint; const Incr: Shortint = 1): Shortint; overload;
function IncLimit(var B: Word; const Limit: Word; const Incr: Word = 1): Word; overload;
function IncLimit(var B: Integer; const Limit: Integer; const Incr: Integer = 1): Integer; overload;
function IncLimit(var B: Cardinal; const Limit: Cardinal; const Incr: Cardinal = 1): Cardinal; overload;
function IncLimit(var B: Int64; const Limit: Int64; const Incr: Int64 = 1): Int64; overload;
[ShortDescr]
Increments an ordinal up to limit.
[Description]
IncLimit increments the specified ordinal variable by the specified value if and
only if the operation will not increment beyond the limit. For example, suppose
that X equals 5, now calling IncLimit(X, 10, 2) will increment X by 2 leaving it
with 7 on return. However, calling IncLimit(X, 10, 6) will not increment X by 6
because that would increment X beyond the limit. On return X still contains 5.
[Parameters]
Count=3
1=B:IntegerType=The value to conditionally increment.
2=Limit:IntegerType=The incrementation limit.
3=Incr:IntegerType=The amount to increment.
[Result]
B contains the incremented value if within limit, otherwise it contains the original value.
This same value is returned as the function result.
[Quick Info]
BCB=3,4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Arithmetic
Author=ESB Consultancy;glenn@esbconsult.com.au
Delphi=3,4,5
[SeeAlso]
Count=3
1=DecLimit
2=DecLimitClamp
3=IncLimitClamp
<DECL>--------------------------------------------------------------------------
[Declaration]
function DecLimitClamp(var B: Byte; const Limit: Byte; const Decr: Byte = 1): Byte; overload;
function DecLimitClamp(var B: ShortInt; const Limit: Shortint; const Decr: ShortInt = 1): Shortint; overload;
function DecLimitClamp(var B: Word; const Limit: Word; const Decr: Word = 1): Word; overload;
function DecLimitClamp(var B: Integer; const Limit: Integer; const Decr: Integer = 1): Integer; overload;
function DecLimitClamp(var B: Cardinal; const Limit: Cardinal; const Decr: Cardinal = 1): Cardinal; overload;
function DecLimitClamp(var B: Int64; const Limit: Int64; const Decr: Int64 = 1): Int64; overload;
[ShortDescr]
Decrements an ordinal up to limit.
[Description]
DecLimitClamp decrements the specified ordinal variable by the specified value. If
this decrement would decrease the value beyond the specified limit, the variable is
clamped to the limit. For example, suppose
that X equals 10, now calling DecLimitClamp(X, 5, 2) will decrement X by 2 leaving it
with 8 on return. However, calling DecLimitClamp(X, 5, 6) will not decrement X by 6
because that would decrement X beyond the limit. X is set to 5 (the limit) instead.
[Parameters]
Count=3
1=B:IntegerType=The value to conditionally decrement.
2=Limit:IntegerType=The decrementation limit, this is inclusive.
3=Decr:IntegerType=The amount to decrement.
[Result]
B contains the decremented value if within limit, otherwise it is set to the limit
value. This same value is returned as the function result.
[Notes]
Count=1
1=If upon entry the B variable is already smaller than the limit the variable is
set to Limit.
[Quick Info]
BCB=3,4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Arithmetic
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
[SeeAlso]
Count=3
1=IncLimit
2=DecLimit
3=IncLimitClamp
<DECL>--------------------------------------------------------------------------
[Declaration]
function IncLimitClamp(var B: Byte; const Limit: Byte; const Incr: Byte = 1): Byte; overload;
function IncLimitClamp(var B: Shortint; const Limit: Shortint; const Incr: Shortint = 1): Shortint; overload;
function IncLimitClamp(var B: Word; const Limit: Word; const Incr: Word = 1): Word; overload;
function IncLimitClamp(var B: Integer; const Limit: Integer; const Incr: Integer = 1): Integer; overload;
function IncLimitClamp(var B: Cardinal; const Limit: Cardinal; const Incr: Cardinal = 1): Cardinal; overload;
function IncLimitClamp(var B: Int64; const Limit: Int64; const Incr: Int64 = 1): Int64; overload;
[ShortDescr]
Increments an ordinal up to limit.
[Description]
IncLimitClamp increments the specified ordinal variable by the specified value. If
this increment would increase the value beyond the specified limit, the variable is
clamped to the limit. For example, suppose
that X equals 5, now calling IncLimitClamp(X, 10, 2) will increment X by 2 leaving it
with 7 on return. However, calling IncLimitClamp(X, 10, 6) will not increment X by 6
because that would increment X beyond the limit. X is set to 10 (the limit) instead.
[Parameters]
Count=3
1=B:IntegerType=The value to conditionally increment.
2=Limit:IntegerType=The incrementation limit.
3=Incr:IntegerType=The amount to increment.
[Result]
B contains the incremented value if within limit, otherwise it is set to the limit
value. This same value is returned as the function result.
[Notes]
Count=1
1=If upon entry the B variable is already larger than the limit the variable is
set to Limit.
[Quick Info]
BCB=3,4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Arithmetic
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
[SeeAlso]
Count=3
1=DecLimit
2=IncLimit
3=DecLimitClamp
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure SwapOrd(var I, J: Byte); overload;
procedure SwapOrd(var I, J: Cardinal); overload;
procedure SwapOrd(var I, J: Integer); overload;
procedure SwapOrd(var I, J: Int64); overload;
procedure SwapOrd(var I, J: Shortint); overload;
procedure SwapOrd(var I, J: Smallint); overload;
procedure SwapOrd(var I, J: Word); overload;
[ShortDescr]
Swaps two integer-typed variables.
[Description]
The Swap function swaps the two supplied arguments. When the function returns
I has the value of J and J has the value of I. This function exist in 7 forms,
one for each Integer type. A function to swap floating point values exists as well
in the JclMath unit, see <REF Target"..\Math\Float support\SwapFloat">SwapFloat</REF>.
[Parameters]
Count=2
1=I:IntegerType=First of the two variables to swap.
2=J:IntegerType=Second of the two variables to swap.
[Result]
At the end of this routine I will contain the original value of J and J will contain the original value of I.
[Quick Info]
BCB=3,4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Arithmetic
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function LRot(const Value: Byte; const Count: TBitRange): Byte; overload;
function LRot(const Value: Word; const Count: TBitRange): Word; overload;
function LRot(const Value: Integer; const Count: TBitRange): Integer; overload;
[ShortDescr]
Left rotates bits.
[Description]
LRot shifts the bits in Value the specified Count number of times to the left.
On each shift the bit in the highest bit position wraps around into the lowest.
This function exists in 3 forms, one for each Integer type.
[Parameters]
Count=2
1=Value:TIntegerType=The Value whose bits to rotate.
2=Mask:TIntegerType=The number of times to rotate.
[Result]
The resulting integer after the rotate is performed.
[Quick Info]
BCB=3,4,5
Unit=JclLogic
Category=Ordinal Math and Logic
SubCat=Bit Manipulation
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
[SeeAlso]
Count=1
1=RRot
