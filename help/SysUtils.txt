<DECL>--------------------------------------------------------------------------
[Declaration]
function PWideCharOrNil(const W: WideString): PWideChar;
[ShortDescr]
Explicit replacement for PWideChar typecast.
[Description]
PWideCharOrNil returns a pointer to the first character of the specified string
or nil of the string is empty. This is identical to simply typecasting to
PWideChar except that this function makes the behaviour of the typecast explicit
 (and independent of the compiler).
[Parameters]
Count=1
1=S:WideString=The string for which to return a PWideChar.
[Result]
If the specified string is empty the funtion returns nil, otherwise it returns
a pointer to the first character of the string.
[Quick Info]
Unit=JclSysUtils
Category=Base Services
SubCat=Pointer manipulation
Author=Petr Vones;petr.v@mujmail.cz
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=1
1=PCharOrNil
<DECL>--------------------------------------------------------------------------
[Declaration]
function PCharOrNil(const S: AnsiString): PChar;
[ShortDescr]
Explicit replacement for PChar typecast.
[Description]
PCharOrNil returns a pointer to the first character of the specified string or
nil if the string is empty. This is identical to simply typecasting to PChar
except that this function makes the behaviour of the typecast explicit (and
independent of the compiler).
[Parameters]
Count=1
1=S:AnsiString=The string for which to return a PChar.
[Result]
If the specified string is empty the funtion returns nil, otherwise it returns
a pointer to the first character of the string.
[Quick Info]
Unit=JclSysUtils
Category=Base Services
SubCat=Pointer manipulation
Author=Petr Vones;petr.v@mujmail.cz
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=1
1=PWideCharOrNil
<DECL>--------------------------------------------------------------------------
[Declaration]
function IntToStrZeroPad(Value, Count: Integer): AnsiString;
[ShortDescr]
Converts an integer to a string an left pads it with zero's.
[Description]
IntToStrZeroPad converts the specified integer value to a string containing the
decimal representation of that number and left pads it with zero's if the
resulting string is less than the specified number of characters.
[Parameters]
Count=2
1=Value:Integer=The integer value to convert to a string.
2=Count:Integer=The number of characters in the resulting string. If the string
is less than the specified number, the string is left padded with zero's until
the string is the specified number of characters long.
[Result]
The string representation of the specified integer value, left padded with zero's.
I don't know of any input that can cause this function to fail, but in the
unlikely event that it does, it does so by raising an exception.
[Quick Info]
Unit=JclSysUtils
Category=Base Services
SubCat=Numeric formatting routines
Author=Anthony Steele;anthony@southeaster.com
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function Iff(const Condition: Boolean; const TruePart, FalsePart: string): string; overload;
function Iff(const Condition: Boolean; const TruePart, FalsePart: Char): Char; overload;
function Iff(const Condition: Boolean; const TruePart, FalsePart: Byte): Byte; overload;
function Iff(const Condition: Boolean; const TruePart, FalsePart: Integer): Integer; overload;
function Iff(const Condition: Boolean; const TruePart, FalsePart: Cardinal): Cardinal; overload;
function Iff(const Condition: Boolean; const TruePart, FalsePart: Float): Float; overload;
function Iff(const Condition: Boolean; const TruePart, FalsePart: Boolean): Boolean; overload;
function Iff(const Condition: Boolean; const TruePart, FalsePart: Pointer): Pointer; overload;
function Iff(const Condition: Boolean; const TruePart, FalsePart: Int64): Int64; overload;
[ShortDescr]
Replacement for the C++ ternary conditional operator.
[Description]
Iff is a replacement for the C/C++ ternary conditional operator ?:. It evaluates
the specified boolean expression and depending on the outcome returns either
the specified TruePart or FalsePart parameter.
The difference to the C/C++ operator is that both expressions are evaluated.
[Parameters]
Count=3
1=Condition:Boolean=The expression which determines which of the other parameters
is returned as the function result.
2=TruePart:Type=The function result if Condition evaluates to True.
3=FalsePart:Type=The function result if Condition evaluates to False.
[Result]
If Condition evaluates to True TruePart is returned, otherwise FalsePart is returned.
[Quick Info]
Unit=JclSysUtils
Category=Base Services
Author=Bernhard Berger;bernhardberger@yahoo.de
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function SizeOfMem(const P: Pointer): Integer;
[ShortDescr]
Returns the size of a memory block given a pointer.
[Description]
SizeOfMem returns the size of the memory block pointed to by the specified pointer.
This routine depends on information peeked from the standard Delphi memory manager
implemention (in GetMem.inc) and will not work when a custom memory manager
replacement is in use. Also, it will only work for memory allocated using the
AllocMem, GetMem and New routines; that is, using the Delphi memory manager.
[Parameters]
Count=1
1=P:Pointer=Pointer to the memory block whose size to retrieve.
[Result]
The total size of the memory block pointed to by P. Note that the current
implementation uses a 4 byte header to store some additonal information (such as
the size) about the memory block. These 4 bytes are included in the result. To get
the size of the block available to the user (the size specified when the block
was allocated) simply subtract 4. If the function fails to determine the size of
the memory, for example because it detected that the Delphi memory manager was 
replaced by a custom memory manager, it returns -1.
[Quick Info]
Unit=JclSysUtils
Category=Memory, Classes and Objects
SubCat=Pointer manipulation
Author=Robert R. Marsh;maps@rmarsh.com
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure FreeAndNil(var Obj);
[ShortDescr]
Frees an object reference and replaces it with nil.
[Description]
FreeAndNil frees the object instance pointed to by Obj and replaces the reference
with nil. This ensures that the reference is nil after the object has been
destroyed and helps debugging. Do not use this routine on objects or generic
pointers which are not TObject descendants. For generic pointers you can use
the <REF>FreeMemAndNil</REF> procedure.
[Parameters]
Count=1
1=Obj:TObject=Reference to an instance of a TObject descendant to free. Upon return
the Obj variable has been reset to nil so future references ensure a relatively
easy to understand access violation.
[Quick Info]
Unit=JclSysUtils
Category=Memory, Classes and Objects
SubCat=Pointer manipulation
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=4,5
[SeeAlso]
Count=1
1=FreeMemAndNil
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure FreeMemAndNil(var P: Pointer);
[ShortDescr]
Frees a block of memory and sets the reference to nil.
[Description]
FreeMemAndNil frees the memory pointed to by P and replaces the reference
with nil. This ensures that the reference is nil after the memory has been
released and helps debugging. Do not use this routine on objects or TObject
descendants. For TObject (descendants) you can use the <REF>FreeAndNil</REF> procedure.
[Parameters]
Count=1
1=P:Pointer=Reference to the memory block to release. Upon return the P variable
has been reset to nil so future references ensure a relatively easy to understand
access violation.
[Quick Info]
Unit=JclSysUtils
Category=Memory, Classes and Objects
SubCat=Pointer manipulation
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=4,5
[SeeAlso]
Count=1
1=FreeAndNil
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure GetAndFillMem(var P: Pointer; Size: Integer; Value: Byte);
[ShortDescr]
Allocates memory and fills it with the specified value.
[Description]
GetAndFillMem allocates a block of memory from the heap of the specified size
and fills each byte in that block with the specified value.
[Parameters]
Count=3
1=P:Pointer=Receives a pointer to the allocated memory block.
2=Size:Integer=Size, in bytes, of the block of memory to allocate.
3=Value:Byte=Value with which to fill the memory block.
[Quick Info]
Unit=JclSysUtils
Category=Memory, Classes and Objects
SubCat=Pointer manipulation
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function GetVirtualMethodCount(AClass: TClass): Integer;
[ShortDescr]
Returns the number of virtual methods of a class.
[Description]
GetVirtualMethodCount returns the number of virtual methods of the specified
class. This includes the methods declared in the class itself and all its
parent classes. However, the result does not include the virtual methods declared
in TObject. The result includes all abstract methods.
[Parameters]
Count=1
1=AClass:TClass=The class for which to get the number of virtual methods.
[Result]
The number of virtual methods of the given class.
[Quick Info]
Unit=JclSysUtils
Category=Memory, Classes and Objects
SubCat=Class Manipulation\VMT
Author=Python;python@softhome.net
Delphi=4,5
[SeeAlso]
Count=2
1=GetVirtualMethod
2=SetVirtualMethod
<DECL>--------------------------------------------------------------------------
[Declaration]
function GetVirtualMethod(AClass: TClass; const Index: Integer): Pointer;
[ShortDescr]
Returns a pointer to the virtual method from the specified class with the given index.
[Description]
Returns the virtual method from the specified class with the given index. There
is no checking performed that the given index actually is a virtual method, and the
return value is undefined for invalid indices.
[Parameters]
Count=2
1=AClass:TClass=The class for which to get a virtual method.
2=Index:Integer=The index of the virtual method to be retrieved. If the index is
invalid the result is undefined. Valid indices are 0 to <REF>GetVirtualMethodCount</REF> - 1.
[Result]
The result is a pointer to the virtual method. If the method is an abstract
method the value returned is a pointer to System._AbstractError.
[Quick Info]
Unit=JclSysUtils
Category=Memory, Classes and Objects
SubCat=Class Manipulation\VMT
Author=Python;python@softhome.net
Delphi=4,5
[SeeAlso]
Count=2
1=GetVirtualMethodCount
2=SetVirtualMethod
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure SetVirtualMethod(AClass: TClass; const Index: Integer; const Method: Pointer);
[ShortDescr]
Changes a virtual method to the given method.
[Description]
Changes a virtual method to the given method.<P><FONT color=red>Do <B>NOT</B>
use this function.</FONT><BR> There should be no need to use this function
unless your implementing a very dirty hack. <P>There is no checking
performed that the Index is a valid virtual method index. The function only
changes the pointer in the VMT of the specified class, not the static references
to this method, which are made when an anchestor uses inherited to call the virtual
method. This procedure changes the executable code (with the risk of completly
destroying your application) and uses WriteProcessMemory to accomplish that.
The function is multiprocessor safe.
[Parameters]
Count=3
1=AClass:TClass=The class for which to set a virtual method.
2=Index:Integer=The index of the virtual method to be set.
3=Method:Pointer=The new address of the virtual method.
[Quick Info]
Unit=JclSysUtils
Category=Memory, Classes and Objects
SubCat=Class Manipulation\VMT
Author=Python;python@softhome.net
Delphi=4,5
[SeeAlso]
Count=2
1=GetVirtualMethodCount
2=GetVirtualMethod
<DECL>--------------------------------------------------------------------------
[Declaration]
function GetDynamicMethodCount(AClass: TClass): Integer;
[ShortDescr]
Returns the number of dynamic methods of a class.
[Description]
GetDynamicMethodCount returns the number of dynamic methods for the specified
class (including abstract methods). This only includes dynamic methods declared
in the class itself, not the methods delcared in ancestor classes.
[Parameters]
Count=1
1=AClass:TClass=The class for which to get the number of dynamic methods.
[Result]
The number of dynamic methods of the specified class.
[Quick Info]
Unit=JclSysUtils
Category=Memory, Classes and Objects
SubCat=Class Manipulation\DMT
Author=Python;python@softhome.net
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function GetDynamicIndexList(AClass: TClass): PDynamicIndexList;
[ShortDescr]
Returns the list of indices of the dynamic methods.
[Description]
Returns the list of indices for the dynamic methods, not including the indices
of the dynamic methods from inherited classes.
Use this list in combination with <REF>GetDynamicAddressList</REF>
and <REF>GetDynamicMethodCount</REF> to get all dynamic methods with their indices.
The number of entries in the returned array that contain meaningful data is
returned by <REF>GetDynamicMethodCount</REF>. The returned pointer points directly
into the class structure and should not be modified.
[Parameters]
Count=1
1=AClass:TClass=The class for which to get dynamic method index list.
[Result]
Pointer to an array containing the indices. Do not modify this array!
[Quick Info]
Unit=JclSysUtils
Category=Memory, Classes and Objects
SubCat=Class Manipulation\DMT
Author=Python;python@softhome.net
Delphi=4,5
[SeeAlso]
Count=1
1=TDynamicIndexList;..\TDynamicIndexList
<DECL>--------------------------------------------------------------------------
[Declaration]
TDynamicIndexList = array [0..MaxInt div 16] of Word;
PDynamicIndexList = ^TDynamicIndexList;
[ShortDescr]
List of valid indices in a dynamic method table.
[Description]
List of indices of valid entries in a dynamic method table. Use <REF Target"..\GetDynamicMethodCount">GetDynamicMethodCount</REF>
to get the count of valid entries in this list.
[Quick Info]
Kind=Type
Unit=JclSysUtils
Category=Memory, Classes and Objects
SubCat=Class Manipulation\DMT
Author=Python;python@softhome.net
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function GetDynamicAddressList(AClass: TClass): PDynamicAddressList;
[ShortDescr]
Returns the list of addresses for the dynamic methods of a class.
[Description]
Returns the list of addresses for the dynamic methods of the specified class.
Use this list in combination with <REF>GetDynamicIndexList</REF>
and <REF>GetDynamicMethodCount</REF> to get all dynamic methods and their indices.
The number of entries in the returned array that contain meaningful data is
returned by GetDynamicMethodCount. The returned pointer points directly into
the class structure and should not be modified.
[Parameters]
Count=1
1=AClass:TClass=The class for which to get dynamic method address list.
[Result]
Pointer to an array containing the addresses. Do not modify this array!
[Quick Info]
Unit=JclSysUtils
Category=Memory, Classes and Objects
SubCat=Class Manipulation\DMT
Author=Python;python@softhome.net
Delphi=4,5
[SeeAlso]
Count=1
1=TDynamicAddressList;Types\TDynamicAddressList
<DECL>--------------------------------------------------------------------------
[Declaration]
TDynamicAddressList = array [0..MaxInt div 16] of Pointer;
PDynamicAddressList = ^TDynamicAddressList;
[ShortDescr]
List of addresses of a dynamic methods
[Description]
List of addresses of the dynamic methods, use <REF Target"..\GetDynamicMethodCount">GetDynamicMethodCount</REF>
to get the indices of valid entries in the list.
[Quick Info]
Kind=Type
Unit=JclSysUtils
Category=Memory, Classes and Objects
SubCat=Class Manipulation\DMT
Author=Python;python@softhome.net
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function HasDynamicMethod(AClass: TClass; Index: Integer): Boolean;
[ShortDescr]
Test if the class (or one of its ancestors) has a dynamic method with the given index.
[Description]
Test if the class (or one of its ancestors) has a dynamic method with the given index.
[Parameters]
Count=2
1=AClass:TClass=The class for which to test for the dynamic method.
2=Index:Integer=The index for which to test.
[Result]
If the class contains a dynamic method with the given index the result is True,
otherwise the result is False.
[QuickInfo]
Unit=JclSysUtils
Category=Memory, Classes and Objects
SubCat=Class Manipulation\DMT
Author=Python;python@softhome.net
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function GetDynamicMethod(AClass: TClass; Index: Integer): Pointer;
[ShortDescr]
Returns a pointer to a specific dynamic method.
[Description]
Returns (the most recent version of) the dynamic method with the given index.
If there is no dynamic method with the given index an abstract error will be
raised, however, if the dynamic method is an abstract method,
System._AbstractError is returned.
[Parameters]
Count=2
1=AClass:TClass=The class for which to get the dynamic method.
2=Index:Integer=The index for which to get.
[Result]
Returns a pointer to the dynamic method, or System._AbstractError if the
dynamic method is an abstract method.
[Quick Info]
Unit=JclSysUtils
Category=Memory, Classes and Objects
SubCat=Class Manipulation\DMT
Author=Python;python@softhome.net
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function GetInitTable(AClass: TClass): PTypeInfo;
[ShortDescr]
Returns the initialization table of a class.
[Description]
GetInitTable returns the initialization table of the specified class.
TODO This is abracadabra to me :-) Need to contact author for further explanation
about this (eg what does the init table look like).
The initialization table is a record type info, from which the size is set to zero, but
still has info about the fields which needs to be initialized, but only for
the fields not already existing in an inherited class. It is used when a new
object is created to initialize its fields.
[Parameters]
Count=1
1=AClass:TClass=The class for which to get the initialization table.
[Result]
The result is a pointer to the initialization table. Do not modify this structure!
[Quick Info]
Unit=JclSysUtils
Category=Memory, Classes and Objects
SubCat=Class Manipulation\DMT
Author=Python;python@softhome.net
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function GetFieldTable(AClass: TClass): PFieldTable;
[ShortDescr]
Returns the field table of a class.
[Description]
GetFieldTable returns a pointer to the field table of the specified class.
A field table contains information about the published fields in a class.
[Parameters]
Count=1
1=AClass:TClass=The class for which to retrieve the field table.
[Result]
Pointer to the field table. Do not modify this structure!
[Quick Info]
Unit=JclSysUtils
Category=Memory, Classes and Objects
SubCat=Class Manipulation\DMT
Author=Python;python@softhome.net
Delphi=4,5
[SeeAlso]
Count=1
1=TFieldTable;Types\TFieldTable
<DECL>--------------------------------------------------------------------------
[Declaration]
TFieldTable = packed record
  EntryCount: Word;
  FieldClassTable: <REF>PFieldClassTable</REF>;
  FirstEntry: <REF>TFieldEntry</REF>;
 {Entries: array [1..65534] of TFieldEntry;}
end;
PFieldTable = ^TFieldTable;
[ShortDescr]
TODO
[Description]
TODO
[RecordFields]
Count=3
1=EntryCount:Word=Number of entries in the field table.
2=FieldClassTable:PFieldClassTable=Table with classes, used by the entries IDX property.
3=FirstEntry:TFieldEntry=First entry (if it exists), this is a variable length structure.
[Quick Info]
Kind=Type
Unit=JclSysUtils
Category=Memory, Classes and Objects
SubCat=Class Manipulation\DMT
Author=Python;python@softhome.net
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
TFieldClassTable = packed record
  Count: Smallint;
  Classes: array [0..8191] of ^TPersistentClass;
end;
PFieldClassTable = ^TFieldClassTable;
[ShortDescr]
List of classes used by the fields entries.
[Description]
List of classes used by the fields entries.
[RecordFields]
Count=2
1=Count:Smallint=Number of classes in the Classes array.
2=Classes:array [0..8191] of ^TPersistentClass=array of classes. The highest valid
index in this array is Count - 1.
[Quick Info]
Kind=Type
Unit=JclSysUtils
Category=Memory, Classes and Objects
SubCat=Class Manipulation\DMT
Author=Python;python@softhome.net
Delphi=4,5
[SeeAlso]
Count=1
1=TFieldEntry
<DECL>--------------------------------------------------------------------------
[Declaration]
TFieldEntry = packed record
  OffSet: Integer;
  IDX: Word;
  Name: ShortString;
end;
PFieldEntry = ^TFieldEntry;
[ShortDescr]
TFieldEntry contains information about a field of a class.
[Description]
TFieldEntry contains information about a field of a class.
[RecordFields]
Count=3
1=OffSet:Integer=OffSet of the field. TODO relative to what?
2=IDX:Word=Index for the classtype in the class list.
3=Name:ShortString=Name of the field.
[Quick Info]
Kind=Type
Unit=JclSysUtils
Category=Memory, Classes and Objects
SubCat=Class Manipulation\DMT
Author=Python;python@softhome.net
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function GetMethodTable(AClass: TClass): PMethodTable;
[ShortDescr]
Returns the method table of a class.
[Description]
GetMethodTable returns a pointer to the method table of the specified class.
The method table contains information about the published methods declared in the
class.
[Parameters]
Count=1
1=AClass:TClass=The class for which to retrieve the method table.
[Result]
Pointer to the method table. Do not modify this structure!
[Quick Info]
Unit=JclSysUtils
Category=Memory, Classes and Objects
SubCat=Class Manipulation\DMT
Author=Python;python@softhome.net
Delphi=4,5
[SeeAlso]
Count=1
1=TMethodTable;Types\TMethodTable
<DECL>--------------------------------------------------------------------------
[Declaration]
TMethodTable = packed record
  Count: Word;
  FirstEntry: <REF Target"TMethodEntry">TMethodEntry</REF>;
 {Entries: array [1..65534] of TMethodEntry;}
end;
PMethodTable = ^TMethodTable;
[ShortDescr]
Structure for the Method Table
[Description]
Method Table Structure. Gives a description of method, with Count the number
of methods, followed by count numbers of a variable length structure for each
entry.
[RecordFields]
Count=2
1=Count:Word=Number of TMethodEntries after count.
2=FirstEntry:TMethodEntry=First entry (if exists) of the method entries.
[SeeAlso]
Count=3
1=GetMethodTable
2=GetMethodEntry
3=TMethodEntry
[Quick Info]
Kind=Type
Unit=JclSysUtils
Category=Memory, Classes and Objects
SubCat=Class Manipulation\DMT
Author=Python;python@softhome.net
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
[Declaration]
function GetMethodEntry(MethodTable: <REF Target"TMethodTable">PMethodTable</REF>; Index: Integer): <REF Target"TMethodEntry">PMethodEntry</REF>;
[ShortDescr]
Returns an entry from the method table.
[Description]
GetMethodEntry returns the entry with the given index from the method table.
There is no checking performed that the given Index is valid.
[Parameters]
Count=2
1=MethodTable:PMethodTable=The method table to get the entry from
2=Index:Integer=The index of the entry to retrieve.
[Result]
Pointer to the method table entry from the method table with
the given index. Do not modify this structure!
[Quick Info]
Unit=JclSysUtils
Category=Memory, Classes and Objects
SubCat=Class Manipulation\DMT
Author=Python;python@softhome.net
Delphi=4,5
[SeeAlso]
Count=2
1=TMethodEntry;Types\TMethodEntry
2=GetMethodTable
<DECL>--------------------------------------------------------------------------
[Declaration]
TMethodEntry = packed record
  EntrySize: Word;
  Address: Pointer;
  Name: ShortString;
end;
PMethodEntry = ^TMethodEntry;
[ShortDescr]
Entry of a method table use by <REF>TMethodTable</REF>.
[Description]
Entry of a method table use by <REF>TMethodTable</REF>.
[RecordFields]
Count=3
1=EntrySize:Word=Size of the TMethodEntry. Use this to go to the next MethodEntry.
2=Address:Pointer=Pointer to the method.
3=Name:ShortString=Name of the method.
[Quick Info]
Kind=Type
Unit=JclSysUtils
Category=Memory, Classes and Objects
SubCat=Class Manipulation\DMT
Author=Python;python@softhome.net
Delphi=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure SetClassParent(AClass: TClass; NewClassParent: TClass);
[ShortDescr]
Modifies the class parent for the given class.
[Description]
Changes the parent of AClass to become NewClassParent. <P><FONT color=red>
Do <B>NOT</B> use this function.</FONT><BR> There should be
no need to use this function unless you are implementing a very dirty hack.<P>
This procedure changes the executable code (with the risk of completly destroying
your application) and uses WriteProcessMemory for this.</P>
The function is multiprocessor safe.
[Parameters]
Count=2
1=AClass:TClass=The class whose parent to change.
2=NewClassParent:TClass=The new parent for AClass.
[Quick Info]
Unit=JclSysUtils
Category=Memory, Classes and Objects
SubCat=Class Manipulation\Miscellanuous
Author=Python;python@softhome.net
Delphi=4,5
[SeeAlso]
Count=1
1=GetClassParent
<DECL>--------------------------------------------------------------------------
[Declaration]
function GetClassParent(AClass: TClass): TClass;
[ShortDescr]
Returns the parent of the class.
[Description]
Returns the parent class of the given class. That is, it returns the type of the
immediate ancestor of the specified class. This is the same as TObject.ClassParent.
[Parameters]
Count=1
1=AClass:TClass=The class for which to retrieve the parent class.
[Result]
The parent class (type of the immediate ancestor) of the specified class or nil
of the specified class is TObject.
[Quick Info]
Unit=JclSysUtils
Category=Memory, Classes and Objects
SubCat=Class Manipulation\Miscellanuous
Author=Python;python@softhome.net
Delphi=4,5
[SeeAlso]
Count=1
1=SetClassParent
<DECL>--------------------------------------------------------------------------
[Declaration]
function IsClass(Address: Pointer): Boolean;
[ShortDescr]
Returns whether a pointer points to a class.
[Description]
IsClass tests whether the specified pointer points to a class. Currently the
implementation only test whether the Self pointer actually points to the class itself.
[Parameters]
Count=1
1=Address:Pointer=The address to test. Note that this should be the equivalent
of Obj.ClassType where Obj is an instance of TObject or descendant class.
[Result]
The result is True if the Address is a class otherwise it is False.
[Quick Info]
Unit=JclSysUtils
Category=Memory, Classes and Objects
SubCat=Class Manipulation\Miscellanuous
Author=Python;python@softhome.net
Delphi=4,5
[SeeAlso]
Count=1
1=IsObject
<DECL>--------------------------------------------------------------------------
[Declaration]
function IsObject(Address: Pointer): Boolean;
[ShortDescr]
Returns whether a pointer points to an object.
[Description]
IsObject tests whether the specified pointer points to an object. Currently the
implementation only test whether the Self pointer actually points to the object itself.
[Parameters]
Count=1
1=Address:Pointer=The address to test. Note that this should be a TObject or
TObject descendant.
[Result]
The result is True if the Address is an object otherwise it is False.
[Quick Info]
Unit=JclSysUtils
Category=Memory, Classes and Objects
SubCat=Class Manipulation\Miscellanuous
Author=Python;python@softhome.net
Delphi=4,5
[SeeAlso]
Count=1
1=IsClass
<DECL>--------------------------------------------------------------------------
[Declaration]
ISafeGuard = interface
[ShortDescr]
Interface used to provide automatic resource destruction.
[Description]
ISafeGuard is the interface used by the Guard functions to provide automatic
resource destruction. A safeguard is an interface which gets associated with the
resource and ensures that when execution leaves the scope at which the safeguard
variable is declared, the resource is released (e.g. memory freed or object destroyed).
Since a safeguard is an interface and Delphi ensures that interfaces are released
even when an exception is raised, you can use a safeguard to ensure that a resource
always gets freed without having to explicitly code it. For example: <BR>
 <PRE class=syntax>
 <B>var</B><BR>
   SafeGuard: ISafeGuard;<BR>
   Strings: TStrings;<BR>
 <B>begin</B><BR>
   Strings := TStrings(Guard(TStringList.Create, SafeGuard));<BR>
   String.ReadFromFile('d:\delphi\jcl\source\JclBase.pas');<BR>
   // code to manipulate strings goes here<BR>
   Strings.SaveToFile('d:\delphi\jcl\source\JclBase.pas');<BR>
 <B>end</B>;<BR>
 </PRE>
In the above code, the TStrings object is associated with the SafeGuard. No matter
how the function terminates, the safeguard ensures that the TStrings object is
destroyed. Usually you will simply store the returned safeguard interface pointer
in a variable at the appropriate scope and forget about it. However, the ISafeGuard
interface does provide some additional functionality which may be useful at times.
[Quick Info]
Unit=JclSysUtils
Category=Memory, Classes and Objects
Category=Memory, Classes and Objects
SubCat=Guards\ISafeGuard
Author=Rudy Velthuis;rvelthuis@gmx.de
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=3
1=Guard
2=GuardGetMem
3=GuardAllocMem
<DECL>--------------------------------------------------------------------------
[Declaration]
function ReleaseItem: Pointer;
[ShortDescr]
Disassociates the resource from the safeguard.
[Description]
ReleaseItem returns a pointer to the associated resource and then disassociates it
with the safeguard. This means that when execution leaves the scope in which
the interface variable is declared, the resource will not be automatically freed.
By using ReleaseItem you are handed back the responsibility to explicitly release
the resource.
[Result]
Pointer to the resource associated with the safeguard.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclSysUtils
Category=Memory, Classes and Objects
SubCat=Guards\ISafeGuard
Author=Rudy Velthuis;rvelthuis@gmx.de
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function GetItem: Pointer;
[ShortDescr]
Returns a pointer to the resource associated with the safeguard.
[Description]
The GetItem method returns a pointer to the resource associated with the safeguard.
Usually you will hold on to this pointer when you associated it with the safeguard,
however you can use the safeguard as the storage for the resource pointer itself.
[Result]
Pointer to the resource associated with the safeguard.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclSysUtils
Category=Memory, Classes and Objects
SubCat=Guards\ISafeGuard
Author=Rudy Velthuis;rvelthuis@gmx.de
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure FreeItem;
[ShortDescr]
Frees the memory of the associated resource.
[Description]
The FreeItem method frees the resource associated with the safeguard. You should
never call this method directly, it is called automatically when execution leaves
the scope in which the interface variable is declared.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclSysUtils
Category=Memory, Classes and Objects
SubCat=Guards\ISafeGuard
Author=Rudy Velthuis;rvelthuis@gmx.de
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
property Item: Pointer read GetItem;
[ShortDescr]
Returns a pointer to the protected resource.
[Description]
The Item property returns a pointer to the associated resource protected by the
safeguard. You'll have to cast the pointer to the appropriate type.
[Quick Info]
Kind=Property
Visibility=Public
Unit=JclSysUtils
Category=Memory, Classes and Objects
SubCat=Guards\ISafeGuard
Author=Rudy Velthuis;rvelthuis@gmx.de
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function Guard(Mem: Pointer; out SafeGuard: ISafeGuard): Pointer; overload;
function Guard(Obj: TObject; out SafeGuard: ISafeGuard): TObject; overload;
[ShortDescr]
Associates a resource, pointer or object reference, with a safeguard.
[Description]
Associates a resource, pointer or object reference, with a safeguard. A safeguard
is an interface which gets associated with the resource and ensures that when
execution leaves the scope at which the safeguard variable is declared, the
resource is released (e.g. memory freed or object destroyed). Since a safeguard is
an interface and Delphi ensures that interfaces are released even when an exception
is raised, you can use a safeguard to ensure that a resource always gets freed
without having to explicitly code it. For example: <BR>
 <PRE class=syntax>
 <B>var</B><BR>
   SafeGuard: ISafeGuard;<BR>
   Strings: TStrings;<BR>
 <B>begin</B><BR>
   Strings := TStrings(Guard(TStringList.Create, SafeGuard));<BR>
   String.ReadFromFile('d:\delphi\jcl\source\JclBase.pas');<BR>
   // code to manipulate strings goes here<BR>
   Strings.SaveToFile('d:\delphi\jcl\source\JclBase.pas');<BR>
 <B>end;</B><BR>
 </PRE>
In the above code, the TStrings object is associated with the SafeGuard. No matter
how the function terminates, the safeguard ensures that the TStrings object is
destroyed. Usually you will simply store the returned safeguard interface pointer
in a variable at the appropriate scope and forget about it. However, the ISafeGuard
interface does provide some additional functionality which may be useful at times.
See the <REF>ISafeGuard</REF> interface for more information.
[Parameters]
Count=2
1=Mem:Pointer=The pointer (or object in the case of the overloaded Guard function)
which to associate with the safeguard.
[Result]
Copy of the Mem (or Obj) parameter. This is merely a convenience which allows
you to create the resource embedded inside the function call as demonstrated above.
[Quick Info]
Unit=JclSysUtils
Category=Memory, Classes and Objects
SubCat=Guards
Author=Rudy Velthuis;rvelthuis@gmx.de
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=3
1=GuardGetMem
2=GuardAllocMem
3=ISafeGuard
<DECL>--------------------------------------------------------------------------
[Declaration]
function GuardGetMem(Size: Cardinal; out SafeGuard: ISafeGuard): Pointer;
[ShortDescr]
Allocates a specified amount of memory and associates it with a safeguard.
[Description]
GuardGetMem allocates the specified amount of memory and associates it with a
safeguard. A pointer to the allocated memory is returned as the function result.
By using GuardGetMem you ensure that no matter how the scope in which the memory
is allocated is left (e.g. by an exception or explicit Exit), the memory will be
freed. See <REF>Guard</REF> for a more detailed description.
[Parameters]
Count=2
1=Size:Cardinal=Size, in bytes, of the memory to allocate. This memory is allocated
using the standard GetMem function and as such is uninitialized.
2=SafeGuard:ISafeGuard=Receives a pointer to the ISafeGuard interface which is
associated with the allocated memory.
[Result]
Pointer to the block of allocated memory.
[Quick Info]
Unit=JclSysUtils
Category=Memory, Classes and Objects
SubCat=Guards
Author=Rudy Velthuis;rvelthuis@gmx.de
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=3
1=Guard
2=GuardAllocMem
3=ISafeGuard
<DECL>--------------------------------------------------------------------------
[Declaration]
function GuardAllocMem(Size: Cardinal; out SafeGuard: ISafeGuard): Pointer;
[ShortDescr]
Allocates a specified amount of memory and associates it with a safeguard.
[Description]
GuardGetMem allocates the specified amount of memory and associates it with a
safeguard. This function is identical to GuardGetMem except that the function
uses AllocMem internally, as opposed to GetMem. As such the allocated memory is
initialized with all zeros. A pointer to the allocated memory is returned as the
function result. By using GuardGetMem you ensure that no matter how the scope in
which the memory is allocated is left (e.g. by an exception or explicit Exit), the
memory will be freed. See <REF>Guard</REF> for a more detailed description.
[Parameters]
Count=2
1=Size:Cardinal=Size, in bytes, of the memory to allocate. This memory is allocated
using the standard AllocMem function and as such is initialized to all zeros.
2=SafeGuard:ISafeGuard=Receives a pointer to the ISafeGuard interface which is
associated with the allocated memory.
[Result]
Pointer to the block of allocated memory.
[Quick Info]
Unit=JclSysUtils
Category=Memory, Classes and Objects
SubCat=Guards
Author=Rudy Velthuis;rvelthuis@gmx.de
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=3
1=Guard
2=GuardGetMem
3=ISafeGuard
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure ClearObjectList(List: TList);
[ShortDescr]
Clears the contents of a TList which contains objects.
[Description]
ClearObjectList clears the contents of the specified list. The routine assumes that each
item in the list is a TObject descendant and frees these objects before removing
them from the list. If the list contains items other than TObject descendants,
the result is unpredictable (likely an access violation will occur).
[Parameters]
Count=1
1=List:TList=The list to clear.
[Quick Info]
Unit=JclSysUtils
Category=Memory, Classes and Objects
SubCat=Miscellanuous
Author=Heri Bender;HBender@Ergonomics.ch
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=1
1=FreeObjectList
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure FreeObjectList(var List: TList);
[ShortDescr]
Clears the contents of a TList which contains objects.
[Description]
FreeObjectList clears the contents of the specified list and then frees the list itself.
The routine assumes that each item in the list is a TObject descendant and frees
these objects before removing them from the list. If the list contains items other
than TObject descendants, the result is unpredictable (likely an access violation
will occur).
[Parameters]
Count=1
1=List:TList=The list to free.
[Quick Info]
Unit=JclSysUtils
Category=Memory, Classes and Objects
SubCat=Miscellanuous
Author=Heri Bender;HBender@Ergonomics.ch
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=1
1=ClearObjectList
<DECL>--------------------------------------------------------------------------
[Declaration]
TModuleHandle = HINST;
[ShortDescr]
OS independent type for loaded modules.
[Description]
OS independent type for loaded modules.
[Quick Info]
Kind=Type
Unit=JclSysUtils
Category=Base Services
SubCat=Dynamic loading
Author=Robert Marquardt;robert_marquardt@gmx.de
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
INVALID_MODULEHANDLE_VALUE = TModuleHandle(0);
[ShortDescr]
OS independent value for variables of type <REF>TModuleHandle</REF>.
[Description]
OS independent value for variables of type <REF>TModuleHandle</REF>.
Denotes that the variable does not contain a valid handle to a module.
[Quick Info]
Kind=Constant
Unit=JclSysUtils
Category=Base Services
SubCat=Dynamic loading
Author=Robert Marquardt;robert_marquardt@gmx.de
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function LoadModule(var Module: TModuleHandle; FileName: string): Boolean;
[ShortDescr]
Loads the dynamic module (DLL) from file FileName.
[Description]
The dynamic module (DLL) is loaded into memory and its initialization code 
is executed. This is an OS independent replacement for LoadLibrary.
The function does nothing but reports success if Module is not initialized
to INVALID_MODULEHANDLE_VALUE to prevent multiple loads.
[Parameters]
Count=2
1=Module:TModuleHandle=Receives the handle of the loaded module.
2=FileName:string=File name of the module to load.
[Result]
The function returns True if the module could be loaded False otherwise.
[Quick Info]
Unit=JclSysUtils
Category=Base Services
SubCat=Dynamic loading
Author=Robert Marquardt;robert_marquardt@gmx.de
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=2
1=LoadModuleEx
2=UnloadModule
<DECL>--------------------------------------------------------------------------
[Declaration]
function LoadModuleEx(var Module: TModuleHandle; FileName: string; Flags: Cardinal): Boolean;
[ShortDescr]
Loads the dynamic module (DLL) from file FileName.
[Description]
The dynamic module (DLL) is loaded into memory and its initialization code 
is executed if the flags allow that.
This is an OS independent replacement for LoadLibraryEx.
Flags are OS dependent. For Windows its the flags of LoadLibraryEx.
The function does nothing but reports success if Module is not initialized
to INVALID_MODULEHANDLE_VALUE to prevent multiple loads.
[Parameters]
Count=3
1=Module:TModuleHandle=Receives the handle of the loaded module.
2=FileName:string=File name of the module to load.
3=Flags:Cardinal=Additional loading flags.
[Result]
[Quick Info]
Unit=JclSysUtils
Category=Base Services
SubCat=Dynamic loading
Author=Robert Marquardt;robert_marquardt@gmx.de
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=2
1=LoadModule
2=UnloadModule
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure UnloadModule(var Module: TModuleHandle);
[ShortDescr]
Unloads a dynamic module (DLL) from memory.
[Description]
Unloads a dynamic module (DLL) loaded with <REF>LoadModule</REF> or 
<REF>LoadModuleEx</REF>. Module is set to INVALID_MODULEHANDLE_VALUE
after unloading of the module.
The function does nothing if Module contains already INVALID_MODULEHANDLE_VALUE
to allow multiple calls to UnloadModule without errors.
contains INVALID_MODULEHANDLE_VALUE to
[Parameters]
Count=1
1=Module:TModuleHandle=Contains the handle of the module to unload.
[Result]
[Quick Info]
Unit=JclSysUtils
Category=Base Services
SubCat=Dynamic loading
Author=Robert Marquardt;robert_marquardt@gmx.de
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=2
1=LoadModule
2=LoadModuleEx
<DECL>--------------------------------------------------------------------------
[Declaration]
function GetModuleSymbol(Module: TModuleHandle; SymbolName: string): Pointer;
[ShortDescr]
Gives access to the exported symbol SymbolName from the loaded module Module.
[Description]
Gives access to the exported symbol SymbolName from the loaded module Module.
Normally this is the name of an exported function.
[Parameters]
Count=2
1=Module:TModuleHandle=Handle to the loaded module.
2=SymbolName:string=Name of the exported symbol to access.
[Result]
The pointer to the exported symbol. Normally this is a "pointer to function"
as C calls it. In Pascal its a function type. nil is returned for symbols
not contained in the module.
[Quick Info]
Unit=JclSysUtils
Category=Base Services
SubCat=Dynamic loading
Author=Robert Marquardt;robert_marquardt@gmx.de
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=1
1=GetModuleSymbolEx
<DECL>--------------------------------------------------------------------------
[Declaration]
function GetModuleSymbolEx(Module: TModuleHandle; SymbolName: string; var Accu: Boolean): Pointer;
[ShortDescr]
Gives access to the exported symbol SymbolName from the loaded module Module.
[Description]
Gives access to the exported symbol SymbolName from the loaded module Module.
Normally this is the name of an exported function.
Accu is updated by "Accu := Accu and (Result <> nil);". This allows to
call GetModuleSymbolEx for many symbols and render a global result for
successfully accessing all symbols.
[Parameters]
Count=3
1=Module:TModuleHandle=Handle to the loaded module.
2=SymbolName:string=Name of the exported symbol to access.
3=Accu:Boolean=Success accumulator to be updated.
[Result]
The pointer to the exported symbol. Normally this is a "pointer to function"
as C calls it. In Pascal its a function type. nil is returned for symbols
not contained in the module and Accu will contain False.
[Quick Info]
Unit=JclSysUtils
Category=Base Services
SubCat=Dynamic loading
Author=Robert Marquardt;robert_marquardt@gmx.de
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=1
1=GetModuleSymbol
<DECL>--------------------------------------------------------------------------
[Declaration]
function ReadModuleData(Module: TModuleHandle; SymbolName: string; var Buffer; Size: Cardinal): Boolean;
[ShortDescr]
Reads the data of an exported variable.
[Description]
ReadModuleData copies the contents of the exported variable SymbolName to
Buffer. Size tells the amount of bytes to be copied.
This function allows to access variables in dynamic modules which are
not directly accessible in Pascal.
Beware! You are accessing the DLL memory image directly.
Be sure to access a variable not a function and be sure
to read the correct amount of data.
[Parameters]
Count=4
1=Module:TModuleHandle=Handle to the loaded module.
2=SymbolName:string=Name of the exported variable to access.
3=Buffer=The untyped destination of the copy.
4=Size:Cardinal=Amount of bytes to copy.
[Result]
[Quick Info]
Unit=JclSysUtils
Category=Base Services
SubCat=Dynamic loading
Author=Robert Marquardt;robert_marquardt@gmx.de
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=1
1=WriteModuleData
<DECL>--------------------------------------------------------------------------
[Declaration]
function WriteModuleData(Module: TModuleHandle; SymbolName: string; var Buffer; Size: Cardinal): Boolean;
[ShortDescr]
Writes the data of an exported variable.
[Description]
WriteModuleData copies the contents of Buffer to the exported variable SymbolName.
Size tells the amount of bytes to be copied.
This function allows to set variables in dynamic modules which are
not directly accessible in Pascal.
BEWARE! You are accessing the DLL memory image directly.
Be sure to access a variable not a function and be sure
to write the correct amount of data.
The changes are not persistent. They get lost when the
DLL is unloaded.
[Parameters]
Count=4
1=Module:TModuleHandle=Handle to the loaded module.
2=SymbolName:string=Name of the exported variable to access.
3=Buffer=The untyped source of the copy.
4=Size:Cardinal=Amount of bytes to copy.
[Result]
[Quick Info]
Unit=JclSysUtils
Category=Base Services
SubCat=Dynamic loading
Author=Robert Marquardt;robert_marquardt@gmx.de
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=1
1=ReadModuleData
