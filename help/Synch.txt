<DECL>--------------------------------------------------------------------------
[Declaration]
function QueryCriticalSection(CS: TJclCriticalSection; var Info: TRTLCriticalSection): Boolean;
[ShortDescr]
Returns information about a critical section object.
[Description]
QueryCriticalSection returns information about the critical section object specified
by CS. The function returns a TRTLCriticalSection record which is defined in
Windows.pas.
[Parameters]
Count=2
1=CS:TJclCriticalSection=The critical section object about which to return information.
2=Info:TRTLCriticalSection=Receives information about the critical section. See Windows.pas
for the declaration of this record, most fields are self-explanatory.
[Result]
If the function succeeds it returns True, otherwise it returns False. In the latter
case the contents of the Info parameter are undefined.
[Notes]
Count=1
1=This function relies on undocumented information.
[Quick Info]
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\Debugging
Windows NT/2000=Requires Windows NT 4.0 or later.
Windows 95/98=Unsupported
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function QueryEvent(Handle: THandle; var Info: TEventInfo): Boolean;
[ShortDescr]
Returns information about an event object.
[Description]
QueryEvent returns information about the event object specified by Handle. The
information is returned in a TEventInfo record and contains members to indicate
the kind of event and whether it is signaled.
[Parameters]
Count=2
1=Handle:THandle=Handle of the event object for which you want information.
2=Info:TEventInfo=Received information about the event. TEventInfo is defined as:
  <PRE class=syntax>
  TEventInfo = <B>record</B><BR>
    EventType: Longint;<BR>
    Signaled: LongBool;<BR>
  <B>end</B>;
  </PRE>
The following table describes the members of this record:
  <TABLE>
  <TR VALIGN="top">
  <TH align=left width=25%>Member</TH>
  <TH align=left width=25%>Type</TH>
  <TH align=left width=50%>Description</TH>
  </TR>
  <TR VALIGN="top">
  <TD width=25%>EventType</TD>
  <TD width=25%>Longint</TD>
  <TD width=50%>If the event is a manual-reset event this member is 0. If the event is an auto-reset event this member is non-zero.</TD>
  </TR>
  <TR VALIGN="top">
  <TD width=25%>Signaled</TD>
  <TD width=25%>LongBool</TD>
  <TD width=50%>True if the event is in the signaled state, False if its in the non-signaled state</TD>
  </TR>
  </TABLE>
[Result]
If the function succeeds it returns True, otherwise it returns False. In the latter
case the contents of the Info parameter are undefined.
[Notes]
Count=1
1=This function relies on undocumented information and uses an undocumented API call.
[Quick Info]
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\Debugging
Windows NT/2000=Requires Windows NT 4.0 or later.
Windows 95/98=Unsupported
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function QueryTimer(Handle: THandle; var Info: TTimerInfo): Boolean;
[ShortDescr]
Returns information about a timer object.
[Description]
QueryTimer returns information about the timer object specified by Handle. The
information is returned in a TTimerInfo record and contains members to indicate
whether the timer is signaled or how much time remains until the timer becomes
signaled.
[Parameters]
Count=2
1=Handle:THandle=Handle of the timer object for which you want information.
2=Info:TTimerInfo=Received information about the timer. TTimerInfo is defined as:
  <PRE class=syntax>
  TTimerInfo = <B>record</B><BR>
    Remaining: TLargeInteger;<BR>
    Signaled: LongBool;<BR>
  <B>end</B>;
  </PRE>
The following table describes the members of this record:
  <TABLE>
  <TR VALIGN="top">
  <TH align=left width=25%>Member</TH>
  <TH align=left width=25%>Type</TH>
  <TH align=left width=50%>Description</TH>
  </TR>
  <TR VALIGN="top">
  <TD width=25%>Remaining</TD>
  <TD width=25%>TLargeInteger</TD>
  <TD width=50%>The time, in 100 ns intervals, until the timer becomes signaled.</TD>
  </TR>
  <TR VALIGN="top">
  <TD width=25%>Signaled</TD>
  <TD width=25%>LongBool</TD>
  <TD width=50%>True if the timer is currently signaled.</TD>
  </TR>
  </TABLE>
[Result]
If the function succeeds it returns True, otherwise it returns False. In the latter
case the contents of the Info parameter are undefined.
[Notes]
Count=1
1=This function relies on undocumented information and uses an undocumented API call.
[Quick Info]
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\Debugging
Windows NT/2000=Requires Windows NT 4.0 or later.
Windows 95/98=Unsupported
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function QuerySemaphore(Handle: THandle; var Info: TSemaphoreCounts): Boolean;
[ShortDescr]
Returns information about a semaphore object.
[Description]
QuerySemaphore returns information about the semaphore object specified by Handle. The
information is returned in a TSemaphoreInfo record and contains members to indicate
the semaphores' current and maximum count.
[Parameters]
Count=2
1=Handle:THandle=Handle of the semaphore object for which you want information.
2=Info:TSemaphoreInfo=Received information about the event. TSemaphoreInfo is defined as:
  <PRE class=syntax>
  TSemaphoreCounts = <B>record</B><BR>
    CurrentCount: Longint;<BR>
    MaximumCount: Longint;<BR>
  <B>end</B>;
  </PRE>
The following table describes the members of this record:
  <TABLE>
  <TR VALIGN="top">
  <TH align=left width=25%>Member</TH>
  <TH align=left width=25%>Type</TH>
  <TH align=left width=50%>Description</TH>
  </TR>
  <TR VALIGN="top">
  <TD width=25%>CurrentCount</TD>
  <TD width=25%>Longint</TD>
  <TD width=50%>The current count of the semaphore object.</TD>
  </TR>
  <TR VALIGN="top">
  <TD width=25%>MaximumCount</TD>
  <TD width=25%>Longint</TD>
  <TD width=50%>The maximum count of the semaphore object as specified when it was constructed.</TD>
  </TR>
  </TABLE>
[Result]
If the function succeeds it returns True, otherwise it returns False. In the latter
case the contents of the Info parameter are undefined.
[Notes]
Count=1
1=This function relies on undocumented information and uses an undocumented API call.
[Quick Info]
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\Debugging
Windows NT/2000=Requires Windows NT 4.0 or later.
Windows 95/98=Unsupported
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function QueryMutex(Handle: THandle; var Info: TMutexInfo): Boolean;
[ShortDescr]
Returns information about a mutex object.
[Description]
QueryMutex returns information about the mutex object specified by Handle. The
information is returned in a TMutexInfo record and contains members to indicate
whether the mutex is signaled and owned.
[Parameters]
Count=2
1=Handle:THandle=Handle of the mutex object for which you want information.
2=Info:TMutexInfo=Received information about the mutex. TMutexInfo is defined as:
  <PRE class=syntax>
  TMutexInfo = <B>record</B><BR>
    SignalState: Longint;<BR>
    Owned: Boolean;<BR>
    Abandoned: Boolean;<BR>
  <B>end</B>;
  </PRE>
The following table describes the members of this record:
  <TABLE>
  <TR VALIGN="top">
  <TH align=left width=25%>Member</TH>
  <TH align=left width=25%>Type</TH>
  <TH align=left width=50%>Description</TH>
  </TR>
  <TR VALIGN="top">
  <TD width=25%>SignalState</TD>
  <TD width=25%>Longint</TD>
  <TD width=50%>Indicates the state of the mutex. If this member is greater than
                0 the mutex is signaled. A value smaller than 0 indicates the
                number of times the mutex was recursively acquired.</TD>
  </TR>
  <TR VALIGN="top">
  <TD width=25%>Owned</TD>
  <TD width=25%>Boolean</TD>
  <TD width=50%>True if the mutex is currently owned by a thread.</TD>
  </TR>
  <TR VALIGN="top">
  <TD width=25%>Abandoned</TD>
  <TD width=25%>Boolean</TD>
  <TD width=50%>True if the mutex was abandoned (thread exited while owning the mutex).</TD>
  </TR>
  </TABLE>
[Result]
If the function succeeds it returns True, otherwise it returns False. In the latter
case the contents of the Info parameter are undefined.
[Notes]
Count=1
1=This function relies on undocumented information and uses an undocumented API call.
[Quick Info]
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\Debugging
Windows NT/2000=Requires Windows NT 4.0 or later.
Windows 95/98=Unsupported
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
TJclMultiReadExclusiveWrite = class (TObject)
[ShortDescr]
Allows multiple readers but only one writer.
[Description]
TJclMultiReadExclusiveWrite is a synchronization object similar to a critical section.
It protects some resource by controlling access to it. Unlike a critical section
however, a TJclMultiReadExclusiveWrite allows multiple threads access to the
protected resource. The threads that request access are separated into two logical
groups called Readers and Writers. The class allows only one writer to have access
to the resource at any time. All other threads, both readers and writers must
wait until the resource is released. Readers however can access the resource
simultaneously. When one or more readers have been granted access, all writers are blocked.
The distinction between readers and writers is made based on how the threads
request access to the resource. Readers use the BeginRead and EndRead methods
while Writers use BeginWrite and EndWrite. It is up to the application to define
what readers and writers really are.<P>
In addition to the above, the class allows readers to be promoted to writers and
it allows the application to tune the access. If you so wish you can have the
class favor readers over writers, vice versa or treat them equally. Note that
if you have the class favor one over the other than the 'other' may never get
access to the resource depending on the details of your application and pure
coincidence (due to timing issues which are beyond control of the class).<P>
Note that the implementation of this class was inspired mainly by Jeffrey Richters
CMREW class presented in his book "Programming applications for Microsoft Windows,
4th edition". 
[Quick Info]
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclMultiReadExclusiveWrite
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
constructor Create(Preferred: TMrewPreferred); virtual;
[ShortDescr]
Creates an instance of TJclMultiReadExclusiveWrite.
[Description]
Creates an instance of TJclMultiReadExclusiveWrite.
[Parameters]
Count=1
1=Preferred:TMrewPreferred=Denotes whether the class should favor readers over
writers, vice versa or treat them equally. See TMrewPreferred for more information.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclMultiReadExclusiveWrite
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
destructor Destroy; override;
[ShortDescr]
Destroys the instance of TJclMultiReadExclusiveWrite.
[Description]
Destroys the instance of TJclMultiReadExclusiveWrite.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclMultiReadExclusiveWrite
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure BeginRead;
[ShortDescr]
Allows a thread read-access to the protected resource, blocking until the access can be granted.
[Description]
BeginRead allows a thread to gain read-access to the protected resource. This
method will block the calling thread until read-access can be granted. After the
thread has been granted access other threads may request, and be granted, read-access
to the protected resource but write access requests will be denied until all
threads that hold read-access have finished using the resource. A thread which
has been granted read-access must eventually call <REF>EndRead</REF> to signal that it
has finished using the resource. Note that read-access can be promoted to
write-access by calling BeginWrite, however, both the calls to BeginRead and
BeginWrite must have a matching call to EndRead and EndWrite respectively.
It is safe to call BeginRead while already holding read-access, it merely
increments a recursion count. If you call BeginRead multiple times you must also
call <REF>EndRead</REF> multiple times. That is, the calls to BeginRead and
EndRead must be balanced. Note that even if the class has only granted access
to readers while BeginRead is called, the calling thread may still be blocked
depending on the Preferred value passed to the constructor.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclMultiReadExclusiveWrite
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=3
1=EndRead
2=BeginWrite
3=EndWrite
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure BeginWrite;
[ShortDescr]
Allows a thread write-access to the protected resource, blocking until the access can be granted.
[Description]
BeginWrite allows a thread to gain write-access to the protected resource. This
method will block the calling thread until write-access can be granted. After a
thread has been granted write-access, all other threads requesting access, either
read or write, will be denied access until the thread currently holding write-access
calls <REF>EndWrite</REF>.
Note that it is legal to request read-access while holding write-access, however,
the thread will not be granted read-access, instead its recursion count is
incremented and write-access is preserved. It is safe to call BeginWrite while
already holding write-access, it merely increments a recursion count. If you call
BeginWrite multiple times you must also call <REF>EndWrite</REF> multiple times.
That is, the calls to BeginWrite and EndWrite must be balanced.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclMultiReadExclusiveWrite
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=3
1=EndRead
2=BeginRead
3=EndWrite
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure EndRead;
[ShortDescr]
Signals that the thread has finished reading from the resource.
[Description]
EndRead signals that the thread holding read-access to the protected resource has
finished reading from the resource. You must call EndRead once for each time you
called <REF>BeginRead</REF>. Even though it is safe to call EndRead while not
holding read-access you should not do so. The same is true for calling EndWrite
while currently holding read-access. Once all threads have released their
read-access locks, currently blocked threads are released. The exact algorithm
used to determine which threads to release depends on the Preferred value passed
to the constructor.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclMultiReadExclusiveWrite
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure EndWrite;
[ShortDescr]
Signals that the thread has finished writing to the resource.
[Description]
EndWrite signals that the thread holding write-access to the protected resource has
finished writing to the resource. You must call EndWrite once for each time you
called <REF>BeginWrite</REF>. Even though it is safe to call EndWrite while not
holding write-access you should not do so. The same is true for calling EndRead
while currently holding write-access. Once the calls to BeginWrite and EndWrite
are balanced so that the write-lock is released, other blocked threads are
released. The exact algorithm used to determine which threads to release depends
on the Preferred value passed to the constructor.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclMultiReadExclusiveWrite
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
TJclOptex = class (TObject)
[ShortDescr]
Optimized Mutex
[Description]
Optex stands for Optimized Mutex. It's a synchronization object which holds middle
ground between a Win32 Mutex and a Critical Section. It provides the speed and
functionality similar to a critical section but has the additional property
that it can be used across process boundaries (like a mutex). This code was originally
written by Jeffrey Richter and is presented, and fully explained, in his excellent,
must-have book "Programming applications for Microsoft Windows, 4th edition".
This book was formerly titled "Advanced Windows". The Object Pascal class that
is included in the JCL is <U>almost</U> a straight port from that code. Any bugs
in this class were most likely introduced by these modifications or an incorrect
port.
[Quick Info]
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclOptex
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
property Existed: Boolean read FExisted;
[ShortDescr]
Returns whether the optex existed.
[Description]
The Existed property returns whether the Optex was newly created (Existed is False)
or already existed during construction (Existed is True). In this latter case the
Optex was already created by another process. This tells you only that the Optex
existed during execution of the constructor. There is no way to find out whether
another process still has the Optex open.
[Quick Info]
Kind=Property
Visibility=Public
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclOptex
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
property Name: string read FName;
[ShortDescr]
Name of the object.
[Description]
The Name property returns the name of the Optex as specified in the constructor.
[Quick Info]
Kind=Property
Visibility=Public
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclOptex
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
property SpinCount: Integer read GetSpinCount write SetSpinCount;
[ShortDescr]
Sets the spincount.
[Description]
The SpinCount property allows you to query the current value of the spincount of
the optex or to set a new value. Note that the spincount value is shared between
all processes that use the same optex. This is not True for distinct optex objects.
[Quick Info]
Kind=Property
Visibility=Public
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclOptex
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
property UniProcess: Boolean read GetUniProcess;
[ShortDescr]
Returns whether the optex can be shared between processes.
[Description]
Returns whether the optex can be used in the process only or can be shared
between processes. This is directly related to whether or not you specified a
name for the optex during construction. If you specified a name, the optex can
be shared and this property will be False, otherwise it will be True. Note that
this tells you nothing about whether or not multiple processes are actually using
the optex, only if they can.
[Quick Info]
Kind=Property
Visibility=Public
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclOptex
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
constructor Create(const Name: string = ''; SpinCount: Integer = 4000);
[ShortDescr]
Creates an instance of the Optex class.
[Description]
The Create constructor creates an instance of the Optex class. If you intend to
use the optex in the current process only you should specify an empty string for
the name parameter. If you want to share it between processes you must give the
optex a name.
[Parameters]
Count=2
1=Name:string=Name for the Optex. When you want to share the Optex between multiple
processes you must give it a name. The second process can then open the Optex
by calling Create with the same name.
2=SpinCount:Integer=The spincount for the optex object. Conceptually
the optex will try to attempt ownership of the optex for
SpinCount number of times when the Enter method is called. If the optex
is still not available after these attempts the thread enters a wait state until
the optex is released. On a single-processor system this parameter is
ignored and the optex will use 0 internally. This means the optex
will never spin before waiting on the kernel event. This makes sense since
the optex could never be released while the thread was spinning (and 
thus monopolizing the processor). Note that the spincount is effective for
all processes that use the same, named optex. If one process changes the spincount
this takes effect in all the other processes immediately as well.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclOptex
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
destructor Destroy; override;
[ShortDescr]
Destroys the Optex instance.
[Description]
The Destroy destructor destroys the Optex instance for which it is called. If the
Optex is shared between multiple processes only this instance is destroyed and
other processes can continue to use the Optex.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclOptex
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure Enter;
[ShortDescr]
Enters the Optex.
[Description]
Enter attempts to get access to the optex, this is referred to as
acquiring ownership of the optex. Only one thread can own the optex
at any time. If the optex is currently owned by a different
thread the function blocks until the critical section becomes free. After
acquiring ownership of the optex you must release it as soon as you
are done with it by calling the <REF>Leave</REF> method. Although only one
thread can own the optex, a single thread can own the optex more than once. 
This means you can call Enter multiple times. However, calls to Enter
and Leave must be balanced: you must call Leave for each time you call Enter.
Note that if the process is running on a multiprocessor system and the optex
is currently owned by anther thread, the Enter method spins in a loop SpinCount
number of times, trying to acquire the optex. If the optex becomes available
before the loop terminated the thread acquires the optex and returns. On a
single-processor system the method only tries one time.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclOptex
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure Leave;
[ShortDescr]
Releases ownership of the optex.
[Description]
The Release method releases ownership of the optex previously acquired
by a call to the <REF>Enter</REF> method. After a call to Release the optex
is free to be acquired by a different thread. If you called Enter multiple
times the optex will not be released until the last, balancing call
to Release.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclOptex
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function TryEnter: Boolean;
[ShortDescr]
Attempts to Enter the critical section.
[Description]
TryEnter attempts to acquire ownership of the optex object. However, unlike
the <REF>Enter</REF> method, this method immediately returns if the optex cannot
be acquired the first time around.
[Result]
If ownership of the optex object is acquired the function returns
True. If ownership could not be acquired because the optex was already
owned by a different thread the function returns False. In this latter case you
must take care <u>not</U> to call Release.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclOptex
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
TJclWaitableTimer = class (<REF Target"..\TJclDispatcherObject\TJclDispatcherObject">TJclDispatcherObject</REF>)
[ShortDescr]
Wrapper for a Win32 Waitable Timer object.
[Description]
TJclWaitableTimer is a wrapper for a Win32 Waitable Timer object.
[Quick Info]
BCB=3,4,5
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclWaitableTimer
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 98 or later.
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function Cancel: Boolean;
[ShortDescr]
Deactivates the waitable timer.
[Description]
The Cancel method stops the timer before it can be set to the signaled state and
cancels any outstanding APC's. Threads that are waiting on the timer remain waiting
until the timer is reactivated with <REF>SetTimer</REF>. If the Timer is already
in the signaled state it remains signaled.
[Result]
If the function succeeds it returns True, otherwise it returns False. In the latter
case you can call GetLastError to get extended error information.
[Quick Info]
Kind=Method
Visibility=Public
BCB=3,4,5
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclWaitableTimer
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 98 or later.
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function SetTimer(const DueTime: Int64; Period: Longint; Resume: Boolean): Boolean;
[ShortDescr]
Activates the timer.
[Description]
The SetTimer method activates the timer. When the DueTime arrives the timer is
set to the signaled state and threads waiting for the timer using one of the
WaitXxx functions become eligible for execution. If the timer was already active
(in its signaled state) the timer is reactivated with the new parameters without
releasing any waiting threads.
[Parameters]
Count=3
1=DueTime:Int64=Specifies when the timer becomes signaled. A positive value
indicates an absolute time in UTC and TFileTime format (you must convert a time
expressed in UTC from a TFileTime to an Int64). A negative value indicates a
relative time in 100 nanosecond intervals.
2=Period:Longint=Period of the timer in milliseconds. A 0 period causes the timer
to become signaled only once while a value greater than 0 causes the timer to
periodically become signaled. Note that a periodic manual-reset timer remains
in the signaled state until it is explicitly reset.
3=Resume:Boolean=Specifies whether to restore a system in suspended power
conservation mode when the timer state is set to signaled.
[Result]
If the function succeeds the result is True, otherwise it is False. In the latter
case you can call GetLastError to get extended error information. Note that if
you set Resume to True on a platform which doesn't support this, the method
succeeds (returns True) but calling GetLastError will return ERROR_NOT_SUPPORTED.
[Quick Info]
Kind=Method
Visibility=Public
BCB=3,4,5
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclWaitableTimer
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 98 or later.
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function SetTimerApc(const DueTime: Int64; Period: Longint; Resume: Boolean; Apc: TFNTimerAPCRoutine; Arg: Pointer): Boolean;
[ShortDescr]
Activates the timer.
[Description]
The SetTimerApc method activates the timer. When the DueTime arrives the timer is
set to the signaled state and threads waiting for the timer using one of the
WaitXxx functions become eligible for execution. Additionally the specified Apc
routine is called in the context of the thread that called SetTimerApc.
If the timer was already active (in its signaled state) the timer is reactivated
with the new parameters without releasing any waiting threads.
Count=5
1=DueTime:Int64=Specifies when the timer becomes signaled. A positive value
indicates an absolute time in UTC and TFileTime format (you must convert a time
expressed in UTC from a TFileTime to an Int64). A negative value indicates a
relative time in 100 nanosecond intervals.
2=Period:Longint=Period of the timer in milliseconds. A 0 period causes the timer
to become signaled only once while a value greater than 0 causes the timer to
periodically become signaled. Note that a periodic manual-reset timer remains
in the signaled state until it is explicitly reset.
3=Resume:Boolean=Specifies whether to restore a system in suspended power
conservation mode when the timer state is set to signaled.
4=Apc:TFNTimerAPCRoutine=Application defined completion routine which is called
when the timer becomes signaled.
5=Arg:Pointer=Application defined value which is passed to the completion routine.
[Result]
If the function succeeds the result is True, otherwise it is False. In the latter
case you can call GetLastError to get extended error information. Note that if
you set Resume to True on a platform which doesn't support this, the method
succeeds (returns True) but calling GetLastError will return ERROR_NOT_SUPPORTED.
[Quick Info]
Kind=Method
Visibility=Public
BCB=3,4,5
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclWaitableTimer
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 98 or later.
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
TFNTimerAPCRoutine = procedure (Arg: Pointer; TimerLow, TimerHigh: DWORD); stdcall;
[ShortDescr]
Timer callback routine.
[Description]
TFNTimerAPCRoutine is used as the callback routine for waitable timers. The procedure
is executed when the waitable timer becomes signaled in the context of the thread
that activated the timer using the SetTimer or SetTimerApc method. However, that
thread must be in an alertable state or the completion routine will be cancelled.
[Parameters]
Count=3
1=Arg:Pointer=Application defined value as passed to SetTimerApc.
2=TimerLow:DWORD=Low order 32-bits of the UTC based time when the timer was signaled.
This value corresponds to the dwLowDateTime value of a TFileTime record.
3=TimerHigh=High order 32-bits of the UTC based time when the timer was signaled.
This value corresponds to the dwHighDateTime value of a TFileTime record.
[Quick Info]
Kind=Type
BCB=3,4,5
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclWaitableTimer
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 98 or later.
[SeeAlso]
Count=1
1=..\Methods\SetTimerApc
<DECL>--------------------------------------------------------------------------
[Declaration]
constructor Create(SecAttr: PSecurityAttributes; Manual: Boolean; const Name: string);
[ShortDescr]
Creates an instance of a TJclWaitableTimer object and the underlying Win32 waitable timer object.
[Description]
Creates an instance of a TJclWaitableTimer object and the underlying Win32 waitable timer object.
[Parameters]
Count=3
1=SecAttr:PSecurityAttributes=Pointer to a TSecurityAttributes record that specifies
the security attributes of the new waitable timer object such as whether it can be inherited.
If you specify nil the Handle cannot be inherited and the waitable timer receives a default
security descriptor.
2=Manual:Boolean=If True the timer acts as a manual-reset notification timer. If
False the timer acts as a synchronization timer.
3=Name:string=Name of the waitable timer object, can be empty. If a waitable timer already exists
on the system with the same name, the waitable timer is opened with TIMER_ALL_ACCESS. If
the waitable timer cannot be opened the constructor fails by raising an EJclWaitableTimerError
exception. If no waitable timer with the specified name exists, the waitable timer is created with
that name. If a named object already exists with the specified name but it is not
a waitable timer, the constructor fails by raising an EJclWaitableTimerError exception.
[Quick Info]
Kind=Method
Visibility=Public
BCB=3,4,5
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclWaitableTimer
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 98 or later.
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
constructor Open(Access: Cardinal; inheritable: Boolean; const Name: string);
[ShortDescr]
The Open constructor attempts to open the existing named waitable timer specified with Name.
[Description]
Opens an existing, named waitable timer. If the waitable timer object does not exist, or the calling
thread does not have sufficient access to open the waitable timer object, the constructor
fails by raising an EJclWaitableTimerError exception.
[Parameters]
Count=3
1=Access:Cardinal=Requested access to the timer object. This can be a combination
of the following values:
  <TABLE>
  <TR VALIGN="top">
  <TH align=left width=39%>Value</TH>
  <TH align=left width=61%>Meaning</TH>
  </TR>
  <TR VALIGN="top">
  <TD width=39%>TIMER_ALL_ACCESS</TD>
  <TD width=61%>Specifies all possible access rights for the timer object.</TD>
  </TR>
  <TR VALIGN="top">
  <TD width=39%>TIMER_MODIFY_STATE</TD>
  <TD width=61%>Enables use of the timer handle in the <REF>SetTimer</REF>
    and <REF>Cancel</REF> methods to modify the timer's state.</TD>
  </TR>
  <TR VALIGN="top">
  <TD width=39%>TIMER_QUERY_STATE</TD>
  <TD width=61%>Reserved for future use.</TD>
  </TR>
  <TR VALIGN="top">
  <TD width=39%>SYNCHRONIZE</TD>
  <TD width=61%><B>Windows NT/2000:</B> Enables use of the timer handle in any
    of the wait methods to wait for the timer's state to be signaled.</TD>
  </TR>
  </TABLE>
2=inheritable=Specifies whether the Handle of the waitable timer object can be inherited
by child processes.
3=Name:string=Name of the waitable timer object to open.
[Quick Info]
Kind=Method
Visibility=Public
BCB=3,4,5
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclWaitableTimer
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 98 or later.
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
TJclSemaphore = class (<REF Target"..\TJclDispatcherObject\TJclDispatcherObject">TJclDispatcherObject</REF>)
[ShortDescr]
Wrapper for a Win32 Semaphore object.
[Description]
TJclSemaphore is a wrapper for a Win32 Semaphore object.
[Quick Info]
BCB=3,4,5
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclSemaphore
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 4 SP 3 or later.
Windows 95/98=Requires Windows 98 or later.
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function Release(ReleaseCount: Longint): Boolean;
[ShortDescr]
Increases the semaphore's count.
[Description]
The Release method increases the count of the semaphore object by the specified
amount, but never increases past the maximum count as specified during construction.
[Parameters]
Count=1
1=ReleaseCount:Longint=The amount by which the semaphore's count should be increased.
The value must be greater than 0. If the increase would cause the count to exceed
the maximum the method fails (returns False) and the current count remains unchanged.
[Result]
If the function succeeds the result is True, otherwise the result is False. In
the latter case you can call GetLastError to get extended error information.
[Quick Info]
Kind=Method
Visibility=Public
BCB=3,4,5
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclSemaphore
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 4 SP 3 or later.
Windows 95/98=Requires Windows 98 or later.
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=1
1=ReleasePrev
<DECL>--------------------------------------------------------------------------
[Declaration]
function ReleasePrev(ReleaseCount: Longint; var PrevCount: Longint): Boolean;
[ShortDescr]
Increases the semaphore's count.
[Description]
The Release method increases the count of the semaphore object by the specified
amount, but never increases past the maximum count as specified during construction.
[Parameters]
Count=2
1=ReleaseCount:Longint=The amount by which the semaphore's count should be increased.
The value must be greater than 0. If the increase would cause the count to exceed
the maximum the method fails (returns False) and the current count remains unchanged.
2=PrevCount:Longint=Receives the previous count of the semaphore, before the increase.
If the function fails the value of this parameter is undefined.
[Result]
If the function succeeds the result is True, otherwise the result is False. In
the latter case you can call GetLastError to get extended error information.
[Quick Info]
Kind=Method
Visibility=Public
BCB=3,4,5
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclSemaphore
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 4 SP 3 or later.
Windows 95/98=Requires Windows 98 or later.
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=1
1=Release
<DECL>--------------------------------------------------------------------------
[Declaration]
constructor Create(SecAttr: PSecurityAttributes; Initial, Maximum: Longint; const Name: string);
[ShortDescr]
Creates an instance of a TJclSemaphore object and the underlying Win32 semaphore object.
[Description]
Creates an instance of a TJclSemaphore object and the underlying Win32 semaphore object.
[Parameters]
Count=4
1=SecAttr:PSecurityAttributes=Pointer to a TSecurityAttributes record that specifies
the security attributes of the new semaphore object such as whether it can be inherited.
If you specify nil the Handle cannot be inherited and the semaphore receives a default
security descriptor.
2=Initial:Longint=Initial count of the semaphore object. This value must be
between 0 and Maximum (both inclusive). The state of a semaphore is signaled when
its count is zero and nonsignaled otherwise. A successful wait operation on a
semaphore decreases the count of the semaphore by one. The count is increased by
a specified amount by using the <REF>Release</REF> method but cannot be increased
beyond the specified Maximum.
3=Maximum:Longint=Maximum count of the semaphore object. Must be greater than 0.
4=Name:string=Name of the semaphore object, can be empty. If a semaphore already exists
on the system with the same name, the semaphore is opened with SEMAPHORE_ALL_ACCESS. If
the semaphore cannot be opened the constructor fails by raising an EJclSemaphoreError
exception. If no semaphore with the specified name exists, the semaphore is created with
that name. If a named object already exists with the specified name but it is not
a semaphore, the constructor fails by raising an EJclSemaphoreError exception.
[Quick Info]
Kind=Method
Visibility=Public
BCB=3,4,5
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclSemaphore
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 4 SP 3 or later.
Windows 95/98=Requires Windows 98 or later.
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
constructor Open(Access: Cardinal; Inheritable: Boolean; const Name: string);
[ShortDescr]
The Open constructor attempts to open the existing named semaphore specified with Name.
[Description]
Opens an existing, named semaphore. If the semaphore object does not exist, or the calling
thread does not have sufficient access to open the semaphore object, the constructor
fails by raising an EJclSemaphoreError exception.
[Parameters]
Count=3
1=Access:Cardinal=Requested access to the semaphore object. This can be a combination
of the following values:
  <TABLE>
  <TR VALIGN="top">
  <TH align=left width=48%>Access</TH>
  <TH align=left width=52%>Description</TH>
  </TR>
  <TR VALIGN="top">
  <TD width=48%>SEMAPHORE_ALL_ACCESS</TD>
  <TD width=52%>Specifies all possible access flags for the semaphore object.</TD>
  </TR>
  <TR VALIGN="top">
  <TD width=48%>SEMAPHORE_MODIFY_STATE</TD>
  <TD width=52%>Enables use of the semaphore handle in the Release method to
    modify the semaphore's count.</TD>
  </TR>
  <TR VALIGN="top">
  <TD width=48%>SYNCHRONIZE</TD>
  <TD width=52%><B>Windows NT/2000:</B> Enables use of the semaphore handle
    in any of the wait methods to wait for the semaphore's state to be signaled.</TD>
  </TR>
  </TABLE>
2=Inheritable=Specifies whether the Handle of the semaphore object can be inherited
by child processes.
3=Name:string=Name of the semaphore object to open.
[Quick Info]
Kind=Method
Visibility=Public
BCB=3,4,5
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclSemaphore
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 4 SP 3 or later.
Windows 95/98=Requires Windows 98 or later.
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
TJclMutex = class (<REF Target"..\TJclDispatcherObject\TJclDispatcherObject">TJclDispatcherObject</REF>)
[ShortDescr]
Wrapper for a Win32 Mutex object.
[Description]
TJclMutex is a wrapper for a Win32 Mutex object.
[Quick Info]
BCB=3,4,5
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclMutex
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 4 SP 3 or later.
Windows 95/98=Requires Windows 98 or later.
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
constructor Create(SecAttr: PSecurityAttributes; InitialOwner: Boolean; const Name: string);
[ShortDescr]
Creates an instance of a TJclMutex object and the underlying Win32 mutex object.
[Description]
Creates an instance of a TJclMutex object and the underlying Win32 mutex object.
[Parameters]
Count=1
1=SecAttr:PSecurityAttributes=Pointer to a TSecurityAttributes record that specifies
the security attributes of the new Mutex object such as whether it can be inherited.
If you specify nil the Handle cannot be inherited and the Mutex receives a default
security descriptor.
2=InitialOwner:Boolean=Set to True if you want immediate ownership of the mutex
object. Note that initial ownership will only be granted if the call actually
creates the mutex. If the named mutex already exists the constructor opens the
mutex but you will not have ownership. Use the Existed property to determine
whether the constructor created or opened the named mutex. This is a non-issue
for unnamed mutexes or calls for which this parameter is False.
3=Name:string=Name of the Mutex object, can be empty. If a mutex already exists
on the system with the same name, the mutex is opened with MUTEX_ALL_ACCESS. If
the mutex cannot be opened the constructor fails by raising an EJclMutexError
exception. If no mutex with the specified name exists, the mutex is created with
that name. If a named object already exists wit the specified name but it is not
a mutex, the constructor fails by raising an EJclMutexError exception.
[Quick Info]
Kind=Method
Visibility=Public
BCB=3,4,5
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclMutex
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 4 SP 3 or later.
Windows 95/98=Requires Windows 98 or later.
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
constructor Open(Access: Cardinal; Inheritable: Boolean; const Name: string);
[ShortDescr]
The Open constructor attempts to open the existing named mutex specified with Name.
[Description]
Opens an existing, named mutex. If the mutex object does not exist, or the calling
thread does not have sufficient access to open the mutex object, the constructor
fails by raising an EJclMutexError exception.
[Parameters]
Count=3
1=Access:Cardinal=Requested access to the Mutex object. This can be a combination
of the following values:
  <TABLE>
  <TR VALIGN="top">
  <TH align=left width=38%>Access</TH>
  <TH align=left width=62%>Description</TH>
  </TR>
  <TR VALIGN="top">
  <TD width=38%>MUTEX_ALL_ACCESS</TD>
  <TD width=62%>Specifies all possible access flags for the mutex object.</TD>
  </TR>
  <TR VALIGN="top">
  <TD width=38%>SYNCHRONIZE</TD>
  <TD width=62%><B>Windows NT/2000:</B> Enables use of the mutex handle in any
    of the wait functions to acquire ownership of the mutex, or in the ReleaseMutex
    function to release ownership.</TD>
  </TR>
  </TABLE>
2=Inheritable=Specifies whether the Handle of the Mutex object can be inherited
by child processes.
3=Name:string=Name of the Mutex object to open.
[Quick Info]
Kind=Method
Visibility=Public
BCB=3,4,5
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclMutex
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 4 SP 3 or later.
Windows 95/98=Requires Windows 98 or later.
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function Release: Boolean;
[ShortDescr]
Releases ownership of the mutex.
[Description]
The Release method release ownership of the mutex which was previously obtained
by using one of the WaitXxx methods. Note that although only one thread can own
a mutex at any time, a single thread can own the mutex multiple times by calling
one of the WaitXxx methods multiple times. You must balance the calls to WaitXxx
and Release, meaning you must call Release once for each time you call WaitXxx.
[Result]
If the function succeeds it returns True, otherwise it returns False. In the latter
case, which is usually a result of not owning the mutex, you can call GetLastError
to get extended error information.
[Quick Info]
Kind=Method
Visibility=Public
BCB=3,4,5
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclMutex
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 4 SP 3 or later.
Windows 95/98=Requires Windows 98 or later.
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
TJclCriticalSectionEx = class (<REF Target"..\TJclDispatcherObject\TJclDispatcherObject">TJclDispatcherObject</REF>)
[ShortDescr]
Wrapper for a Win32 critical section object
[Description]
TJclCriticalSection is a wrapper for a Win32 critical section object which surfaces
all functionality, including functionality not available in Windows 95. To use
TJclCriticalSectionEx the target system must be running Windows NT 4 with service
pack 3 or better or Windows 98. Note however that the TryEnter, GetSpinCount, and 
SetSpinCount methods are not implemented in Windows 98.
[Quick Info]
BCB=3,4,5
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclCriticalSectionEx
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 4 SP 3 or later.
Windows 95/98=Requires Windows 98 or later.
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
constructor CreateEx(SpinCount: Cardinal; NoFailEnter: Boolean); virtual;
[ShortDescr]
Creates an instance of a TJclCriticalSectionEx object.
[Description]
The CreateEx constructor creates an instance of a TJclCriticalSection object
and initializes the underlying Win32 critical section object. The parameters
allow you to specify a spincount for the critical section and you can specify
whether the internally used event object must be preallocated (see below). The
Create constructor is overloaded for TJclCriticalSectionEx and simply calls
CreateEx with 4000 and False for SpinCount and NoFailEnter respectively.
[Parameters]
Count=2
1=SpinCount:Cardinal=The spincount for the critical section object. Conceptually
the critical section will try to attempt ownership of the critical section for
SpinCount number of times when the Enter method is called. If the critical section
is still not available after these attempts the thread enters a wait state until
the critical section is released. On a single-processor system this parameter is
ignored and the critical section will use 0 internally. This means the critical
section will never spin before waiting on a kernel event. This makes sense since
the critical section could never be released while the thread was spinning 
(and thus monopolizing the processor).
2=NoFailEnter:Boolean=If True the kernel event object which is used when a thread
must enter a wait state because the critical section is not available, is preallocated
thereby guaranteeing that the Enter method does not fail, even in low memory situations.
[Quick Info]
BCB=3,4,5
Kind=Method
Visibility=Public
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclCriticalSectionEx
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 4 SP 3 or later.
Windows 95/98=Requires Windows 98 or later.
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function TryEnter: Boolean;
[ShortDescr]
Attempts to Enter the critical section.
[Description]
TryEnter attempts to acquire ownership of the critical section object. However,
unlike the <REF Target"..\..\TJclCriticalSection\Methods\Enter">Enter</REF> method,
this method immediately returns if the critical section cannot be acquired.  Note this
method is not supported on Windows 98.
[Result]
If ownership of the critical section object is acquired the function returns
True. If ownership could not be acquired because the critical section was already
owned by a different thread the function returns False. In this latter case you
must take care <u>not</U> to call Release.
[Quick Info]
BCB=3,4,5
Kind=Method
Visibility=Public
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclCriticalSectionEx
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 4 SP 3 or later.
Windows 95/98=Unsupported.
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
class function GetSpinTimeOut: Cardinal;
[ShortDescr]
Returns the system setting of the critical section timeout.
[Description]
GetSpinTimeOut returns the system's global critical section timeout value. This
value determines after which interval an attempt to enter a critical section
times out. The default setting is about 30 days.
[Result]
The systems critical section timeout interval in seconds.
[Quick Info]
BCB=3,4,5
Kind=Method
Visibility=Public
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclCriticalSectionEx
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 4 SP 3 or later.
Windows 95/98=Unsupported
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=1
1=SetSpinTimeOut
<DECL>--------------------------------------------------------------------------
[Declaration]
class procedure SetSpinTimeOut(const Value: Cardinal);
[ShortDescr]
Sets the system's critical section timeout value.
[Description]
SetSpinTimeOut sets the system's global critical section timeout value. This
value determines after which interval an attempt to enter a critical section
times out. The default setting is about 30 days. Note that this value affects
all threads on the entire system. Do not set this value too low since it might
negatively affect threads that normally wait longer than the timeout interval
and do not expect to timeout.
[Parameters]
Count=1
1=Value:Cardinal=The new critical section timeout interval in seconds.
[Quick Info]
BCB=3,4,5
Kind=Method
Visibility=Public
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclCriticalSectionEx
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 4 SP 3 or later.
Windows 95/98=Unsupported
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=1
1=GetSpinTimeOut
<DECL>--------------------------------------------------------------------------
[Declaration]
property SpinCount: Cardinal read FSpinCount write SetSpinCount;
[ShortDescr]
Sets the spincount for the critical section.
[Description]
SpinCount allows you to query or set the critical section's spincount value.
[Result]
[Quick Info]
BCB=3,4,5
Kind=Property
Visibility=Public
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclCriticalSectionEx
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 4 SP 3 or later.
Windows 95/98=Requires Windows 98 or later.
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
TJclCriticalSection = class (TObject)
[ShortDescr]
Wrapper for a Win32 critical section object
[Description]
TJclCriticalSection is a wrapper for a Win32 critical section object which surfaces
only functionality common to all Win32 implementations. Windows 98 and Windows NT
introduced some additional functionality which is only available in the
TJclCriticalSectionEx class.
[Quick Info]
BCB=3,4,5
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclCriticalSection
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 3.1 or later.
Windows 95/98=Requires Windows 95 or later.
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
constructor Create; virtual;
[ShortDescr]
Creates an instance of a TJclCriticalSection object.
[Description]
The create constructor creates an instance of a TJclCriticalSection object and
initializes the underlying Win32 critical section object.
[Quick Info]
BCB=3,4,5
Kind=Method
Visibility=Public
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclCriticalSection
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 3.1 or later.
Windows 95/98=Requires Windows 95 or later.
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
class procedure CreateAndEnter(var CS: TJclCriticalSection);
[ShortDescr]
Creates an instance of a TJclCriticalSection object and enters it.
[Description]
The CreateAndEnter class method creates an instance of TJclCriticalSection and
Enters it in an atomic, and therefor thread safe, manner. The newly created
critical section is then assigned to the CS parameter. The method does not return
until ownership of the critical section can be obtained. This routine is handy in
situations where you use a lazy creation approach (that is don't create the
ciritical section until it is actually needed) and there's a possibility that
multiple threads could attempt to create the critical section simultanuously.
[Parameters]
Count=1
1=CS:TJclCriticalSection=Variable which receives a reference to the newly created
critical section object. It is valid for the parameter to contain a reference to
an already created critical section. In that case the method merely attempts to
Enter the existing critical section. If the parameter does not contain a valid
reference it must be nil (declaring a variable as a global variable or object
data field will ensure the variable is initialized to nil).
[Quick Info]
BCB=3,4,5
Kind=Method
Visibility=Public
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclCriticalSection
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 3.1 or later.
Windows 95/98=Requires Windows 95 or later.
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
destructor Destroy; override;
[ShortDescr]
Destroys the TJclCriticalSection object.
[Description]
The Destroy destructor releases the underlying Win32 critical section object and
destroys the TJclCriticalSection object.
[Quick Info]
BCB=3,4,5
Kind=Method
Visibility=Public
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclCriticalSection
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 3.1 or later.
Windows 95/98=Requires Windows 95 or later.
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure Enter;
[ShortDescr]
Enters the critical section.
[Description]
Enter attempts to get access to the critical section, this is referred to as
acquiring ownership of the critical section. Only one thread can own the critical
section at any time. If the critical section is currently owned by a different
thread the function blocks until the critical section becomes free. After
acquiring ownership of the critical section you must release it as soon as you
are done with it by calling the <REF>Leave</REF> method. Although only one
thread can own the critical section, a single thread can own the critical section
more than once. This means you can call Enter multiple times. However, calls to Enter
and Leave must be balanced: you must call Leave for each time you call Enter.
[Notes]
Count=1
1=In extremely low-memory situations a call to Enter may fail by raising an exception.
If you cannot tolerate a failure of Enter you should use TJclCriticalSectionEx instead.
[Quick Info]
BCB=3,4,5
Kind=Method
Visibility=Public
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclCriticalSection
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 3.1 or later.
Windows 95/98=Requires Windows 95 or later.
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=1
1=Leave
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure Leave;
[ShortDescr]
Releases ownership of the critical section.
[Description]
The Release method releases ownership of the critical section previously acquired
by a call to the <REF>Enter</REF> method. After a call to Release the critical
section is free to be acquired by a different thread. If you called Enter multiple
times the critical section will not be released until the last, balancing call
to Release.
[Notes]
Count=1
1=If you call Release while you don't currently own the critical section, the
state of the critical section object becomes corrupted and threads waiting for
ownership may be blocked forever.
[Quick Info]
BCB=3,4,5
Kind=Method
Visibility=Public
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclCriticalSection
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 3.1 or later.
Windows 95/98=Requires Windows 95 or later.
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=1
1=Enter
<DECL>--------------------------------------------------------------------------
[Declaration]
TJclEvent = class (<REF Target"..\TJclDispatcherObject\TJclDispatcherObject">TJclDispatcherObject</REF>)
[ShortDescr]
Wrapper for the Win32 Event object.
[Description]
TJclEvent is a wrapper for a Win32 Event object.
[Quick Info]
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclEvent
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 3.1 or later.
Windows 95/98=Requires Windows 95 or later.
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function Pulse: Boolean;
[ShortDescr]
Pulses the Event object.
[Description]
Pulse sets the Event to the signaled state and back to nonsignaled in one single
operation releasing the appropriate waiting threads in between. For a manual-reset
event, all waiting threads are released before returning the Event to the nonsignaled
state. For an auto-reset event, only one waiting thread is released. If no threads
are waiting the function merely resets the Event to the nonsignaled state.
[Result]
If the function succeeds it returns True, otherwise it returns False. In the latter
case you can call GetLastError to get extended error information.
[Quick Info]
BCB=3,4,5
Kind=Method
Visibility=Public
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclEvent
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 3.1 or later.
Windows 95/98=Requires Windows 95 or later.
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=2
1=ResetEvent
2=SetEvent
<DECL>--------------------------------------------------------------------------
[Declaration]
function ResetEvent: Boolean;
[ShortDescr]
Resets the Event to the nonsignaled state.
[Description]
ResetEvent resets the Event to the nonsignaled state thereby blocking all waiting
threads. This is only useful for a manual-reset event which has to be explicitly
set or reset. Auto-reset events are automatically reset to the nonsignaled state
whenever a thread successfully waited on it.
[Result]
If the function succeeds it returns True, otherwise it returns False. In the latter
case you can call GetLastError to get extended error information.
[Quick Info]
BCB=3,4,5
Kind=Method
Visibility=Public
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclEvent
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 3.1 or later.
Windows 95/98=Requires Windows 95 or later.
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=2
1=Pulse
2=SetEvent
<DECL>--------------------------------------------------------------------------
[Declaration]
function SetEvent: Boolean;
[ShortDescr]
Sets the Event to the signaled state.
[Description]
SetEvent sets the Event to the signaled state. Manual-reset events remain in the
signaled state until explicitly reset by using <REF>ResetEvent</REF>. All threads
subsequently calling one of the wait functions are released immediately. For
auto-reset events the state remains signaled until one thread is released from
waiting on this event.
[Result]
If the function succeeds it returns True, otherwise it returns False. In the latter
case you can call GetLastError to get extended error information.
[Quick Info]
BCB=3,4,5
Kind=Method
Visibility=Public
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclEvent
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 3.1 or later.
Windows 95/98=Requires Windows 95 or later.
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=2
1=Pulse
2=ResetEvent
<DECL>--------------------------------------------------------------------------
[Declaration]
constructor Create(SecAttr: PSecurityAttributes; Manual, Signaled: Boolean; const Name: string);
[ShortDescr]
Creates an instance of a TJclEvent object.
[Description]
Create creates an instance of a TJclEvent object.
[Parameters]
Count=4
1=SecAttr:PSecurityAttributes=Pointer to a TSecurityAttributes record that specifies
the security attributes of the new Event object such as whether it can be inherited.
If you specify nil the Handle cannot be inherited and the Event receives a default
security descriptor.
2=Manual:Boolean=Specifies whether a manual-reset or auto-reset event is created.
If True (manual-reset) you must use the <REF>ResetEvent</REF> method to manually
reset the state of the event to nonsignaled. If False (auto-reset) the system
automatically sets the state of the Event object to non-signaled when a thread
successfully waited on the event.
3=Signaled:Boolean=Specifies the initial state of the Event. If True the Event
is created in the signaled state, if False it is created in the non-signaled state.
4=Name:string=Name of the Event object, can be empty. If an event already exists
on the system with the same name, the event is opened with EVENT_ALL_ACCESS. If
the Event cannot be opened the constructor fails by raising an EJclEventError
exception. If no Event with the specified name exists, the Event is created with
that name. If a named object already exists wit the specified name but it is not
an event, the constructor fails by raising an EJclEventError exception.
[Quick Info]
BCB=3,4,5
Kind=Method
Visibility=Public
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclEvent
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 3.1 or later.
Windows 95/98=Requires Windows 95 or later.
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=1
1=Open
<DECL>--------------------------------------------------------------------------
[Declaration]
constructor Open(Access: Cardinal; Inheritable: Boolean; const Name: string);
[ShortDescr]
The Open constructor attempts to open the existing named event specified with Name.
[Description]
Opens an existing, named event. If the Event object does not exist, or the calling
thread does not have sufficient access to open the Event object, the constructor
fails by raising an EJclEventError exception.
[Parameters]
Count=3
1=Access:Cardinal=Requested access to the Event object. This can be a combination
of the following values:
  <TABLE>
  <TR VALIGN="top">
  <TH align=left width=40%>Access</TH>
  <TH align=left width=60%>Description</TH>
  </TR>
  <TR VALIGN="top">
  <TD width=40%>EVENT_ALL_ACCESS</TD>
  <TD width=60%>Specifies all possible access flags for the event object.</TD>
  </TR>
  <TR VALIGN="top">
  <TD width=40%>EVENT_MODIFY_STATE</TD>
  <TD width=60%>Enables modification of the event's state with the <REF>SetEvent</REF>
    and <REF>ResetEvent</REF> methods.</TD>
  </TR>
  <TR VALIGN="top">
  <TD width=40%>SYNCHRONIZE</TD>
  <TD width=60%><B>Windows NT/2000:</B> Enables use of the event handle in any
    of the wait functions to wait for the event's state to be signaled.</TD>
  </TR>
  </TABLE>
2=Inheritable=Specifies whether the Handle of the Event object can be inherited
by child processes.
3=Name:string=Name of the Event object to open.
[Quick Info]
BCB=3,4,5
Kind=Method
Visibility=Public
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclEvent
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 3.1 or later.
Windows 95/98=Requires Windows 95 or later.
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=1
1=Create
<DECL>--------------------------------------------------------------------------
[Declaration]
TJclDispatcherObject = class (TObject)
[ShortDescr]
Base class for kernel synchronization objects.
[Description]
TJclDispatcherObject is the base class for all kernel synchronization objects,
which are also known as dispatcher objects, hence the name. It has provisions
for the storage of a handle to the object and automatically releases the handle
when the object is destructed. Additionally it provides methods to wait on the
object which are common to all dispatcher object derivatives.
[Notes]
Count=1
1=There are several non-kernel synchronization objects that do not derive 
from TJclDispatcherObject. Examples are the TJclCriticalSection and TJclOptex.
[Quick Info]
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclDispatcherObject
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 3.1 or later.
Windows 95/98=Requires Windows 95 or later.
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
property Existed: Boolean read FExisted;
[ShortDescr]
Indicates whether the object existed.
[Description]
The Existed property denotes whether the dispatcher object already existed when
it was created. This property is True if:<BR>
  <UL>
    <LI>You successfully used the Open constructor.
    <LI>If an object with the Name specified in the constructor already existed
        somewhere on the system and you have been granted access to that object.
  </UL>
If you create a named object which doesn't exist, the object is created and Existed
will be False. Unnamed object always result in Existed being False.
[Quick Info]
Kind=Property
Visibility=Public
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclDispatcherObject
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 3.1 or later.
Windows 95/98=Requires Windows 95 or later.
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
property Handle: THandle read FHandle;
[ShortDescr]
Handle to the dispatcher object being wrapped.
[Description]
The handle property contains the handle to the underlying dispatcher object. You
could use this in a call to WaitForMultipleObjects or to duplicate the Handle. Never
manually close the handle by calling CloseHandle, the class does this automatically
in the destructor.
[Quick Info]
Kind=Property
Visibility=Public
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclDispatcherObject
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 3.1 or later.
Windows 95/98=Requires Windows 95 or later.
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
property Name: string read FName;
[ShortDescr]
The name of the object.
[Description]
Name contains the name of the object as specified in the constructor.
[Quick Info]
Kind=Property
Visibility=Public
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclDispatcherObject
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 3.1 or later.
Windows 95/98=Requires Windows 95 or later.
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
TJclWaitResult = (wrAbandoned, wrError, wrIoCompletion, wrSignaled, wrTimeout);
[ShortDescr]
Enumeration used as the method result by WaitFor, WaitForever and WaitAlertable.
[Enumeration]
Count=5
1=wrAbandoned=Only applicable if the object is a mutex which was not released by
the owning thread before the thread exited. The calling thread has been granted ownership
of the mutex which is set to nonsignaled.
2=wrError=An error occurred. You can call GetLastError to get more information
about why the method failed.
3=wrIoCompletion=One or more I/O completion routines were queued. Only applicable
to <REF Target"..\Methods\WaitAlertable">WaitAlertable</REF>.
4=wrSignaled=The object was, or became, signaled.
5=wrTimeout=The timeout interval expired. This is not a successful wait.
[Quick Info]
Kind=Type
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclDispatcherObject
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 3.1 or later.
Windows 95/98=Requires Windows 95 or later.
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function SignalAndWait(const Obj: TJclDispatcherObject; TimeOut: Cardinal; Alertable: Boolean): TJclWaitResult;
[ShortDescr]
Signals another object and then blocks until the object becomes signaled or the timeout expires.
[Description]
SignalAndWait signals the specified object (Obj) and checks the state of the object this
method belongs to, if it is non-signaled the calling thread enters an alertable
wait-state until one of the following occurs:<BR>
 <UL>
  <LI>The object becomes signaled.
  <LI>The time-out interval expires.
  <LI>An I/O completion routine or asynchronous procedure call is queued to the thread.
 </UL>
If the object is signaled, or one of the above mentioned events occur while in a
wait-state, the method returns and the calling thread is allowed to continue
execution.<BR>
Note that successfully waiting on a dispatcher object can, depending on the object,
modify the state of the underlying object. For example, the count of a semaphore
is decreased by one before the method returns. See the individual synchronization
classes and the Platform SDK for details.
[Parameters]
Count=3
1=Obj:TJclDispatcherObject=The object to signal before waiting on the object for
which this method is called. The object to signal can be a Mutex, Event or Semaphore
to which you must have the appropriate access.
2=TimeOut:Cardinal=Interval, in milliseconds, the method waits on an object. If the
object does not become signaled before the interval has expired, the method returns.
3=Alertable:Boolean=If False the method blocks until either the object becomes
signaled or the timeout expires. If True the calling thread enters an alertable
wait-state until one of the aforementioned events occur or an I/O Completion routine
or APC is queued for the thread.
[Result]
The result indicates success or failure and is of
type <REF Target"..\Types\TJclWaitResult">TJclWaitResult</REF>. This method can
return any of the members of the enumeration. See TJclWaitResult for the details.
[Quick Info]
BCB=3,4,5
Kind=Method
Visibility=Public
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclDispatcherObject
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Unsupported
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=4
1=WaitFor
2=WaitForever
3=WaitForMultipleObjects;..\..\WaitForMultipleObjects
4=WaitAlertableForMultipleObjects;..\..\WaitAlertableForMultipleObjects
<DECL>--------------------------------------------------------------------------
[Declaration]
function WaitAlertable(const TimeOut: Cardinal): TJclWaitResult;
[ShortDescr]
WaitAlertable blocks until the object becomes signaled or the timeout expires.
[Description]
WaitAlertable checks the state of the object, if it is non-signaled the calling
thread enters an alertable wait-state until one of the following occurs:<BR>
 <UL>
  <LI>The object becomes signaled.
  <LI>The time-out interval expires.
  <LI>An I/O completion routine or asynchronous procedure call is queued to the thread.
 </UL>
If the object is signaled, or one of the above mentioned events occur while in a
wait-state, the method returns and the calling thread is allowed to continue
execution.<BR>
Note that successfully waiting on a dispatcher object can, depending on the object,
modify the state of the underlying object. For example, the count of a semaphore
is decreased by one before the method returns. See the individual synchronization
classes and the Platform SDK for details.
[Parameters]
Count=1
1=TimeOut:Cardinal=Interval, in milliseconds, the method waits on an object. If the
object does not become signaled before the interval has expired, the method returns.
[Result]
The result indicates success or failure and is of
type <REF Target"..\Types\TJclWaitResult">TJclWaitResult</REF>. This method can
return any of the members of the enumeration. See TJclWaitResult for the details.
[Quick Info]
BCB=3,4,5
Kind=Method
Visibility=Public
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclDispatcherObject
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 3.1 or later.
Windows 95/98=Requires Windows 95 or later.
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=4
1=WaitFor
2=WaitForever
3=WaitForMultipleObjects;..\..\WaitForMultipleObjects
4=WaitAlertableForMultipleObjects;..\..\WaitAlertableForMultipleObjects
<DECL>--------------------------------------------------------------------------
[Declaration]
function WaitFor(const TimeOut: Cardinal): TJclWaitResult;
[ShortDescr]
Blocks until the object becomes signaled or the timeout expires.
[Description]
WaitFor checks the state of the object, if it is non-signaled the calling thread
enters a wait state until one of the following occurs:<BR>
  <UL>
    <LI>The object becomes signaled.
    <LI>The time-out interval expires.
  </UL>
If the object is signaled, or one of the above mentioned events occurs, the function
returns and the thread is allowed to continue execution.<BR>
Note that successfully waiting on a dispatcher object can, depending on the object,
modify the state of the underlying object. For example, the count of a semaphore
is decreased by one before the method returns. See the individual synchronization
classes and the Platform SDK for details.
[Parameters]
Count=1
1=TimeOut:Cardinal=Interval, in milliseconds, the method waits on an object. If the
object does not become signaled before the interval has expired, the method returns.
If you specify a 0 timeout the method tests the state of the object and immediately
returns. You can specify INFINITE to wait forever or use <REF>WaitForever</REF>
instead.
[Result]
The result indicates success or failure and is of
type <REF Target"..\Types\TJclWaitResult">TJclWaitResult</REF>. This type is shared
between all WaitXxx functions and as such not all members of this enumeration can
be returned from this method. Valid ones are wrError, wrAbandoned, wrTimeOut and
wrSignaled. See TJclWaitResult for the details.
[Notes]
Count=1
1=This method results in non-alertable wait state while the object is not signaled.
Use <REF>WaitAlertable</REF> to enter an alertable wait state.
[Quick Info]
BCB=3,4,5
Kind=Method
Visibility=Public
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclDispatcherObject
Windows NT/2000=Requires Windows NT 3.1 or later.
Windows 95/98=Requires Windows 95 or later.
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=4
1=WaitAlertable
2=WaitForever
3=WaitForMultipleObjects;..\..\WaitForMultipleObjects
4=WaitAlertableForMultipleObjects;..\..\WaitAlertableForMultipleObjects
<DECL>--------------------------------------------------------------------------
[Declaration]
function WaitForever: TJclWaitResult;
[ShortDescr]
Blocks until the object becomes signaled.
[Description]
WaitForever checks the state of the object, if it is non-signaled the calling
thread enters a wait state until the object becomes signaled. If the object is
signaled, or becomes signaled, the function returns and the thread is allowed to
continue execution.<BR>
Note that successfully waiting on a dispatcher object can, depending on the object,
modify the state of the underlying object. For example, the count of a semaphore
is decreased by one before the method returns. See the individual synchronization
classes and the Platform SDK for details.
[Result]
The result indicates success or failure and is of
type <REF Target"..\Types\TJclWaitResult">TJclWaitResult</REF>. This type is shared
between all WaitXxx functions and as such not all members of this enumeration can
be returned from this method. Valid ones are wrError, wrAbandoned, wrTimeOut and
wrSignaled. See TJclWaitResult for the details.
[Quick Info]
BCB=3,4,5
Kind=Method
Visibility=Public
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclDispatcherObject
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 3.1 or later.
Windows 95/98=Requires Windows 95 or later.
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=4
1=WaitAlertable
2=WaitFor
3=WaitForMultipleObjects;..\..\WaitForMultipleObjects
4=WaitAlertableForMultipleObjects;..\..\WaitAlertableForMultipleObjects
<DECL>--------------------------------------------------------------------------
[Declaration]
constructor Attach(Handle: THandle);
[ShortDescr]
Attaches to an existing dispatcher object.
[Description]
The Attach constructor attaches to the existing dispatcher object specified by
Handle. This is particularly useful when passing handles between a parent and
child process using handle inheritance.
[Parameters]
Count=1
1=Handle:THandle=Handle of the dispatcher object to attach to. This must be a
handle to an event, mutex, semaphore, waitable timer or timer queue.
[Quick Info]
BCB=3,4,5
Kind=Method
Visibility=Public
Unit=JclSynch
Category=Libraries, Processes and Threads
Windows NT/2000=Requires Windows NT 3.1 or later.
Windows 95/98=Requires Windows 95 or later.
SubCat=Synchronization\TJclDispatcherObject
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
destructor Destroy; override;
[ShortDescr]
Disposes of the object instance.
[Description]
Destroy closes the handle to the dispatcher object and disposes of the object
instance. After this call the object instance, as well as the dispatcher object
wrapped by the class, are no longer valid. The state of any threads waiting on
the object are often undefined and therefore you should never destroy an object
with outstanding references. TJclDispatcherObject does not make any provisions
for this, nor do any of the derived classes.
[Quick Info]
BCB=3,4,5
Kind=Method
Visibility=Public
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclDispatcherObject
Windows NT/2000=Requires Windows NT 3.1 or later.
Windows 95/98=Requires Windows 95 or later.
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function LockedCompareExchange(var Target: Integer; Exch, Comp: Integer): Integer;
[ShortDescr]
Thread safe compare and exchange.
[Description]
LockedCompareExchange compares Comp with Target. If they are equal the value of
Exch is moved into Target, otherwise Target retains its value. All this is
performed in a locked, thread-safe manner. The LockedXxx functions allow for a
simple and efficient way for applications to synchronize access to and manipulate
integer variables which are shared by multiple threads.
[Parameters]
Count=3
1=Target:Integer=The target variable to compare Value and which conditionally
receives the value of Exch.
2=Exch:Integer=The value which is moved into Target if Comp and Target are equal.
3=Comp:Integer=The comperand which Target is compared against.
[Result]
The value of Target on procedure entry. Depending on the comparison, Target may
have been updated or have retained its value.
[Notes]
Count=1
1=The Win32 API provides similar functions. Look up InterlockedXxx in the Platform SDK.
[Quick Info]
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\Locked integer manipulation
Author=Azret Botash;azret@attglobal.net
BCB=3,4,5
Delphi=3,4,5
Requirements=Requires a 486 or better processor.
[SeeAlso]
Count=4
1=LockedExchangeSub
2=LockedExchange
3=LockedExchangeInc
4=LockedExchangeDec
<DECL>--------------------------------------------------------------------------
[Declaration]
function LockedExchangeAdd(var Target: Integer; Value: Integer): Integer;
[ShortDescr]
Thread safe addition.
[Description]
LockedExchangeAdd implements threadsafe addition for integers. The function adds
Value to Target and returns the previous value of Target. The LockedXxx functions
allow for a simple and efficient way for applications to synchronize access to
and manipulate integer variables which are shared by multiple threads.
[Parameters]
Count=2
1=Target:Integer=The target variable to add Value to.
2=Value:Integer=The value to add to Target
[Result]
The value of Target before the addition.
[Notes]
Count=1
1=The Win32 API provides similar functions. Look up InterlockedXxx in the Platform SDK.
[Quick Info]
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\Locked integer manipulation
Author=Azret Botash;azret@attglobal.net
BCB=3,4,5
Delphi=3,4,5
[SeeAlso]
Count=4
1=LockedExchangeSub
2=LockedExchange
3=LockedExchangeInc
4=LockedExchangeDec
<DECL>--------------------------------------------------------------------------
[Declaration]
function LockedAdd(var Target: Integer; Value: Integer): Integer;
[ShortDescr]
Thread safe addition.
[Description]
LockedAdd implements threadsafe addition for integers. The function adds Value
to Target and returns the new value of Target. The LockedXxx functions allow for
a simple and efficient way for applications to synchronize access to and
manipulate integer variables which are shared by multiple threads.
[Parameters]
Count=2
1=Target:Integer=The target variable to add Value to.
2=Value:Integer=The value to add to Target
[Result]
The resulting value of Target after the addition. Note that the actual value of
the variable may have already changed.
[Notes]
Count=1
1=The Win32 API provides similar functions. Look up InterlockedXxx in the Platform SDK.
[Quick Info]
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\Locked integer manipulation
Author=Azret Botash;azret@attglobal.net
BCB=3,4,5
Delphi=3,4,5
[SeeAlso]
Count=4
1=LockedSub
2=LockedExchange
3=LockedInc
4=LockedDec
<DECL>--------------------------------------------------------------------------
[Declaration]
function LockedExchangeSub(var Target: Integer; Value: Integer): Integer;
[ShortDescr]
Thread safe subtraction.
[Description]
LockedExchangeSub implements threadsafe subtraction for integers. The function
subtracts Value from Target and returns the old value of Target. The LockedXxx
functions allow for a simple and efficient way for applications to synchronize
access to and manipulate integer variables which are shared by multiple threads.
[Parameters]
Count=2
1=Target:Integer=The Target variable to manipulate.
2=Value:Integer=The value to subtract from Target.
[Result]
The value of Target before the subtraction.
[Notes]
Count=1
1=The Win32 API provides similar functions. Look up InterlockedXxx in the Platform SDK.
[Quick Info]
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\Locked integer manipulation
Author=Azret Botash;azret@attglobal.net
BCB=3,4,5
Delphi=3,4,5
[SeeAlso]
Count=4
1=LockedExchangeAdd
2=LockedExchange
3=LockedExchangeInc
4=LockedExchangeDec
<DECL>--------------------------------------------------------------------------
[Declaration]
function LockedSub(var Target: Integer; Value: Integer): Integer;
[ShortDescr]
Thread safe subtraction.
[Description]
LockedSub implements threadsafe subtraction for integers. The function subtracts
Value from Target and returns the new value of Target. The LockedXxx functions
allow for a simple and efficient way for applications to synchronize access to,
and manipulate integer variables which are shared by multiple threads.
[Parameters]
Count=2
1=Target:Integer=The Target variable to manipulate.
2=Value:Integer=The value to subtract from Target.
[Result]
The resulting value of Target after the subtraction. Note that the actual value
of the variable may have already changed!
[Notes]
Count=1
1=The Win32 API provides similar functions. Lookup InterlockedXxx in the Platform SDK.
[Quick Info]
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\Locked integer manipulation
Author=Azret Botash;azret@attglobal.net
BCB=3,4,5
Delphi=3,4,5
[SeeAlso]
Count=4
1=LockedAdd
2=LockedExchange
3=LockedInc
4=LockedDec
<DECL>--------------------------------------------------------------------------
[Declaration]
function LockedExchange(var Target: Integer; Value: Integer): Integer;
[ShortDescr]
Thread safe exchange.
[Description]
LockedExchange implements a thread safe exchange of two integer values. The function
exchanges the values of Target and Value and returns the previous value of
Target. The LockedXxx functions allow for a simple and efficient way for applications
to synchronize access to and manipulate integer variables which are shared by
multiple threads.
[Parameters]
Count=2
1=Target:Integer=The Target variable.
2=Value:Integer=The value to move into Target.
[Result]
The value of Target before the exchange.
[Notes]
Count=1
1=The Win32 API provides similar functions. Look up InterlockedXxx in the Platform SDK.
[Quick Info]
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\Locked integer manipulation
Author=Azret Botash;azret@attglobal.net
BCB=3,4,5
Delphi=3,4,5
[SeeAlso]
Count=4
1=LockedAdd
2=LockedSub
3=LockedInc
4=LockedDec
<DECL>--------------------------------------------------------------------------
[Declaration]
function LockedExchangeInc(var Target: Integer): Integer;
[ShortDescr]
Thread safe increment.
[Description]
LockedExchangeInc increments the specified Integer in an atomic, thread-safe manner.
The LockedXxx functions allow for a simple and efficient way for applications to
synchronize access to and manipulate integer variables which are shared by
multiple threads.
[Parameters]
Count=1
1=Target:Integer=The variable to increment.
[Result]
The value of Target before the increment.
[Notes]
Count=1
1=The Win32 API provides similar functions. Look up InterlockedXxx in the Platform SDK.
[Quick Info]
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\Locked integer manipulation
Author=Azret Botash;azret@attglobal.net
BCB=3,4,5
Delphi=3,4,5
[SeeAlso]
Count=4
1=LockedExchangeAdd
2=LockedExchangeSub
3=LockedExchange
4=LockedExchangeDec
<DECL>--------------------------------------------------------------------------
[Declaration]
function LockedInc(var Target: Integer): Integer;
[ShortDescr]
Thread safe increment.
[Description]
LockedInc increments the specified Integer in an atomic, thread-safe manner. The
LockedXxx functions allow for a simple and efficient way for applications to
synchronize access to and manipulate integer variables which are shared by
multiple threads.
[Parameters]
Count=1
1=Target:Integer=The variable to increment.
[Result]
The resulting value of Target after the increment. Note that the actual value of the
variable may have already changed!
[Notes]
Count=1
1=The Win32 API provides similar functions. Look up InterlockedXxx in the Platform SDK.
[Quick Info]
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\Locked integer manipulation
Author=Azret Botash;azret@attglobal.net
BCB=3,4,5
Delphi=3,4,5
[SeeAlso]
Count=4
1=LockedAdd
2=LockedSub
3=LockedExchange
4=LockedDec
<DECL>--------------------------------------------------------------------------
[Declaration]
function LockedExchangeDec(var Target: Integer): Integer;
[ShortDescr]
Thread safe decrement.
[Description]
LockedExchangeDec decrements the specified Integer in an atomic, thread-safe manner.
The LockedXxx functions allow for a simple and efficient way for applications to
synchronize access to and manipulate integer variables which are shared by
multiple threads.
[Parameters]
Count=1
1=Target:Integer=The variable to decrement.
[Result]
The value of Target before being decremented.
[Notes]
Count=1
1=The Win32 API provides similar functions. Look up InterlockedXxx in the Platform SDK.
[Quick Info]
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\Locked integer manipulation
Author=Azret Botash;azret@attglobal.net
BCB=3,4,5
Delphi=3,4,5
[SeeAlso]
Count=4
1=LockedExchangeAdd
2=LockedExchangeSub
3=LockedExchange
4=LockedInc
<DECL>--------------------------------------------------------------------------
[Declaration]
function LockedDec(var Target: Integer): Integer;
[ShortDescr]
Thread safe decrement.
[Description]
LockedDec decrements the specified Integer in an atomic, thread-safe manner. The
LockedXxx functions allow for a simple and efficient way for applications to
synchronize access to and manipulate integer variables which are shared by
multiple threads.
[Parameters]
Count=1
1=Target:Integer=The variable to decrement.
[Result]
The value of Target after being decremented. Note that the actual value of the
variable may have already changed!
[Notes]
Count=1
1=The Win32 API provides similar functions. Look up InterlockedXxx in the Platform SDK.
[Quick Info]
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\Locked integer manipulation
Author=Azret Botash;azret@attglobal.net
BCB=3,4,5
Delphi=3,4,5
[SeeAlso]
Count=4
1=LockedAdd
2=LockedSub
3=LockedExchange
4=LockedInc
<DECL>--------------------------------------------------------------------------
[Declaration]
TJclMeteredSection = class (TObject)
[ShortDescr]
Provides a fast alternative to the semaphore kernel object.
[Description]
TJclMeteredSection is basically nothing more than a semaphore kernel object except
that it is much faster. Its speed comes from the fact that unless the calling
thread has to enter a wait state, all code is executed in user mode. This in
opposition to a semaphore which always requires a transition to kernel mode.<P>
This class is (almost) a straight port from the metered section object as presented
in the article "A Quick and Versatile Synchronization Object", Dan Chou which is
available from the MSDN Library (Technical Articles\Windows Platform\MultiThreading).
[Quick Info]
BCB=3,4,5
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclMeteredSection
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function Enter(TimeOut: Longword): TJclWaitResult;
[ShortDescr]
Enters the metered section.
[Description]
The Enter method decreases the count of the metered section object thereby granting
access to the protected resource to a single thread. The method does not return
until either access was granted, the specified timeout elapses or an error
occurs.
[Parameters]
Count=1
1=TimeOut:Longword=Specifies the time-out interval, in milliseconds. The function
returns if the interval elapses, even if the metered section does not have an open
slot. If Milliseconds is zero, the function tests the metered section's state a
and returns immediately. If Milliseconds is INFINITE, the function's time-out
interval never elapses.
[Result]
If access was granted the result is wrSignaled, if the specified TimeOut elapsed
the result is wrTimeOut and if an error occured the result is wrError. Although
TJclWaitResult includes other values, these should never be encountered as the
function result.
[Notes]
Count=1
1=The EnterMeteredSection function checks for an available slot in the metered
section. If the metered section does not have an available slot, the calling
thread enters an efficient wait state. The thread consumes very little processor
time while waiting for a slot to become free.
[Quick Info]
Kind=Method
Visibility=Public
BCB=3,4,5
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclMeteredSection
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function Leave(ReleaseCount: Longint): Boolean; overload;
function Leave(ReleaseCount: Longint; var PrevCount: Longint): Boolean; overload;
[ShortDescr]
Increases the MeteredSection's count.
[Description]
The LeaveMeteredSection function increases the number of available slots of a metered
section by a specified amount but never increases past the maximum count as specified
during construction. As a result of incrementing the count one or more waiting threads
may be released from their wait state. Note that incrementing the count is not thread
bound. That is, all threads may call Leave even though they never called Enter.
[Parameters]
Count=2
1=ReleaseCount:Longint=Specifies the number of the metered section's slots to
release. The value must be greater than zero. If the specified amount would cause
the metered section's count to exceed the maximum number of available slots
specified during creation of the metered section, the number of available slots
is not changed and the function returns False.
2=PrevCount:Longint=32-bit Longint which receives the previous metered section open
slot count.
[Result]
If the function succeeds the result is True, otherwise the result is False.
[Quick Info]
Kind=Method
Visibility=Public
BCB=3,4,5
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclMeteredSection
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
constructor Create(InitialCount, MaxCount: Longint; const Name: string);
[ShortDescr]
Creates an instance of a TJclMeteredSection object.
[Description]
Creates a named or unnamed instance of a TJclMeteredSection object.
[Parameters]
Count=3
1=InitialCount:Longint=Specifies an initial count of open slots for the metered
section. This value must be greater than or equal to zero and less than or equal
to MaxCount. A slot is available when the count is greater than zero and
none is available when it is zero. The count is decreased by one whenever the
EnterMeteredSection function releases a thread that was waiting for the metered
section. The count is increased by a specified amount by calling the
LeaveMeteredSection function.
2=MaxCount:Longint=Specifies the maximum number of available slots for the metered
section. This value must be greater than zero.
3=Name:string=String specifying the name of the metered section. The name is
limited to MAX_METSECT_NAMELEN characters, and can contain any character except
the backslash path-separator character (\). Name comparison is case sensitive.<P>
If Name matches the name of an existing named metered section, the InitialCount
and MaxCount parameters are ignored because they have already been set by the
process that originally created the metered section.<P>
If Name is empty, the metered section is created without a name.
[Quick Info]
Kind=Method
Visibility=Public
BCB=3,4,5
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclMeteredSection
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
constructor Open(const Name: string);
[ShortDescr]
The Open constructor attempts to open the existing named MeteredSection specified with Name.
[Description]
Opens an existing, named MeteredSection. If the MeteredSection object does not exist, or the calling
thread does not have sufficient access to open the MeteredSection object, the constructor
fails by raising an EJclMeteredSectionError exception.
[Parameters]
Count=1
1=Name:string=Name of the MeteredSection object to open.
[Quick Info]
Kind=Method
Visibility=Public
BCB=4,5
Unit=JclSynch
Category=Libraries, Processes and Threads
SubCat=Synchronization\TJclMeteredSection
Author=Marcel van Brakel;brakelm@bart.nl
Windows NT/2000=Requires Windows NT 4 or later.
Windows 95/98=Requires Windows 95 or later.
Delphi=3,4,5
BCB=3,4,5
