{**************************************************************************************************}
{                                                                                                  }
{ Project JEDI Code Library (JCL)                                                                  }
{                                                                                                  }
{ The contents of this file are subject to the Mozilla Public License Version 1.1 (the "License"); }
{ you may not use this file except in compliance with the License. You may obtain a copy of the    }
{ License at http://www.mozilla.org/MPL/                                                           }
{                                                                                                  }
{ Software distributed under the License is distributed on an "AS IS" basis, WITHOUT WARRANTY OF   }
{ ANY KIND, either express or implied. See the License for the specific language governing rights  }
{ and limitations under the License.                                                               }
{                                                                                                  }
{ Portions of this code are translated from AclAPI.h.                                              }
{ The Initial Developer of AclAPI.h is Microsoft. Portions created by Microsoft are Copyright (C)  }
{ 1993-1999 Microsoft Corporation. All Rights Reserved.                                            }
{                                                                                                  }
{ Portions of this code are translated from AccCtrl.h.                                             }
{ The Initial Developer of AccCtrl.h is Microsoft. Portions created by Microsoft are Copyright (C) }
{ 1993-1998 Microsoft Corporation. All Rights Reserved.                                            }
{                                                                                                  }
{ Portions of this code are translated from BaseTsd.h.                                             }
{ The Initial Developer of BaseTsd.h is Microsoft. Portions created by Microsoft are Copyright (C) }
{ Microsoft Corporation. All Rights Reserved.                                                      }
{                                                                                                  }
{ Portions of this code are translated from ImageHlp.h.                                            }
{ The Initial Developer of ImageHlp.h is Microsoft. Portions created by Microsoft are Copyright    }
{ (C) Microsoft Corporation. All Rights Reserved.                                                  }
{                                                                                                  }
{ Portions of this code are translated from LMaccess.h.                                            }
{ The Initial Developer of LMaccess.h is Microsoft. Portions created by Microsoft are Copyright    }
{ (C) 1991-1999 Microsoft Corporation. All Rights Reserved.                                        }
{                                                                                                  }
{ Portions of this code are translated from LMAPIbuf.h.                                            }
{ The Initial Developer of LMAPIbuf.h is Microsoft. Portions created by Microsoft are Copyright    }
{ (C) 1991-1999 Microsoft Corporation. All Rights Reserved.                                        }
{                                                                                                  }
{ Portions of this code are translated from LMCons.h.                                              }
{ The Initial Developer of LMCons.h is Microsoft. Portions created by Microsoft are Copyright (C)  }
{ 1990-1999 Microsoft Corporation. All Rights Reserved.                                            }
{                                                                                                  }
{ Portions of this code are translated from LMErr.h.                                               }
{ The Initial Developer of LMErr.h is Microsoft. Portions created by Microsoft are Copyright (C)   }
{ 1987-1999 Microsoft Corporation. All Rights Reserved.                                            }
{                                                                                                  }
{ Portions of this code are translated from Nb30.h.                                                }
{ The Initial Developer of Nb30.h is Microsoft. Portions created by Microsoft are Copyright (C)    }
{ 1991-1999 Microsoft Corporation. All Rights Reserved.                                            }
{                                                                                                  }
{ Portions of this code are translated from ntstatus.h.                                            }
{ The Initial Developer of ntstatus.h is Microsoft. Portions created by Microsoft are Copyright    }
{ (C) Microsoft Corporation. All Rights Reserved.                                                  }
{                                                                                                  }
{ Portions of this code are translated from OleIdl.h, OleIdl.Idl.                                  }
{ The Initial Developer of OleIdl.h, OleIdl.Idl is Microsoft. Portions created by Microsoft are    }
{ Copyright (C) Microsoft Corporation. All Rights Reserved.                                        }
{                                                                                                  }
{ Portions of this code are translated from RasDlg.h.                                              }
{ The Initial Developer of RasDlg.h is Microsoft. Portions created by Microsoft are Copyright (C)  }
{ Microsoft Corporation. All Rights Reserved.                                                      }
{                                                                                                  }
{ Portions of this code are translated from Reason.h.                                              }
{ The Initial Developer of Reason.h is Microsoft. Portions created by Microsoft are Copyright (C)  }
{ Microsoft Corporation. All Rights Reserved.                                                      }
{                                                                                                  }
{ Portions of this code are translated from ShlObj.h.                                              }
{ The Initial Developer of ShlObj.h is Microsoft. Portions created by Microsoft are Copyright (C)  }
{ Microsoft Corporation. All Rights Reserved.                                                      }
{                                                                                                  }
{ Portions of this code are translated from ShlWApi.h.                                             }
{ The Initial Developer of ShlWApi.h is Microsoft. Portions created by Microsoft are Copyright (C) }
{ Microsoft Corporation. All Rights Reserved.                                                      }
{                                                                                                  }
{ Portions of this code are translated from WinBase.h.                                             }
{ The Initial Developer of WinBase.h is Microsoft. Portions created by Microsoft are Copyright (C) }
{ Microsoft Corporation. All Rights Reserved.                                                      }
{                                                                                                  }
{ Portions of this code are translated from winternl.h.                                            }
{ The Initial Developer of winternl.h is Microsoft. Portions created by Microsoft are Copyright    }
{ (C) Microsoft Corporation. All Rights Reserved.                                                  }
{                                                                                                  }
{ Portions of this code are translated from WinIoCtl.h.                                            }
{ The Initial Developer of WinIoCtl.h is Microsoft. Portions created by Microsoft are Copyright    }
{ (C) Microsoft Corporation. All Rights Reserved.                                                  }
{                                                                                                  }
{ Portions of this code are translated from WinNls.h.                                              }
{ The Initial Developer of WinNls.h is Microsoft. Portions created by Microsoft are Copyright (C)  }
{ Microsoft Corporation. All Rights Reserved.                                                      }
{                                                                                                  }
{ Portions of this code are translated from WinNT.h.                                               }
{ The Initial Developer of WinNT.h is Microsoft. Portions created by Microsoft are Copyright (C)   }
{ Microsoft Corporation. All Rights Reserved.                                                      }
{                                                                                                  }
{ Portions of this code are translated from WinReg.h.                                              }
{ The Initial Developer of WinReg.h is Microsoft. Portions created by Microsoft are Copyright (C)  }
{ Microsoft Corporation. All Rights Reserved.                                                      }
{                                                                                                  }
{ Portions of this code are translated from WinSpool.h.                                            }
{ The Initial Developer of WinSpool.h is Microsoft. Portions created by Microsoft are Copyright    }
{ (C) 1990-1998 Microsoft Corporation. All Rights Reserved.                                        }
{                                                                                                  }
{ Portions of this code are translated from WinUser.h.                                             }
{ The Initial Developer of WinUser.h is Microsoft. Portions created by Microsoft are Copyright (C) }
{ Microsoft Corporation. All Rights Reserved.                                                      }
{                                                                                                  }
{ Portions of this code are translated from WinVer.h.                                              }
{ The Initial Developer of WinVer.h is Microsoft. Portions created by Microsoft are Copyright (C)  }
{ Microsoft Corporation. All Rights Reserved.                                                      }
{                                                                                                  }
{ Portions of this code are translated from DelayImp.h.                                            }
{ The Initial Developer of DelayImp.h is Inprise Corporation. Portions created by Inprise          }
{ Corporation are Copyright (C) 1999, 2000 by Inprise Corporation. All Rights Reserved.            }
{                                                                                                  }
{ The Original Code is JclWin32.pas.                                                               }
{                                                                                                  }
{ The Initial Developers of the Original Code are documented in the accompanying help file         }
{ JCLHELP.hlp. Portions created by these individuals are Copyright (C) of these individuals.       }
{                                                                                                  }
{ Contributor(s):                                                                                  }
{   Peter Friese                                                                                   }
{   Peter J. Haas (PeterJHaas), jediplus@pjh2.de                                                   }
{                                                                                                  }
{**************************************************************************************************}
{                                                                                                  }
{ This unit defines various Win32 API declarations which are either missing or incorrect in one or }
{ more of the supported Delphi versions. This unit is not intended for regular code, only API      }
{ declarations.                                                                                    }
{                                                                                                  }
{**************************************************************************************************}

// Last modified: $Data$
// For history see end of file

unit JclWin32;

{$I jcl.inc}

{$ALIGN ON}
{$MINENUMSIZE 4}

interface

uses
  Windows, ActiveX, SysUtils, WinSpool,
  {$IFNDEF FPC}
  AccCtrl,
  {$ENDIF FPC}
  JclBase;

{$HPPEMIT '#include <winnt.h>'}   
{$HPPEMIT 'typedef _IMAGE_THUNK_DATA32 _IMAGE_THUNK_DATA;'}
{$HPPEMIT 'typedef _IMAGE_TLS_DIRECTORY32 _IMAGE_TLS_DIRECTORY;'}

{$HPPEMIT '#include <AclAPI.h>'}
{$HPPEMIT '#include <BaseTsd.h>'}
{$HPPEMIT '#include <ImageHlp.h>'}
{$HPPEMIT '#include <LMaccess.h>'}
{$HPPEMIT '#include <LMAPIbuf.h>'}
{$HPPEMIT '#include <LMcons.h>'}
{$HPPEMIT '#include <LMErr.h>'}
{$HPPEMIT '#include <nb30.h>'}
{$HPPEMIT '#include <ntstatus.h>'}
{$HPPEMIT '#include <Reason.h>'}
{$HPPEMIT '#include <RasDlg.h>'}
{$HPPEMIT '#include <ShlObj.h>'}
{$HPPEMIT '#include <ShlWApi.h>'}
{$HPPEMIT '#include <WinBase.h>'}
{$HPPEMIT '#include <WinIoCtl.h>'}
{$HPPEMIT '#include <WinNls.h>'}
{$HPPEMIT '#include <WinSpool.h>'}
{$HPPEMIT '#include <winternl.h>'}
{$HPPEMIT '#include <WinUser.h>'}

{$HPPEMIT '#include <delayimp.h>'}

//==================================================================================================
// FPC compatibility
//==================================================================================================

{$IFDEF FPC}

// from unit Windows
const
  // from WinNT.h
  FILE_ATTRIBUTE_OFFLINE = $00001000;

  // from WinReg.h
  HKEY_CLASSES_ROOT     = DWORD($80000000);
  HKEY_CURRENT_USER     = DWORD($80000001);
  HKEY_LOCAL_MACHINE    = DWORD($80000002);
  HKEY_USERS            = DWORD($80000003);
  HKEY_PERFORMANCE_DATA = DWORD($80000004);
  HKEY_CURRENT_CONFIG   = DWORD($80000005);
  HKEY_DYN_DATA         = DWORD($80000006);

  // from WinVer.h
  VOS__BASE = 0;
  VOS__WINDOWS16 = 1;
  VOS__PM16 = 2;
  VOS__PM32 = 3;
  VOS__WINDOWS32 = 4;

{ VS_VERSION.dwFileSubtype for VFT_WINDOWS_DRV }

  VFT2_UNKNOWN = 0;
  VFT2_DRV_PRINTER = 1;
  VFT2_DRV_KEYBOARD = 2;
  VFT2_DRV_LANGUAGE = 3;
  VFT2_DRV_DISPLAY = 4;
  VFT2_DRV_MOUSE = 5;
  VFT2_DRV_NETWORK = 6;
  VFT2_DRV_SYSTEM = 7;
  VFT2_DRV_INSTALLABLE = 8;
  VFT2_DRV_SOUND = 9;
  VFT2_DRV_COMM = 10;

type
  // from WinBase.h
  _GET_FILEEX_INFO_LEVELS = (GetFileExInfoStandard, GetFileExMaxInfoLevel);
  TGetFileExInfoLevels = _GET_FILEEX_INFO_LEVELS;
  GET_FILEEX_INFO_LEVELS = _GET_FILEEX_INFO_LEVELS;

type
  PKeyboardState = ^TKeyboardState;
  TKeyboardState = array[0..255] of Byte;

// from unit AccCtrl
type
  SE_OBJECT_TYPE = (
    SE_UNKNOWN_OBJECT_TYPE,
    SE_FILE_OBJECT,
    SE_SERVICE,
    SE_PRINTER,
    SE_REGISTRY_KEY,
    SE_LMSHARE,
    SE_KERNEL_OBJECT,
    SE_WINDOW_OBJECT,
    SE_DS_OBJECT,
    SE_DS_OBJECT_ALL,
    SE_PROVIDER_DEFINED_OBJECT,
    SE_WMIGUID_OBJECT
  );

// from ActiveX
const
  // from OleIdl.h, OleIdl.Idl
  DROPEFFECT_NONE   = 0;
  DROPEFFECT_COPY   = 1;
  DROPEFFECT_MOVE   = 2;
  DROPEFFECT_LINK   = 4;
  DROPEFFECT_SCROLL = DWORD($80000000);

{$ENDIF FPC}

//==================================================================================================
// from BaseTsd.h
//==================================================================================================

type
  {$EXTERNALSYM ULONG_PTR}
  ULONG_PTR = LongWord;      // Need to have the same size like Pointer
  {$EXTERNALSYM DWORD_PTR}
  DWORD_PTR = ULONG_PTR;
  {$EXTERNALSYM PDWORD_PTR}
  PDWORD_PTR = ^PLongWord;
  PDWordPtr = PDWORD_PTR;

//==================================================================================================
// from AclAPI.h
//==================================================================================================

//--------------------------------------------------------------------------------------------------
// Run time dynamic linking
//--------------------------------------------------------------------------------------------------

{ TODO : SetNamedSecurityInfo is incorrectly declared, at least for Windows 2000
  it is. D5 unit tries to import from aclapi.dll but it is located in advapi3.dll
  Have to check whether this is also true for Windows NT 4. }
{ TODO : Likely Advapi32.dll }

// At least in Win98 SE SetNamedSecurityInfoW exist and return ERROR_CALL_NOT_IMPLEMENTED
// GetLastError = ERROR_CALL_NOT_IMPLEMENTED
// This function don't exists in Win95C

function RtdlSetNamedSecurityInfoW(pObjectName: LPWSTR; ObjectType: SE_OBJECT_TYPE;
  SecurityInfo: SECURITY_INFORMATION; psidOwner, psidGroup: PSID;
  pDacl, pSacl: PACL): DWORD;

//==================================================================================================
// from Nb30.h  Netbios (incorrect/inconvenient declarations in rtl)
//==================================================================================================

const
  {$EXTERNALSYM NCBNAMSZ}
  NCBNAMSZ    = 16;        // absolute length of a net name
  {$EXTERNALSYM MAX_LANA}
  MAX_LANA    = 254;       // lana's in range 0 to MAX_LANA inclusive

  {$EXTERNALSYM NRC_GOODRET}
  NRC_GOODRET = $00;       // good return
                           // also returned when ASYNCH request accepted
  {$EXTERNALSYM NRC_OPENERR}
  NRC_OPENERR = $3f;       // NETBIOS not loaded

  {$EXTERNALSYM NCBASTAT}
  NCBRESET    = $32;       // NCB RESET
  {$EXTERNALSYM NCBRESET}
  NCBASTAT    = $33;       // NCB ADAPTER STATUS
  {$EXTERNALSYM NCBENUM}
  NCBENUM     = $37;       // NCB ENUMERATE LANA NUMBERS

// Network Control Block
type
  {$EXTERNALSYM PNCB}
  PNCB = ^_NCB;
  {$EXTERNALSYM _NCB}
  _NCB = packed record
    ncb_command: UCHAR;                              // command code
    ncb_retcode: UCHAR;                              // return code
    ncb_lsn: UCHAR;                                  // local session number
    ncb_num: UCHAR;                                  // number of our network name
    ncb_buffer: PAnsiChar;                           // address of message buffer
    ncb_length: WORD;                                // size of message buffer
    ncb_callname: array[0..NCBNAMSZ-1] of AnsiChar;  // blank-padded name of remote
    ncb_name: array[0..NCBNAMSZ-1] of AnsiChar;      // our blank-padded netname
    ncb_rto: UCHAR;                                  // rcv timeout/retry count
    ncb_sto: UCHAR;                                  // send timeout/sys timeout
    ncb_post: procedure(pnbc: PNCB); stdcall;        // POST routine address
    ncb_lana_num: UCHAR;                             // lana (adapter) number
    ncb_cmd_cplt: UCHAR;                             // 0xff => commmand pending
    {$IFDEF _WIN64}
    ncb_reserve: array[0..17] of AnsiChar;           // reserved, used by BIOS
    {$ELSE}
    ncb_reserve: array[0..9] of AnsiChar;            // reserved, used by BIOS
    {$ENDIF}
    ncb_event: THandle;                              // HANDLE to Win32 event which
                                                     // will be set to the signalled
                                                     // state when an ASYNCH command
                                                     // completes
  end;
  {$EXTERNALSYM NCB}
  NCB = _NCB;
  TNCB = _NCB;

//  Structure returned to the NCB command NCBASTAT is ADAPTER_STATUS followed
//  by an array of NAME_BUFFER structures.

type
  {$EXTERNALSYM _ADAPTER_STATUS}
  _ADAPTER_STATUS = packed record
    adapter_address: array[0..5] of AnsiChar;
    rev_major: UCHAR;
    reserved0: UCHAR;
    adapter_type: UCHAR;
    rev_minor: UCHAR;
    duration: WORD;
    frmr_recv: WORD;
    frmr_xmit: WORD;

    iframe_recv_err: WORD;

    xmit_aborts: WORD;
    xmit_success: DWORD;
    recv_success: DWORD;

    iframe_xmit_err: WORD;

    recv_buff_unavail: WORD;
    t1_timeouts: WORD;
    ti_timeouts: WORD;
    reserved1: DWORD;
    free_ncbs: WORD;
    max_cfg_ncbs: WORD;
    max_ncbs: WORD;
    xmit_buf_unavail: WORD;
    max_dgram_size: WORD;
    pending_sess: WORD;
    max_cfg_sess: WORD;
    max_sess: WORD;
    max_sess_pkt_size: WORD;
    name_count: WORD;
  end;
  {$EXTERNALSYM ADAPTER_STATUS}
  ADAPTER_STATUS = _ADAPTER_STATUS;
  {$EXTERNALSYM PADAPTER_STATUS}
  PADAPTER_STATUS = ^_ADAPTER_STATUS;
  TAdapterStatus = _ADAPTER_STATUS;
  PAdapterStatus = PADAPTER_STATUS;

  {$EXTERNALSYM _NAME_BUFFER}
  _NAME_BUFFER = packed record
    name: array[0..NCBNAMSZ-1] of AnsiChar;
    name_num: UCHAR;
    name_flags: UCHAR;
  end;
  {$EXTERNALSYM NAME_BUFFER}
  NAME_BUFFER = _NAME_BUFFER;
  {$EXTERNALSYM PNAME_BUFFER}
  PNAME_BUFFER = ^_NAME_BUFFER;
  TNameBuffer = _NAME_BUFFER;
  PNameBuffer = PNAME_BUFFER;

  // Structure returned to the NCB command NCBENUM.
  //
  // On a system containing lana's 0, 2 and 3, a structure with
  // length =3, lana[0]=0, lana[1]=2 and lana[2]=3 will be returned.
  {$EXTERNALSYM NAME_BUFFER}
  _LANA_ENUM = packed record
    length: UCHAR;         //  Number of valid entries in lana[]
    lana: array[0..MAX_LANA] of UCHAR;
  end;
  {$EXTERNALSYM LANA_ENUM}
  LANA_ENUM = _LANA_ENUM;
  {$EXTERNALSYM PLANA_ENUM}
  PLANA_ENUM = ^_LANA_ENUM;
  TLanaEnum = _LANA_ENUM;
  PLanaEnum = PLANA_ENUM;

//--------------------------------------------------------------------------------------------------
// Run time dynamic linking
//--------------------------------------------------------------------------------------------------

// return NRC_OPENERR, if the function can not be linked
function RtdlNetBios(P: PNCB): UCHAR;

//==================================================================================================
// from Reason.h
//==================================================================================================

const
  {$EXTERNALSYM SHTDN_REASON_MAJOR_APPLICATION}
  SHTDN_REASON_MAJOR_APPLICATION          = $00040000;
  {$EXTERNALSYM SHTDN_REASON_MINOR_OTHER}
  SHTDN_REASON_MINOR_OTHER                = $00000000;

//==================================================================================================
// from WinNls.h
//==================================================================================================

const
  {$EXTERNALSYM LCID_ALTERNATE_SORTS}
  LCID_ALTERNATE_SORTS      = $00000004;

  {$EXTERNALSYM CP_THREAD_ACP}
  CP_THREAD_ACP             = 3;
  {$EXTERNALSYM CP_SYMBOL}
  CP_SYMBOL                 = 42;

  {$EXTERNALSYM CTRY_ALBANIA}
  CTRY_ALBANIA              = 355;        // Albania
  {$EXTERNALSYM CTRY_ALGERIA}
  CTRY_ALGERIA              = 213;        // Algeria
  {$EXTERNALSYM CTRY_ARGENTINA}
  CTRY_ARGENTINA            = 54;         // Argentina
  {$EXTERNALSYM CTRY_ARMENIA}
  CTRY_ARMENIA              = 374;        // Armenia
  {$EXTERNALSYM CTRY_AUSTRALIA}
  CTRY_AUSTRALIA            = 61;         // Australia
  {$EXTERNALSYM CTRY_AUSTRIA}
  CTRY_AUSTRIA              = 43;         // Austria
  {$EXTERNALSYM CTRY_AZERBAIJAN}
  CTRY_AZERBAIJAN           = 994;        // Azerbaijan
  {$EXTERNALSYM CTRY_BAHRAIN}
  CTRY_BAHRAIN              = 973;        // Bahrain
  {$EXTERNALSYM CTRY_BELARUS}
  CTRY_BELARUS              = 375;        // Belarus
  {$EXTERNALSYM CTRY_BELGIUM}
  CTRY_BELGIUM              = 32;         // Belgium
  {$EXTERNALSYM CTRY_BELIZE}
  CTRY_BELIZE               = 501;        // Belize
  {$EXTERNALSYM CTRY_BOLIVIA}
  CTRY_BOLIVIA              = 591;        // Bolivia
  {$EXTERNALSYM CTRY_BRAZIL}
  CTRY_BRAZIL               = 55;         // Brazil
  {$EXTERNALSYM CTRY_BRUNEI_DARUSSALAM}
  CTRY_BRUNEI_DARUSSALAM    = 673;        // Brunei Darussalam
  {$EXTERNALSYM CTRY_BULGARIA}
  CTRY_BULGARIA             = 359;        // Bulgaria
  {$EXTERNALSYM CTRY_CANADA}
  CTRY_CANADA               = 2;          // Canada
  {$EXTERNALSYM CTRY_CARIBBEAN}
  CTRY_CARIBBEAN            = 1;          // Caribbean
  {$EXTERNALSYM CTRY_CHILE}
  CTRY_CHILE                = 56;         // Chile
  {$EXTERNALSYM CTRY_COLOMBIA}
  CTRY_COLOMBIA             = 57;         // Colombia
  {$EXTERNALSYM CTRY_COSTA_RICA}
  CTRY_COSTA_RICA           = 506;        // Costa Rica
  {$EXTERNALSYM CTRY_CROATIA}
  CTRY_CROATIA              = 385;        // Croatia
  {$EXTERNALSYM CTRY_CZECH}
  CTRY_CZECH                = 420;        // Czech Republic
  {$EXTERNALSYM CTRY_DENMARK}
  CTRY_DENMARK              = 45;         // Denmark
  {$EXTERNALSYM CTRY_DOMINICAN_REPUBLIC}
  CTRY_DOMINICAN_REPUBLIC   = 1;          // Dominican Republic
  {$EXTERNALSYM CTRY_ECUADOR}
  CTRY_ECUADOR              = 593;        // Ecuador
  {$EXTERNALSYM CTRY_EGYPT}
  CTRY_EGYPT                = 20;         // Egypt
  {$EXTERNALSYM CTRY_EL_SALVADOR}
  CTRY_EL_SALVADOR          = 503;        // El Salvador
  {$EXTERNALSYM CTRY_ESTONIA}
  CTRY_ESTONIA              = 372;        // Estonia
  {$EXTERNALSYM CTRY_FAEROE_ISLANDS}
  CTRY_FAEROE_ISLANDS       = 298;        // Faeroe Islands
  {$EXTERNALSYM CTRY_FINLAND}
  CTRY_FINLAND              = 358;        // Finland
  {$EXTERNALSYM CTRY_FRANCE}
  CTRY_FRANCE               = 33;         // France
  {$EXTERNALSYM CTRY_GEORGIA}
  CTRY_GEORGIA              = 995;        // Georgia
  {$EXTERNALSYM CTRY_GERMANY}
  CTRY_GERMANY              = 49;         // Germany
  {$EXTERNALSYM CTRY_GREECE}
  CTRY_GREECE               = 30;         // Greece
  {$EXTERNALSYM CTRY_GUATEMALA}
  CTRY_GUATEMALA            = 502;        // Guatemala
  {$EXTERNALSYM CTRY_HONDURAS}
  CTRY_HONDURAS             = 504;        // Honduras
  {$EXTERNALSYM CTRY_HONG_KONG}
  CTRY_HONG_KONG            = 852;        // Hong Kong S.A.R., P.R.C.
  {$EXTERNALSYM CTRY_HUNGARY}
  CTRY_HUNGARY              = 36;         // Hungary
  {$EXTERNALSYM CTRY_ICELAND}
  CTRY_ICELAND              = 354;        // Iceland
  {$EXTERNALSYM CTRY_INDIA}
  CTRY_INDIA                = 91;         // India
  {$EXTERNALSYM CTRY_INDONESIA}
  CTRY_INDONESIA            = 62;         // Indonesia
  {$EXTERNALSYM CTRY_IRAN}
  CTRY_IRAN                 = 981;        // Iran
  {$EXTERNALSYM CTRY_IRAQ}
  CTRY_IRAQ                 = 964;        // Iraq
  {$EXTERNALSYM CTRY_IRELAND}
  CTRY_IRELAND              = 353;        // Ireland
  {$EXTERNALSYM CTRY_ISRAEL}
  CTRY_ISRAEL               = 972;        // Israel
  {$EXTERNALSYM CTRY_ITALY}
  CTRY_ITALY                = 39;         // Italy
  {$EXTERNALSYM CTRY_JAMAICA}
  CTRY_JAMAICA              = 1;          // Jamaica
  {$EXTERNALSYM CTRY_JAPAN}
  CTRY_JAPAN                = 81;         // Japan
  {$EXTERNALSYM CTRY_JORDAN}
  CTRY_JORDAN               = 962;        // Jordan
  {$EXTERNALSYM CTRY_KAZAKSTAN}
  CTRY_KAZAKSTAN            = 7;          // Kazakstan
  {$EXTERNALSYM CTRY_KENYA}
  CTRY_KENYA                = 254;        // Kenya
  {$EXTERNALSYM CTRY_KUWAIT}
  CTRY_KUWAIT               = 965;        // Kuwait
  {$EXTERNALSYM CTRY_KYRGYZSTAN}
  CTRY_KYRGYZSTAN           = 996;        // Kyrgyzstan
  {$EXTERNALSYM CTRY_LATVIA}
  CTRY_LATVIA               = 371;        // Latvia
  {$EXTERNALSYM CTRY_LEBANON}
  CTRY_LEBANON              = 961;        // Lebanon
  {$EXTERNALSYM CTRY_LIBYA}
  CTRY_LIBYA                = 218;        // Libya
  {$EXTERNALSYM CTRY_LIECHTENSTEIN}
  CTRY_LIECHTENSTEIN        = 41;         // Liechtenstein
  {$EXTERNALSYM CTRY_LITHUANIA}
  CTRY_LITHUANIA            = 370;        // Lithuania
  {$EXTERNALSYM CTRY_LUXEMBOURG}
  CTRY_LUXEMBOURG           = 352;        // Luxembourg
  {$EXTERNALSYM CTRY_MACAU}
  CTRY_MACAU                = 853;        // Macau S.A.R., PRC
  {$EXTERNALSYM CTRY_MACEDONIA}
  CTRY_MACEDONIA            = 389;        // Former Yugoslav Republic of Macedonia
  {$EXTERNALSYM CTRY_MALAYSIA}
  CTRY_MALAYSIA             = 60;         // Malaysia
  {$EXTERNALSYM CTRY_MALDIVES}
  CTRY_MALDIVES             = 960;        // Maldives
  {$EXTERNALSYM CTRY_MEXICO}
  CTRY_MEXICO               = 52;         // Mexico
  {$EXTERNALSYM CTRY_MONACO}
  CTRY_MONACO               = 33;         // Principality of Monaco
  {$EXTERNALSYM CTRY_MONGOLIA}
  CTRY_MONGOLIA             = 976;        // Mongolia
  {$EXTERNALSYM CTRY_MOROCCO}
  CTRY_MOROCCO              = 212;        // Morocco
  {$EXTERNALSYM CTRY_NETHERLANDS}
  CTRY_NETHERLANDS          = 31;         // Netherlands
  {$EXTERNALSYM CTRY_NEW_ZEALAND}
  CTRY_NEW_ZEALAND          = 64;         // New Zealand
  {$EXTERNALSYM CTRY_NICARAGUA}
  CTRY_NICARAGUA            = 505;        // Nicaragua
  {$EXTERNALSYM CTRY_NORWAY}
  CTRY_NORWAY               = 47;         // Norway
  {$EXTERNALSYM CTRY_OMAN}
  CTRY_OMAN                 = 968;        // Oman
  {$EXTERNALSYM CTRY_PAKISTAN}
  CTRY_PAKISTAN             = 92;         // Islamic Republic of Pakistan
  {$EXTERNALSYM CTRY_PANAMA}
  CTRY_PANAMA               = 507;        // Panama
  {$EXTERNALSYM CTRY_PARAGUAY}
  CTRY_PARAGUAY             = 595;        // Paraguay
  {$EXTERNALSYM CTRY_PERU}
  CTRY_PERU                 = 51;         // Peru
  {$EXTERNALSYM CTRY_PHILIPPINES}
  CTRY_PHILIPPINES          = 63;         // Republic of the Philippines
  {$EXTERNALSYM CTRY_POLAND}
  CTRY_POLAND               = 48;         // Poland
  {$EXTERNALSYM CTRY_PORTUGAL}
  CTRY_PORTUGAL             = 351;        // Portugal
  {$EXTERNALSYM CTRY_PRCHINA}
  CTRY_PRCHINA              = 86;         // People's Republic of China
  {$EXTERNALSYM CTRY_PUERTO_RICO}
  CTRY_PUERTO_RICO          = 1;          // Puerto Rico
  {$EXTERNALSYM CTRY_QATAR}
  CTRY_QATAR                = 974;        // Qatar
  {$EXTERNALSYM CTRY_ROMANIA}
  CTRY_ROMANIA              = 40;         // Romania
  {$EXTERNALSYM CTRY_RUSSIA}
  CTRY_RUSSIA               = 7;          // Russia
  {$EXTERNALSYM CTRY_SAUDI_ARABIA}
  CTRY_SAUDI_ARABIA         = 966;        // Saudi Arabia
  {$EXTERNALSYM CTRY_SERBIA}
  CTRY_SERBIA               = 381;        // Serbia
  {$EXTERNALSYM CTRY_SINGAPORE}
  CTRY_SINGAPORE            = 65;         // Singapore
  {$EXTERNALSYM CTRY_SLOVAK}
  CTRY_SLOVAK               = 421;        // Slovak Republic
  {$EXTERNALSYM CTRY_SLOVENIA}
  CTRY_SLOVENIA             = 386;        // Slovenia
  {$EXTERNALSYM CTRY_SOUTH_AFRICA}
  CTRY_SOUTH_AFRICA         = 27;         // South Africa
  {$EXTERNALSYM CTRY_SOUTH_KOREA}
  CTRY_SOUTH_KOREA          = 82;         // Korea
  {$EXTERNALSYM CTRY_SPAIN}
  CTRY_SPAIN                = 34;         // Spain
  {$EXTERNALSYM CTRY_SWEDEN}
  CTRY_SWEDEN               = 46;         // Sweden
  {$EXTERNALSYM CTRY_SWITZERLAND}
  CTRY_SWITZERLAND          = 41;         // Switzerland
  {$EXTERNALSYM CTRY_SYRIA}
  CTRY_SYRIA                = 963;        // Syria
  {$EXTERNALSYM CTRY_TAIWAN}
  CTRY_TAIWAN               = 886;        // Taiwan
  {$EXTERNALSYM CTRY_TATARSTAN}
  CTRY_TATARSTAN            = 7;          // Tatarstan
  {$EXTERNALSYM CTRY_THAILAND}
  CTRY_THAILAND             = 66;         // Thailand
  {$EXTERNALSYM CTRY_TRINIDAD_Y_TOBAGO}
  CTRY_TRINIDAD_Y_TOBAGO    = 1;          // Trinidad y Tobago
  {$EXTERNALSYM CTRY_TUNISIA}
  CTRY_TUNISIA              = 216;        // Tunisia
  {$EXTERNALSYM CTRY_TURKEY}
  CTRY_TURKEY               = 90;         // Turkey
  {$EXTERNALSYM CTRY_UAE}
  CTRY_UAE                  = 971;        // U.A.E.
  {$EXTERNALSYM CTRY_UKRAINE}
  CTRY_UKRAINE              = 380;        // Ukraine
  {$EXTERNALSYM CTRY_UNITED_KINGDOM}
  CTRY_UNITED_KINGDOM       = 44;         // United Kingdom
  {$EXTERNALSYM CTRY_UNITED_STATES}
  CTRY_UNITED_STATES        = 1;          // United States
  {$EXTERNALSYM CTRY_URUGUAY}
  CTRY_URUGUAY              = 598;        // Uruguay
  {$EXTERNALSYM CTRY_UZBEKISTAN}
  CTRY_UZBEKISTAN           = 7;          // Uzbekistan
  {$EXTERNALSYM CTRY_VENEZUELA}
  CTRY_VENEZUELA            = 58;         // Venezuela
  {$EXTERNALSYM CTRY_VIET_NAM}
  CTRY_VIET_NAM             = 84;         // Viet Nam
  {$EXTERNALSYM CTRY_YEMEN}
  CTRY_YEMEN                = 967;        // Yemen
  {$EXTERNALSYM CTRY_ZIMBABWE}
  CTRY_ZIMBABWE             = 263;        // Zimbabwe

  {$EXTERNALSYM LOCALE_RETURN_NUMBER}
  LOCALE_RETURN_NUMBER          = $20000000;

  {$EXTERNALSYM LOCALE_IDEFAULTEBCDICCODEPAGE}
  LOCALE_IDEFAULTEBCDICCODEPAGE = $00001012;
  {$EXTERNALSYM LOCALE_IPAPERSIZE}
  LOCALE_IPAPERSIZE             = $0000100A;
  {$EXTERNALSYM LOCALE_SENGCURRNAME}
  LOCALE_SENGCURRNAME           = $00001007;
  {$EXTERNALSYM LOCALE_SNATIVECURRNAME}
  LOCALE_SNATIVECURRNAME        = $00001008;
  {$EXTERNALSYM LOCALE_SYEARMONTH}
  LOCALE_SYEARMONTH             = $00001006;
  {$EXTERNALSYM LOCALE_SSORTNAME}
  LOCALE_SSORTNAME              = $00001013;
  {$EXTERNALSYM LOCALE_IDIGITSUBSTITUTION}
  LOCALE_IDIGITSUBSTITUTION     = $00001014;

  {$EXTERNALSYM DATE_YEARMONTH}
  DATE_YEARMONTH            = $00000008;
  {$EXTERNALSYM DATE_LTRREADING}
  DATE_LTRREADING           = $00000010;
  {$EXTERNALSYM DATE_RTLREADING}
  DATE_RTLREADING           = $00000020;

  {$EXTERNALSYM CAL_SYEARMONTH}
  CAL_SYEARMONTH            = $0000002F;
  {$EXTERNALSYM CAL_ITWODIGITYEARMAX}
  CAL_ITWODIGITYEARMAX      = $00000030;

  {$EXTERNALSYM CAL_NOUSEROVERRIDE}
  CAL_NOUSEROVERRIDE        = LOCALE_NOUSEROVERRIDE;
  {$EXTERNALSYM CAL_USE_CP_ACP}
  CAL_USE_CP_ACP            = LOCALE_USE_CP_ACP;
  {$EXTERNALSYM CAL_RETURN_NUMBER}
  CAL_RETURN_NUMBER         = LOCALE_RETURN_NUMBER;

  {$EXTERNALSYM CAL_GREGORIAN_ME_FRENCH}
  CAL_GREGORIAN_ME_FRENCH      = 9;       // Gregorian Middle East French calendar
  {$EXTERNALSYM CAL_GREGORIAN_ARABIC}
  CAL_GREGORIAN_ARABIC         = 10;      // Gregorian Arabic calendar
  {$EXTERNALSYM CAL_GREGORIAN_XLIT_ENGLISH}
  CAL_GREGORIAN_XLIT_ENGLISH   = 11;      // Gregorian Transliterated English calendar
  {$EXTERNALSYM CAL_GREGORIAN_XLIT_FRENCH}
  CAL_GREGORIAN_XLIT_FRENCH    = 12;      // Gregorian Transliterated French calendar

  {$EXTERNALSYM LGRPID_WESTERN_EUROPE}
  LGRPID_WESTERN_EUROPE        = $0001;   // Western Europe & U.S.
  {$EXTERNALSYM LGRPID_CENTRAL_EUROPE}
  LGRPID_CENTRAL_EUROPE        = $0002;   // Central Europe
  {$EXTERNALSYM LGRPID_BALTIC}
  LGRPID_BALTIC                = $0003;   // Baltic
  {$EXTERNALSYM LGRPID_GREEK}
  LGRPID_GREEK                 = $0004;   // Greek
  {$EXTERNALSYM LGRPID_CYRILLIC}
  LGRPID_CYRILLIC              = $0005;   // Cyrillic
  {$EXTERNALSYM LGRPID_TURKISH}
  LGRPID_TURKISH               = $0006;   // Turkish
  {$EXTERNALSYM LGRPID_JAPANESE}
  LGRPID_JAPANESE              = $0007;   // Japanese
  {$EXTERNALSYM LGRPID_KOREAN}
  LGRPID_KOREAN                = $0008;   // Korean
  {$EXTERNALSYM LGRPID_TRADITIONAL_CHINESE}
  LGRPID_TRADITIONAL_CHINESE   = $0009;   // Traditional Chinese
  {$EXTERNALSYM LGRPID_SIMPLIFIED_CHINESE}
  LGRPID_SIMPLIFIED_CHINESE    = $000A;   // Simplified Chinese
  {$EXTERNALSYM LGRPID_THAI}
  LGRPID_THAI                  = $000B;   // Thai
  {$EXTERNALSYM LGRPID_HEBREW}
  LGRPID_HEBREW                = $000C;   // Hebrew
  {$EXTERNALSYM LGRPID_ARABIC}
  LGRPID_ARABIC                = $000D;   // Arabic
  {$EXTERNALSYM LGRPID_VIETNAMESE}
  LGRPID_VIETNAMESE            = $000E;   // Vietnamese
  {$EXTERNALSYM LGRPID_INDIC}
  LGRPID_INDIC                 = $000F;   // Indic
  {$EXTERNALSYM LGRPID_GEORGIAN}
  LGRPID_GEORGIAN              = $0010;   // Georgian
  {$EXTERNALSYM LGRPID_ARMENIAN}
  LGRPID_ARMENIAN              = $0011;   // Armenian

{$EXTERNALSYM LANGIDFROMLCID}
function LANGIDFROMLCID(const lcid: LCID): Word; // Macro
{$EXTERNALSYM MAKELANGID}
function MAKELANGID(const usPrimaryLanguage, usSubLanguage: Byte): Word; // Macro
{$EXTERNALSYM PRIMARYLANGID}
function PRIMARYLANGID(const lgid: Word): Word; // Macro
{$EXTERNALSYM SUBLANGID}
function SUBLANGID(const lgid: Word): Word; // Macro
{$EXTERNALSYM MAKELCID}
function MAKELCID(const wLanguageID, wSortID: Word): LCID; // Macro
{$EXTERNALSYM SORTIDFROMLCID}
function SORTIDFROMLCID(const lcid: LCID): Word; // Macro

type
  {$EXTERNALSYM CALINFO_ENUMPROCEXA}
  CALINFO_ENUMPROCEXA = function(lpCalendarInfoString: PAnsiChar; Calendar: CALID): BOOL; stdcall;
  TCalInfoEnumProcExA = CALINFO_ENUMPROCEXA;

//--------------------------------------------------------------------------------------------------
// Run time dynamic linking
//--------------------------------------------------------------------------------------------------

function RtdlGetCalendarInfoA(Locale: LCID; Calendar: CALID; CalType: CALTYPE;
  lpCalData: PAnsiChar; cchData: Integer; lpValue: PDWORD): Integer;
function RtdlGetCalendarInfoW(Locale: LCID; Calendar: CALID; CalType: CALTYPE;
  lpCalData: PWideChar; cchData: Integer; lpValue: PDWORD): Integer;

function RtdlSetCalendarInfoA(Locale: LCID; Calendar: CALID; CalType: CALTYPE;
  lpCalData: PAnsiChar): Integer;
function RtdlSetCalendarInfoW(Locale: LCID; Calendar: CALID; CalType: CALTYPE;
  lpCalData: PWideChar): Integer;

function RtdlEnumCalendarInfoExA(lpCalInfoEnumProc: TCalInfoEnumProcExA;
  Locale: LCID; Calendar: CALID; CalType: CALTYPE): BOOL;

//==================================================================================================
// from WinNT.h
//==================================================================================================

type
  {$EXTERNALSYM PSTR}
  PSTR = PAnsiChar;
  {$EXTERNALSYM PCSTR}
  PCSTR = PAnsiChar;

//--------------------------------------------------------------------------------------------------
// ImageHlp related declarations (WinNT.h)
//--------------------------------------------------------------------------------------------------

{$IFNDEF FPC}
type
  {$EXTERNALSYM PIMAGE_NT_HEADERS}
  PIMAGE_NT_HEADERS = PImageNtHeaders;
  {$EXTERNALSYM PIMAGE_SECTION_HEADER}
  PIMAGE_SECTION_HEADER = PImageSectionHeader;
{$ENDIF ~FPC}

//--------------------------------------------------------------------------------------------------
// Registry related declarations (WinNT.h)
//--------------------------------------------------------------------------------------------------

const
  {$EXTERNALSYM REG_QWORD}
  REG_QWORD               = 11;  // 64-bit number
  {$EXTERNALSYM REG_QWORD_LITTLE_ENDIAN}
  REG_QWORD_LITTLE_ENDIAN = 11;  // 64-bit number (same as REG_QWORD)

//--------------------------------------------------------------------------------------------------
// Version related declarations (WinNT.h)
//--------------------------------------------------------------------------------------------------

const
  // ProductType
  {$EXTERNALSYM VER_NT_WORKSTATION}
  VER_NT_WORKSTATION                 = $0000001;
  {$EXTERNALSYM VER_NT_DOMAIN_CONTROLLER}
  VER_NT_DOMAIN_CONTROLLER           = $0000002;
  {$EXTERNALSYM VER_NT_SERVER}
  VER_NT_SERVER                      = $0000003;

  // SuiteMask
  {$EXTERNALSYM VER_SUITE_SMALLBUSINESS}
  VER_SUITE_SMALLBUSINESS            = $00000001;
  {$EXTERNALSYM VER_SUITE_ENTERPRISE}
  VER_SUITE_ENTERPRISE               = $00000002;
  {$EXTERNALSYM VER_SUITE_BACKOFFICE}
  VER_SUITE_BACKOFFICE               = $00000004;
  {$EXTERNALSYM VER_SUITE_COMMUNICATIONS}
  VER_SUITE_COMMUNICATIONS           = $00000008;
  {$EXTERNALSYM VER_SUITE_TERMINAL}
  VER_SUITE_TERMINAL                 = $00000010;
  {$EXTERNALSYM VER_SUITE_SMALLBUSINESS_RESTRICTED}
  VER_SUITE_SMALLBUSINESS_RESTRICTED = $00000020;
  {$EXTERNALSYM VER_SUITE_EMBEDDEDNT}
  VER_SUITE_EMBEDDEDNT               = $00000040;
  {$EXTERNALSYM VER_SUITE_DATACENTER}
  VER_SUITE_DATACENTER               = $00000080;
  {$EXTERNALSYM VER_SUITE_SINGLEUSERTS}
  VER_SUITE_SINGLEUSERTS             = $00000100;
  {$EXTERNALSYM VER_SUITE_PERSONAL}
  VER_SUITE_PERSONAL                 = $00000200;
  {$EXTERNALSYM VER_SUITE_BLADE}
  VER_SUITE_BLADE                    = $00000400;
  {$EXTERNALSYM VER_SUITE_EMBEDDED_RESTRICTED}
  VER_SUITE_EMBEDDED_RESTRICTED      = $00000800;
  {$EXTERNALSYM VER_SUITE_SECURITY_APPLIANCE}
  VER_SUITE_SECURITY_APPLIANCE       = $00001000;

  {$EXTERNALSYM VER_SUITE_SERVERAPPLIANCE}
  VER_SUITE_SERVERAPPLIANCE          = $00000400;  // not part of the current Platform SDK

type
  {$EXTERNALSYM _OSVERSIONINFOEXA}
  _OSVERSIONINFOEXA = packed record
    dwOSVersionInfoSize: DWORD;
    dwMajorVersion: DWORD;
    dwMinorVersion: DWORD;
    dwBuildNumber: DWORD;
    dwPlatformId: DWORD;
    szCSDVersion: array[0..127] of AnsiChar;     // Maintenance string for PSS usage
    wServicePackMajor: WORD;
    wServicePackMinor: WORD;
    wSuiteMask: WORD;
    wProductType: BYTE;
    wReserved: BYTE;
  end;
  {$EXTERNALSYM OSVERSIONINFOEXA}
  OSVERSIONINFOEXA = _OSVERSIONINFOEXA;
  {$EXTERNALSYM POSVERSIONINFOEXA}
  POSVERSIONINFOEXA = ^_OSVERSIONINFOEXA;
  {$EXTERNALSYM LPOSVERSIONINFOEXA}
  LPOSVERSIONINFOEXA = POSVERSIONINFOEXA;
  TOSVersionInfoEx = _OSVERSIONINFOEXA;
  POSVersionInfoEx = POSVersionInfoExA;

//--------------------------------------------------------------------------------------------------
// Security related declarations (WinNT.h)
//--------------------------------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Universal well-known SIDs                                               //
//                                                                         //
//     Null SID                     S-1-0-0                                //
//     World                        S-1-1-0                                //
//     Local                        S-1-2-0                                //
//     Creator Owner ID             S-1-3-0                                //
//     Creator Group ID             S-1-3-1                                //
//     Creator Owner Server ID      S-1-3-2                                //
//     Creator Group Server ID      S-1-3-3                                //
//                                                                         //
//     (Non-unique IDs)             S-1-4                                  //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

const
  {$EXTERNALSYM SECURITY_NULL_SID_AUTHORITY}
  SECURITY_NULL_SID_AUTHORITY: TSidIdentifierAuthority = (Value: (0, 0, 0, 0, 0, 0));
  {$EXTERNALSYM SECURITY_WORLD_SID_AUTHORITY}
  SECURITY_WORLD_SID_AUTHORITY: TSidIdentifierAuthority = (Value: (0, 0, 0, 0, 0, 1));
  {$EXTERNALSYM SECURITY_LOCAL_SID_AUTHORITY}
  SECURITY_LOCAL_SID_AUTHORITY: TSidIdentifierAuthority = (Value: (0, 0, 0, 0, 0, 2));
  {$EXTERNALSYM SECURITY_CREATOR_SID_AUTHORITY}
  SECURITY_CREATOR_SID_AUTHORITY: TSidIdentifierAuthority = (Value: (0, 0, 0, 0, 0, 3));
  {$EXTERNALSYM SECURITY_NON_UNIQUE_AUTHORITY}
  SECURITY_NON_UNIQUE_AUTHORITY: TSidIdentifierAuthority = (Value: (0, 0, 0, 0, 0, 4));

  {$EXTERNALSYM SECURITY_NULL_RID}
  SECURITY_NULL_RID                 = ($00000000);
  {$EXTERNALSYM SECURITY_WORLD_RID}
  SECURITY_WORLD_RID                = ($00000000);
  {$EXTERNALSYM SECURITY_LOCAL_RID}
  SECURITY_LOCAL_RID                = ($00000000);

  {$EXTERNALSYM SECURITY_CREATOR_OWNER_RID}
  SECURITY_CREATOR_OWNER_RID        = ($00000000);
  {$EXTERNALSYM SECURITY_CREATOR_GROUP_RID}
  SECURITY_CREATOR_GROUP_RID        = ($00000001);

  {$EXTERNALSYM SECURITY_CREATOR_OWNER_SERVER_RID}
  SECURITY_CREATOR_OWNER_SERVER_RID = ($00000002);
  {$EXTERNALSYM SECURITY_CREATOR_GROUP_SERVER_RID}
  SECURITY_CREATOR_GROUP_SERVER_RID = ($00000003);


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// NT well-known SIDs                                                      //
//                                                                         //
//     NT Authority          S-1-5                                         //
//     Dialup                S-1-5-1                                       //
//                                                                         //
//     Network               S-1-5-2                                       //
//     Batch                 S-1-5-3                                       //
//     Interactive           S-1-5-4                                       //
//     Service               S-1-5-6                                       //
//     AnonymousLogon        S-1-5-7       (aka null logon session)        //
//     Proxy                 S-1-5-8                                       //
//     ServerLogon           S-1-5-9       (aka domain controller account) //
//     Self                  S-1-5-10      (self RID)                      //
//     Authenticated User    S-1-5-11      (Authenticated user somewhere)  //
//     Restricted Code       S-1-5-12      (Running restricted code)       //
//     Terminal Server       S-1-5-13      (Running on Terminal Server)    //
//                                                                         //
//     (Logon IDs)           S-1-5-5-X-Y                                   //
//                                                                         //
//     (NT non-unique IDs)   S-1-5-0x15-...                                //
//                                                                         //
//     (Built-in domain)     s-1-5-0x20                                    //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

const
  {$EXTERNALSYM SECURITY_NT_AUTHORITY}
  SECURITY_NT_AUTHORITY: TSidIdentifierAuthority = (Value: (0, 0, 0, 0, 0, 5));

  {$EXTERNALSYM SECURITY_DIALUP_RID}
  SECURITY_DIALUP_RID                 = ($00000001);
  {$EXTERNALSYM SECURITY_NETWORK_RID}
  SECURITY_NETWORK_RID                = ($00000002);
  {$EXTERNALSYM SECURITY_BATCH_RID}
  SECURITY_BATCH_RID                  = ($00000003);
  {$EXTERNALSYM SECURITY_INTERACTIVE_RID}
  SECURITY_INTERACTIVE_RID            = ($00000004);
  {$EXTERNALSYM SECURITY_SERVICE_RID}
  SECURITY_SERVICE_RID                = ($00000006);
  {$EXTERNALSYM SECURITY_ANONYMOUS_LOGON_RID}
  SECURITY_ANONYMOUS_LOGON_RID        = ($00000007);
  {$EXTERNALSYM SECURITY_PROXY_RID}
  SECURITY_PROXY_RID                  = ($00000008);
  {$EXTERNALSYM SECURITY_ENTERPRISE_CONTROLLERS_RID}
  SECURITY_ENTERPRISE_CONTROLLERS_RID = ($00000009);
  {$EXTERNALSYM SECURITY_SERVER_LOGON_RID}
  SECURITY_SERVER_LOGON_RID           = SECURITY_ENTERPRISE_CONTROLLERS_RID;
  {$EXTERNALSYM SECURITY_PRINCIPAL_SELF_RID}
  SECURITY_PRINCIPAL_SELF_RID         = ($0000000A);
  {$EXTERNALSYM SECURITY_AUTHENTICATED_USER_RID}
  SECURITY_AUTHENTICATED_USER_RID     = ($0000000B);
  {$EXTERNALSYM SECURITY_RESTRICTED_CODE_RID}
  SECURITY_RESTRICTED_CODE_RID        = ($0000000C);
  {$EXTERNALSYM SECURITY_TERMINAL_SERVER_RID}
  SECURITY_TERMINAL_SERVER_RID        = ($0000000D);

  {$EXTERNALSYM SECURITY_LOGON_IDS_RID}
  SECURITY_LOGON_IDS_RID       = ($00000005);
  {$EXTERNALSYM SECURITY_LOGON_IDS_RID_COUNT}
  SECURITY_LOGON_IDS_RID_COUNT = (3);
  {$EXTERNALSYM SECURITY_LOCAL_SYSTEM_RID}
  SECURITY_LOCAL_SYSTEM_RID    = ($00000012);
  {$EXTERNALSYM SECURITY_NT_NON_UNIQUE}
  SECURITY_NT_NON_UNIQUE       = ($00000015);
  {$EXTERNALSYM SECURITY_BUILTIN_DOMAIN_RID}
  SECURITY_BUILTIN_DOMAIN_RID  = ($00000020);

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// well-known domain relative sub-authority values (RIDs)...               //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

// Well-known users ...

  {$EXTERNALSYM DOMAIN_USER_RID_ADMIN}
  DOMAIN_USER_RID_ADMIN  = ($000001F4);
  {$EXTERNALSYM DOMAIN_USER_RID_GUEST}
  DOMAIN_USER_RID_GUEST  = ($000001F5);
  {$EXTERNALSYM DOMAIN_USER_RID_KRBTGT}
  DOMAIN_USER_RID_KRBTGT = ($000001F6);

// well-known groups ...

  {$EXTERNALSYM DOMAIN_GROUP_RID_ADMINS}
  DOMAIN_GROUP_RID_ADMINS            = ($00000200);
  {$EXTERNALSYM DOMAIN_GROUP_RID_USERS}
  DOMAIN_GROUP_RID_USERS             = ($00000201);
  {$EXTERNALSYM DOMAIN_GROUP_RID_GUESTS}
  DOMAIN_GROUP_RID_GUESTS            = ($00000202);
  {$EXTERNALSYM DOMAIN_GROUP_RID_COMPUTERS}
  DOMAIN_GROUP_RID_COMPUTERS         = ($00000203);
  {$EXTERNALSYM DOMAIN_GROUP_RID_CONTROLLERS}
  DOMAIN_GROUP_RID_CONTROLLERS       = ($00000204);
  {$EXTERNALSYM DOMAIN_GROUP_RID_CERT_ADMINS}
  DOMAIN_GROUP_RID_CERT_ADMINS       = ($00000205);
  {$EXTERNALSYM DOMAIN_GROUP_RID_SCHEMA_ADMINS}
  DOMAIN_GROUP_RID_SCHEMA_ADMINS     = ($00000206);
  {$EXTERNALSYM DOMAIN_GROUP_RID_ENTERPRISE_ADMINS}
  DOMAIN_GROUP_RID_ENTERPRISE_ADMINS = ($00000207);
  {$EXTERNALSYM DOMAIN_GROUP_RID_POLICY_ADMINS}
  DOMAIN_GROUP_RID_POLICY_ADMINS     = ($00000208);

// well-known aliases ...

  {$EXTERNALSYM DOMAIN_ALIAS_RID_ADMINS}
  DOMAIN_ALIAS_RID_ADMINS           = ($00000220);
  {$EXTERNALSYM DOMAIN_ALIAS_RID_USERS}
  DOMAIN_ALIAS_RID_USERS            = ($00000221);
  {$EXTERNALSYM DOMAIN_ALIAS_RID_GUESTS}
  DOMAIN_ALIAS_RID_GUESTS           = ($00000222);
  {$EXTERNALSYM DOMAIN_ALIAS_RID_POWER_USERS}
  DOMAIN_ALIAS_RID_POWER_USERS      = ($00000223);

  {$EXTERNALSYM DOMAIN_ALIAS_RID_ACCOUNT_OPS}
  DOMAIN_ALIAS_RID_ACCOUNT_OPS      = ($00000224);
  {$EXTERNALSYM DOMAIN_ALIAS_RID_SYSTEM_OPS}
  DOMAIN_ALIAS_RID_SYSTEM_OPS       = ($00000225);
  {$EXTERNALSYM DOMAIN_ALIAS_RID_PRINT_OPS}
  DOMAIN_ALIAS_RID_PRINT_OPS        = ($00000226);
  {$EXTERNALSYM DOMAIN_ALIAS_RID_BACKUP_OPS}
  DOMAIN_ALIAS_RID_BACKUP_OPS       = ($00000227);

  {$EXTERNALSYM DOMAIN_ALIAS_RID_REPLICATOR}
  DOMAIN_ALIAS_RID_REPLICATOR       = ($00000228);
  {$EXTERNALSYM DOMAIN_ALIAS_RID_RAS_SERVERS}
  DOMAIN_ALIAS_RID_RAS_SERVERS      = ($00000229);
  {$EXTERNALSYM DOMAIN_ALIAS_RID_PREW2KCOMPACCESS}
  DOMAIN_ALIAS_RID_PREW2KCOMPACCESS = ($0000022A);

  {$EXTERNALSYM SE_CREATE_TOKEN_NAME}
  SE_CREATE_TOKEN_NAME        = 'SeCreateTokenPrivilege';
  {$EXTERNALSYM SE_ASSIGNPRIMARYTOKEN_NAME}
  SE_ASSIGNPRIMARYTOKEN_NAME  = 'SeAssignPrimaryTokenPrivilege';
  {$EXTERNALSYM SE_LOCK_MEMORY_NAME}
  SE_LOCK_MEMORY_NAME         = 'SeLockMemoryPrivilege';
  {$EXTERNALSYM SE_INCREASE_QUOTA_NAME}
  SE_INCREASE_QUOTA_NAME      = 'SeIncreaseQuotaPrivilege';
  {$EXTERNALSYM SE_UNSOLICITED_INPUT_NAME}
  SE_UNSOLICITED_INPUT_NAME   = 'SeUnsolicitedInputPrivilege';
  {$EXTERNALSYM SE_MACHINE_ACCOUNT_NAME}
  SE_MACHINE_ACCOUNT_NAME     = 'SeMachineAccountPrivilege';
  {$EXTERNALSYM SE_TCB_NAME}
  SE_TCB_NAME                 = 'SeTcbPrivilege';
  {$EXTERNALSYM SE_SECURITY_NAME}
  SE_SECURITY_NAME            = 'SeSecurityPrivilege';
  {$EXTERNALSYM SE_TAKE_OWNERSHIP_NAME}
  SE_TAKE_OWNERSHIP_NAME      = 'SeTakeOwnershipPrivilege';
  {$EXTERNALSYM SE_LOAD_DRIVER_NAME}
  SE_LOAD_DRIVER_NAME         = 'SeLoadDriverPrivilege';
  {$EXTERNALSYM SE_SYSTEM_PROFILE_NAME}
  SE_SYSTEM_PROFILE_NAME      = 'SeSystemProfilePrivilege';
  {$EXTERNALSYM SE_SYSTEMTIME_NAME}
  SE_SYSTEMTIME_NAME          = 'SeSystemtimePrivilege';
  {$EXTERNALSYM SE_PROF_SINGLE_PROCESS_NAME}
  SE_PROF_SINGLE_PROCESS_NAME = 'SeProfileSingleProcessPrivilege';
  {$EXTERNALSYM SE_INC_BASE_PRIORITY_NAME}
  SE_INC_BASE_PRIORITY_NAME   = 'SeIncreaseBasePriorityPrivilege';
  {$EXTERNALSYM SE_CREATE_PAGEFILE_NAME}
  SE_CREATE_PAGEFILE_NAME     = 'SeCreatePagefilePrivilege';
  {$EXTERNALSYM SE_CREATE_PERMANENT_NAME}
  SE_CREATE_PERMANENT_NAME    = 'SeCreatePermanentPrivilege';
  {$EXTERNALSYM SE_BACKUP_NAME}
  SE_BACKUP_NAME              = 'SeBackupPrivilege';
  {$EXTERNALSYM SE_RESTORE_NAME}
  SE_RESTORE_NAME             = 'SeRestorePrivilege';
  {$EXTERNALSYM SE_SHUTDOWN_NAME}
  SE_SHUTDOWN_NAME            = 'SeShutdownPrivilege';
  {$EXTERNALSYM SE_DEBUG_NAME}
  SE_DEBUG_NAME               = 'SeDebugPrivilege';
  {$EXTERNALSYM SE_AUDIT_NAME}
  SE_AUDIT_NAME               = 'SeAuditPrivilege';
  {$EXTERNALSYM SE_SYSTEM_ENVIRONMENT_NAME}
  SE_SYSTEM_ENVIRONMENT_NAME  = 'SeSystemEnvironmentPrivilege';
  {$EXTERNALSYM SE_CHANGE_NOTIFY_NAME}
  SE_CHANGE_NOTIFY_NAME       = 'SeChangeNotifyPrivilege';
  {$EXTERNALSYM SE_REMOTE_SHUTDOWN_NAME}
  SE_REMOTE_SHUTDOWN_NAME     = 'SeRemoteShutdownPrivilege';
  {$EXTERNALSYM SE_UNDOCK_NAME}
  SE_UNDOCK_NAME              = 'SeUndockPrivilege';
  {$EXTERNALSYM SE_SYNC_AGENT_NAME}
  SE_SYNC_AGENT_NAME          = 'SeSyncAgentPrivilege';
  {$EXTERNALSYM SE_ENABLE_DELEGATION_NAME}
  SE_ENABLE_DELEGATION_NAME   = 'SeEnableDelegationPrivilege';
  {$EXTERNALSYM SE_MANAGE_VOLUME_NAME}
  SE_MANAGE_VOLUME_NAME       = 'SeManageVolumePrivilege';
  {$EXTERNALSYM SE_IMPERSONATE_NAME}
  SE_IMPERSONATE_NAME         = 'SeImpersonatePrivilege';
  {$EXTERNALSYM SE_CREATE_GLOBAL_NAME}
  SE_CREATE_GLOBAL_NAME       = 'SeCreateGlobalPrivilege';

type
  {$EXTERNALSYM _TOKEN_USER}
  _TOKEN_USER = packed record
    User: SID_AND_ATTRIBUTES;
  end;
  {$EXTERNALSYM TOKEN_USER}
  TOKEN_USER = _TOKEN_USER;
  {$EXTERNALSYM PTOKEN_USER}
  PTOKEN_USER = ^_TOKEN_USER;
  TTokenUser = _TOKEN_USER;
  PTokenUser = PTOKEN_USER;

//--------------------------------------------------------------------------------------------------
// NTFS related I/O control codes, types and constants (WinNT.h)
//--------------------------------------------------------------------------------------------------

const
  {$EXTERNALSYM COMPRESSION_FORMAT_NONE}
  COMPRESSION_FORMAT_NONE     = $0000;
  {$EXTERNALSYM COMPRESSION_FORMAT_DEFAULT}
  COMPRESSION_FORMAT_DEFAULT  = $0001;
  {$EXTERNALSYM COMPRESSION_FORMAT_LZNT1}
  COMPRESSION_FORMAT_LZNT1    = $0002;

  {$EXTERNALSYM FILE_SUPPORTS_SPARSE_FILES}
  FILE_SUPPORTS_SPARSE_FILES         = $00000040;
  {$EXTERNALSYM FILE_SUPPORTS_REPARSE_POINTS}
  FILE_SUPPORTS_REPARSE_POINTS       = $00000080;

  {$EXTERNALSYM IO_REPARSE_TAG_MOUNT_POINT}
  IO_REPARSE_TAG_MOUNT_POINT = DWORD($A0000003);
  {$EXTERNALSYM IO_REPARSE_TAG_HSM}
  IO_REPARSE_TAG_HSM         = DWORD($C0000004);
  {$EXTERNALSYM IO_REPARSE_TAG_SIS}
  IO_REPARSE_TAG_SIS         = DWORD($80000007);

  {$EXTERNALSYM FILE_ATTRIBUTE_DEVICE}
  FILE_ATTRIBUTE_DEVICE              = $00000040;
  {$EXTERNALSYM FILE_ATTRIBUTE_SPARSE_FILE}
  FILE_ATTRIBUTE_SPARSE_FILE         = $00000200;
  {$EXTERNALSYM FILE_ATTRIBUTE_REPARSE_POINT}
  FILE_ATTRIBUTE_REPARSE_POINT       = $00000400;
  {$EXTERNALSYM FILE_ATTRIBUTE_NOT_CONTENT_INDEXED}
  FILE_ATTRIBUTE_NOT_CONTENT_INDEXED = $00002000;
  {$EXTERNALSYM FILE_ATTRIBUTE_ENCRYPTED}
  FILE_ATTRIBUTE_ENCRYPTED           = $00004000;

  {$EXTERNALSYM FILE_WRITE_DATA}
  FILE_WRITE_DATA         = $0002;
  {$EXTERNALSYM FILE_READ_DATA}
  FILE_READ_DATA          = $0001;
  
//--------------------------------------------------------------------------------------------------
// NTFS Reparse Points (WinNT.h)
//--------------------------------------------------------------------------------------------------

const
  {$EXTERNALSYM REPARSE_GUID_DATA_BUFFER_HEADER_SIZE}
  REPARSE_GUID_DATA_BUFFER_HEADER_SIZE = 24;
  
  {$EXTERNALSYM MAXIMUM_REPARSE_DATA_BUFFER_SIZE}
  MAXIMUM_REPARSE_DATA_BUFFER_SIZE = 16 * 1024;

  {$EXTERNALSYM IO_REPARSE_TAG_RESERVED_ZERO}
  IO_REPARSE_TAG_RESERVED_ZERO  = (0);
  {$EXTERNALSYM IO_REPARSE_TAG_RESERVED_ONE}
  IO_REPARSE_TAG_RESERVED_ONE   = (1);
  {$EXTERNALSYM IO_REPARSE_TAG_RESERVED_RANGE}
  IO_REPARSE_TAG_RESERVED_RANGE = IO_REPARSE_TAG_RESERVED_ONE;
  
type
  {$EXTERNALSYM _REPARSE_GUID_DATA_BUFFER}
  _REPARSE_GUID_DATA_BUFFER = record
    ReparseTag: DWORD;
    ReparseDataLength: Word;
    Reserved: WORD;
    ReparseGuid: TGUID;
    DataBuffer: array [0..0] of Byte;
  end;
  {$EXTERNALSYM REPARSE_GUID_DATA_BUFFER}
  REPARSE_GUID_DATA_BUFFER = _REPARSE_GUID_DATA_BUFFER;
  {$EXTERNALSYM PREPARSE_GUID_DATA_BUFFER}
  PREPARSE_GUID_DATA_BUFFER = ^_REPARSE_GUID_DATA_BUFFER;
  TReparseGuidDataBuffer = _REPARSE_GUID_DATA_BUFFER;
  PReparseGuidDataBuffer = ^PREPARSE_GUID_DATA_BUFFER;

//--------------------------------------------------------------------------------------------------
// Image (WinNT.h)
//--------------------------------------------------------------------------------------------------

const
  {$EXTERNALSYM IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT}
  IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   = 13; // Delay load import descriptors
  {$EXTERNALSYM IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR}
  IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR = 14; // COM run-time descriptor -> .NET

  {$EXTERNALSYM IMAGE_DLLCHARACTERISTICS_NO_BIND}
  IMAGE_DLLCHARACTERISTICS_NO_BIND               = $0800;
  {$EXTERNALSYM IMAGE_DLLCHARACTERISTICS_WDM_DRIVER}
  IMAGE_DLLCHARACTERISTICS_WDM_DRIVER            = $2000;
  {$EXTERNALSYM IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE}
  IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE = $8000;

type
  // Non-COFF Object file header
  {$EXTERNALSYM ANON_OBJECT_HEADER}
  ANON_OBJECT_HEADER = packed record
    Sig1: WORD;            // Must be IMAGE_FILE_MACHINE_UNKNOWN
    Sig2: WORD;            // Must be 0xffff
    Version: WORD;         // >= 1 (implies the CLSID field is present)
    Machine: WORD;
    TimeDateStamp: DWORD;
    ClassID: TCLSID;       // Used to invoke CoCreateInstance
    SizeOfData: DWORD;     // Size of data that follows the header
  end;
  TANonObjectHeader = ANON_OBJECT_HEADER;

  // Import format
  {$EXTERNALSYM _IMAGE_IMPORT_BY_NAME}
  _IMAGE_IMPORT_BY_NAME = packed record
    Hint: WORD;
    Name: array[0..0] of AnsiChar;
  end;
  {$EXTERNALSYM IMAGE_IMPORT_BY_NAME}
  IMAGE_IMPORT_BY_NAME = _IMAGE_IMPORT_BY_NAME;
  {$EXTERNALSYM PIMAGE_IMPORT_BY_NAME}
  PIMAGE_IMPORT_BY_NAME = ^_IMAGE_IMPORT_BY_NAME;
  TImageImportByName = _IMAGE_IMPORT_BY_NAME;
  PImageImportByName = PIMAGE_IMPORT_BY_NAME;

  {$EXTERNALSYM _IMAGE_THUNK_DATA32}
  _IMAGE_THUNK_DATA32 = packed record
    case Integer of
      0: (ForwarderString: DWORD);      // PBYTE
      1: (Function_: DWORD);            // PDWORD
      2: (Ordinal: DWORD);
      3: (AddressOfData: DWORD);        // PIMAGE_IMPORT_BY_NAME
  end;
  {$EXTERNALSYM IMAGE_THUNK_DATA32}
  IMAGE_THUNK_DATA32 = _IMAGE_THUNK_DATA32;
  {$EXTERNALSYM PIMAGE_THUNK_DATA32}
  PIMAGE_THUNK_DATA32 = ^_IMAGE_THUNK_DATA32;
  TImageThunkData32 = _IMAGE_THUNK_DATA32;
  PImageThunkData32 = PIMAGE_THUNK_DATA32;

const
  {$EXTERNALSYM IMAGE_ORDINAL_FLAG64}
  IMAGE_ORDINAL_FLAG64 = $8000000000000000;
  {$EXTERNALSYM IMAGE_ORDINAL_FLAG32}
  IMAGE_ORDINAL_FLAG32 = $80000000;

{$EXTERNALSYM IMAGE_ORDINAL64}
function IMAGE_ORDINAL64(Ordinal: Word): Word; // Macro
{$EXTERNALSYM IMAGE_ORDINAL32}
function IMAGE_ORDINAL32(Ordinal: Word): Word; // Macro

{$EXTERNALSYM IMAGE_SNAP_BY_ORDINAL64}
function IMAGE_SNAP_BY_ORDINAL64(Ordinal: UInt64): Boolean; // Macro
{$EXTERNALSYM IMAGE_SNAP_BY_ORDINAL32}
function IMAGE_SNAP_BY_ORDINAL32(Ordinal: DWord): Boolean; // Macro

type
  // Thread Local Storage
  {$EXTERNALSYM _IMAGE_TLS_DIRECTORY32}
  _IMAGE_TLS_DIRECTORY32 = packed record
    StartAddressOfRawData: DWORD;
    EndAddressOfRawData: DWORD;
    AddressOfIndex: DWORD;             // PDWORD
    AddressOfCallBacks: DWORD;         // PIMAGE_TLS_CALLBACK *
    SizeOfZeroFill: DWORD;
    Characteristics: DWORD;
  end;
  {$EXTERNALSYM IMAGE_TLS_DIRECTORY32}
  IMAGE_TLS_DIRECTORY32 = _IMAGE_TLS_DIRECTORY32;
  {$EXTERNALSYM PIMAGE_TLS_DIRECTORY32}
  PIMAGE_TLS_DIRECTORY32 = ^_IMAGE_TLS_DIRECTORY32;
  TImageTlsDirectory32 = _IMAGE_TLS_DIRECTORY32;
  PImageTlsDirectory32 = PIMAGE_TLS_DIRECTORY32;

{$IFDEF _WIN64}
const
  {$EXTERNALSYM IMAGE_ORDINAL_FLAG}
  IMAGE_ORDINAL_FLAG = IMAGE_ORDINAL_FLAG64;

{$EXTERNALSYM IMAGE_ORDINAL}
function IMAGE_ORDINAL(Ordinal: Word): Word; // Macro

type
  {$EXTERNALSYM IMAGE_THUNK_DATA}
  IMAGE_THUNK_DATA = IMAGE_THUNK_DATA64;
  {$EXTERNALSYM PIMAGE_THUNK_DATA}
  PIMAGE_THUNK_DATA = PIMAGE_THUNK_DATA64;

{$EXTERNALSYM IMAGE_SNAP_BY_ORDINAL}
function IMAGE_SNAP_BY_ORDINAL(Ordinal: UInt64): Boolean; // Macro

type
  {$EXTERNALSYM IMAGE_TLS_DIRECTORY}
  IMAGE_TLS_DIRECTORY = IMAGE_TLS_DIRECTORY64;
  {$EXTERNALSYM PIMAGE_TLS_DIRECTORY}
  PIMAGE_TLS_DIRECTORY = PIMAGE_TLS_DIRECTORY64;
{$ELSE _WIN64}
const
  {$EXTERNALSYM IMAGE_ORDINAL_FLAG}
  IMAGE_ORDINAL_FLAG = IMAGE_ORDINAL_FLAG32;

{$EXTERNALSYM IMAGE_ORDINAL}
function IMAGE_ORDINAL(Ordinal: Word): Word; // Macro

type
  {$EXTERNALSYM IMAGE_THUNK_DATA}
  IMAGE_THUNK_DATA = IMAGE_THUNK_DATA32;
  {$EXTERNALSYM PIMAGE_THUNK_DATA}
  PIMAGE_THUNK_DATA = PIMAGE_THUNK_DATA32;

{$EXTERNALSYM IMAGE_SNAP_BY_ORDINAL}
function IMAGE_SNAP_BY_ORDINAL(Ordinal: DWord): Boolean; // Macro

type
  {$EXTERNALSYM IMAGE_TLS_DIRECTORY}
  IMAGE_TLS_DIRECTORY = IMAGE_TLS_DIRECTORY32;
  {$EXTERNALSYM PIMAGE_TLS_DIRECTORY}
  PIMAGE_TLS_DIRECTORY = PIMAGE_TLS_DIRECTORY32;
{$ENDIF _WIN64}

type
  TImageThunkData = IMAGE_THUNK_DATA;
  PImageThunkData = PIMAGE_THUNK_DATA;
  TImageTlsDirectory = IMAGE_TLS_DIRECTORY;
  PImageTlsDirectory = PIMAGE_TLS_DIRECTORY;
  
  {$EXTERNALSYM _IMAGE_IMPORT_DESCRIPTOR}
  _IMAGE_IMPORT_DESCRIPTOR = packed record
    case Integer of
      0: (
        Characteristics: DWORD;    // 0 for terminating null import descriptor

        TimeDateStamp: DWORD;      // 0 if not bound,
                                   // -1 if bound, and real date\time stamp
                                   //     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)
                                   // O.W. date/time stamp of DLL bound to (Old BIND)
        ForwarderChain: DWORD;     // -1 if no forwarders
        Name: DWORD;
        FirstThunk: DWORD          // RVA to IAT (if bound this IAT has actual addresses)
      );
      1: (
        OriginalFirstThunk: DWORD  // RVA to original unbound IAT (PIMAGE_THUNK_DATA)
      );
  end;
  {$EXTERNALSYM IMAGE_IMPORT_DESCRIPTOR}
  IMAGE_IMPORT_DESCRIPTOR = _IMAGE_IMPORT_DESCRIPTOR;
  {$EXTERNALSYM PIMAGE_IMPORT_DESCRIPTOR}
  PIMAGE_IMPORT_DESCRIPTOR = ^_IMAGE_IMPORT_DESCRIPTOR;
  TImageImportDescriptor = _IMAGE_IMPORT_DESCRIPTOR;
  PImageImportDescriptor = PIMAGE_IMPORT_DESCRIPTOR;
  
// New format import descriptors pointed to by
//   DataDirectory[ IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ]
type
  {$EXTERNALSYM _IMAGE_BOUND_IMPORT_DESCRIPTOR}
  _IMAGE_BOUND_IMPORT_DESCRIPTOR = packed record
    TimeDateStamp: DWORD;
    OffsetModuleName: WORD;
    NumberOfModuleForwarderRefs: WORD;
    // Array of zero or more IMAGE_BOUND_FORWARDER_REF follows
  end;
  {$EXTERNALSYM IMAGE_BOUND_IMPORT_DESCRIPTOR}
  IMAGE_BOUND_IMPORT_DESCRIPTOR = _IMAGE_BOUND_IMPORT_DESCRIPTOR;
  {$EXTERNALSYM PIMAGE_BOUND_IMPORT_DESCRIPTOR}
  PIMAGE_BOUND_IMPORT_DESCRIPTOR = ^_IMAGE_BOUND_IMPORT_DESCRIPTOR;
  TImageBoundImportDescriptor = _IMAGE_BOUND_IMPORT_DESCRIPTOR;
  PImageBoundImportDescriptor = PIMAGE_BOUND_IMPORT_DESCRIPTOR;

  {$EXTERNALSYM _IMAGE_BOUND_FORWARDER_REF}
  _IMAGE_BOUND_FORWARDER_REF = packed record
    TimeDateStamp: DWORD;
    OffsetModuleName: WORD;
    Reserved: WORD;
  end;
  {$EXTERNALSYM IMAGE_BOUND_FORWARDER_REF}
  IMAGE_BOUND_FORWARDER_REF = _IMAGE_BOUND_FORWARDER_REF;
  {$EXTERNALSYM PIMAGE_BOUND_FORWARDER_REF}
  PIMAGE_BOUND_FORWARDER_REF = ^_IMAGE_BOUND_FORWARDER_REF;
  TImageBoundForwarderRef = _IMAGE_BOUND_FORWARDER_REF;
  PImageBoundForwarderRef = PIMAGE_BOUND_FORWARDER_REF;

// Resource Format.

// Resource directory consists of two counts, following by a variable length
// array of directory entries.  The first count is the number of entries at
// beginning of the array that have actual names associated with each entry.
// The entries are in ascending order, case insensitive strings.  The second
// count is the number of entries that immediately follow the named entries.
// This second count identifies the number of entries that have 16-bit integer
// Ids as their name.  These entries are also sorted in ascending order.
//
// This structure allows fast lookup by either name or number, but for any
// given resource entry only one form of lookup is supported, not both.
// This is consistant with the syntax of the .RC file and the .RES file.

type
  {$EXTERNALSYM _IMAGE_RESOURCE_DIRECTORY}
  _IMAGE_RESOURCE_DIRECTORY = packed record
    Characteristics: DWORD;
    TimeDateStamp: DWORD;
    MajorVersion: WORD;
    MinorVersion: WORD;
    NumberOfNamedEntries: WORD;
    NumberOfIdEntries: WORD;
  end;
  //  IMAGE_RESOURCE_DIRECTORY_ENTRY DirectoryEntries[];
  {$EXTERNALSYM IMAGE_RESOURCE_DIRECTORY}
  IMAGE_RESOURCE_DIRECTORY = _IMAGE_RESOURCE_DIRECTORY;
  {$EXTERNALSYM PIMAGE_RESOURCE_DIRECTORY}
  PIMAGE_RESOURCE_DIRECTORY = ^_IMAGE_RESOURCE_DIRECTORY;
  TImageResourceDirectory = _IMAGE_RESOURCE_DIRECTORY;
  PImageResourceDirectory = PIMAGE_RESOURCE_DIRECTORY;

const
  {$EXTERNALSYM IMAGE_RESOURCE_NAME_IS_STRING}
  IMAGE_RESOURCE_NAME_IS_STRING    = $80000000;
  {$EXTERNALSYM IMAGE_RESOURCE_DATA_IS_DIRECTORY}
  IMAGE_RESOURCE_DATA_IS_DIRECTORY = $80000000;

// Each directory contains the 32-bit Name of the entry and an offset,
// relative to the beginning of the resource directory of the data associated
// with this directory entry.  If the name of the entry is an actual text
// string instead of an integer Id, then the high order bit of the name field
// is set to one and the low order 31-bits are an offset, relative to the
// beginning of the resource directory of the string, which is of type
// IMAGE_RESOURCE_DIRECTORY_STRING.  Otherwise the high bit is clear and the
// low-order 16-bits are the integer Id that identify this resource directory
// entry. If the directory entry is yet another resource directory (i.e. a
// subdirectory), then the high order bit of the offset field will be
// set to indicate this.  Otherwise the high bit is clear and the offset
// field points to a resource data entry.

type
  {$EXTERNALSYM _IMAGE_RESOURCE_DIRECTORY_ENTRY}
  _IMAGE_RESOURCE_DIRECTORY_ENTRY = packed record
    case Integer of
      0: (
        // DWORD NameOffset:31;
        // DWORD NameIsString:1;
        NameOffset: DWORD;
        OffsetToData: DWORD
      );
      1: (
        Name: DWORD;
        // DWORD OffsetToDirectory:31;
        // DWORD DataIsDirectory:1;
        OffsetToDirectory: DWORD;
      );
      2: (
        Id: WORD;
      );
  end;
  {$EXTERNALSYM IMAGE_RESOURCE_DIRECTORY_ENTRY}
  IMAGE_RESOURCE_DIRECTORY_ENTRY = _IMAGE_RESOURCE_DIRECTORY_ENTRY;
  {$EXTERNALSYM PIMAGE_RESOURCE_DIRECTORY_ENTRY}
  PIMAGE_RESOURCE_DIRECTORY_ENTRY = ^_IMAGE_RESOURCE_DIRECTORY_ENTRY;
  TImageResourceDirectoryEntry = _IMAGE_RESOURCE_DIRECTORY_ENTRY;
  PImageResourceDirectoryEntry = PIMAGE_RESOURCE_DIRECTORY_ENTRY;
  
// For resource directory entries that have actual string names, the Name
// field of the directory entry points to an object of the following type.
// All of these string objects are stored together after the last resource
// directory entry and before the first resource data object.  This minimizes
// the impact of these variable length objects on the alignment of the fixed
// size directory entry objects.

type
  {$EXTERNALSYM _IMAGE_RESOURCE_DIRECTORY_STRING}
  _IMAGE_RESOURCE_DIRECTORY_STRING = packed record
    Length: WORD;
    NameString: array[0..0] of AnsiChar;
  end;
  {$EXTERNALSYM IMAGE_RESOURCE_DIRECTORY_STRING}
  IMAGE_RESOURCE_DIRECTORY_STRING = _IMAGE_RESOURCE_DIRECTORY_STRING;
  {$EXTERNALSYM PIMAGE_RESOURCE_DIRECTORY_STRING}
  PIMAGE_RESOURCE_DIRECTORY_STRING = ^_IMAGE_RESOURCE_DIRECTORY_STRING;
  TImageResourceDirectoryString = _IMAGE_RESOURCE_DIRECTORY_STRING;
  PImageResourceDirectoryString = PIMAGE_RESOURCE_DIRECTORY_STRING;

  {$EXTERNALSYM _IMAGE_RESOURCE_DIR_STRING_U}
  _IMAGE_RESOURCE_DIR_STRING_U = packed record
    Length: WORD;
    NameString: array[0..0] of WideChar;
  end;
  {$EXTERNALSYM IMAGE_RESOURCE_DIR_STRING_U}
  IMAGE_RESOURCE_DIR_STRING_U = _IMAGE_RESOURCE_DIR_STRING_U;
  {$EXTERNALSYM PIMAGE_RESOURCE_DIR_STRING_U}
  PIMAGE_RESOURCE_DIR_STRING_U = ^_IMAGE_RESOURCE_DIR_STRING_U;
  TImageResourceDirStringU = _IMAGE_RESOURCE_DIR_STRING_U;
  PImageResourceDirStringU = PIMAGE_RESOURCE_DIR_STRING_U;

// Each resource data entry describes a leaf node in the resource directory
// tree.  It contains an offset, relative to the beginning of the resource
// directory of the data for the resource, a size field that gives the number
// of bytes of data at that offset, a CodePage that should be used when
// decoding code point values within the resource data.  Typically for new
// applications the code page would be the unicode code page.

type
  {$EXTERNALSYM _IMAGE_RESOURCE_DATA_ENTRY}
  _IMAGE_RESOURCE_DATA_ENTRY = packed record
    OffsetToData: DWORD;
    Size: DWORD;
    CodePage: DWORD;
    Reserved: DWORD;
  end;
  {$EXTERNALSYM IMAGE_RESOURCE_DATA_ENTRY}
  IMAGE_RESOURCE_DATA_ENTRY = _IMAGE_RESOURCE_DATA_ENTRY;
  {$EXTERNALSYM PIMAGE_RESOURCE_DATA_ENTRY}
  PIMAGE_RESOURCE_DATA_ENTRY = ^_IMAGE_RESOURCE_DATA_ENTRY;
  TImageResourceDataEntry = _IMAGE_RESOURCE_DATA_ENTRY;
  PImageResourceDataEntry = PIMAGE_RESOURCE_DATA_ENTRY;

  // Load Configuration Directory Entry
  {$EXTERNALSYM IMAGE_LOAD_CONFIG_DIRECTORY32}
  IMAGE_LOAD_CONFIG_DIRECTORY32 = packed record
    Size: DWORD;                                  // nach alt Characteristics
    TimeDateStamp: DWORD;
    MajorVersion: WORD;
    MinorVersion: WORD;
    GlobalFlagsClear: DWORD;
    GlobalFlagsSet: DWORD;
    CriticalSectionDefaultTimeout: DWORD;
    DeCommitFreeBlockThreshold: DWORD;
    DeCommitTotalFreeThreshold: DWORD;
    LockPrefixTable: DWORD;            // VA
    MaximumAllocationSize: DWORD;
    VirtualMemoryThreshold: DWORD;
    ProcessHeapFlags: DWORD;
    ProcessAffinityMask: DWORD;
    CSDVersion: WORD;
    Reserved1: WORD;
    EditList: DWORD;                   // VA
    SecurityCookie: DWORD;             // VA
    SEHandlerTable: DWORD;             // VA
    SEHandlerCount: DWORD;
  end;
  {$EXTERNALSYM IMAGE_LOAD_CONFIG_DIRECTORY32}
  PIMAGE_LOAD_CONFIG_DIRECTORY32 = ^IMAGE_LOAD_CONFIG_DIRECTORY32;
  TImageLoadConfigDirectory32 = IMAGE_LOAD_CONFIG_DIRECTORY32;
  PImageLoadConfigDirectory32 = PIMAGE_LOAD_CONFIG_DIRECTORY32;

  {$IFDEF _WIN64}
  {$EXTERNALSYM IMAGE_LOAD_CONFIG_DIRECTORY}
  IMAGE_LOAD_CONFIG_DIRECTORY = IMAGE_LOAD_CONFIG_DIRECTORY64;
  {$EXTERNALSYM PIMAGE_LOAD_CONFIG_DIRECTORY}
  PIMAGE_LOAD_CONFIG_DIRECTORY = PIMAGE_LOAD_CONFIG_DIRECTORY64;
  {$ELSE _WIN64}
  {$EXTERNALSYM IMAGE_LOAD_CONFIG_DIRECTORY}
  IMAGE_LOAD_CONFIG_DIRECTORY = IMAGE_LOAD_CONFIG_DIRECTORY32;
  {$EXTERNALSYM PIMAGE_LOAD_CONFIG_DIRECTORY}
  PIMAGE_LOAD_CONFIG_DIRECTORY = PIMAGE_LOAD_CONFIG_DIRECTORY32;
  {$ENDIF _WIN64}

  TImageLoadConfigDirectory = IMAGE_LOAD_CONFIG_DIRECTORY;
  PImageLoadConfigDirectory = PIMAGE_LOAD_CONFIG_DIRECTORY;

  // Based relocation format.
  {$EXTERNALSYM _IMAGE_BASE_RELOCATION}
  _IMAGE_BASE_RELOCATION = packed record
    VirtualAddress: DWORD;
    SizeOfBlock: DWORD;
    // TypeOffset: array[0..0] of WORD;
  end;
  {$EXTERNALSYM _IMAGE_BASE_RELOCATION}
  IMAGE_BASE_RELOCATION = _IMAGE_BASE_RELOCATION;
  {$EXTERNALSYM PIMAGE_BASE_RELOCATION}
  PIMAGE_BASE_RELOCATION = ^_IMAGE_BASE_RELOCATION;
  TImageBaseRelocation = _IMAGE_BASE_RELOCATION;
  PImageBaseRelocation = PIMAGE_BASE_RELOCATION;

const
  {$EXTERNALSYM IMAGE_SIZEOF_BASE_RELOCATION}
  IMAGE_SIZEOF_BASE_RELOCATION = 8;

  // Based relocation types.
  {$EXTERNALSYM IMAGE_REL_BASED_ABSOLUTE}
  IMAGE_REL_BASED_ABSOLUTE       = 0;
  {$EXTERNALSYM IMAGE_REL_BASED_HIGH}
  IMAGE_REL_BASED_HIGH           = 1;
  {$EXTERNALSYM IMAGE_REL_BASED_LOW}
  IMAGE_REL_BASED_LOW            = 2;
  {$EXTERNALSYM IMAGE_REL_BASED_HIGHLOW}
  IMAGE_REL_BASED_HIGHLOW        = 3;
  {$EXTERNALSYM IMAGE_REL_BASED_HIGHADJ}
  IMAGE_REL_BASED_HIGHADJ        = 4;
  {$EXTERNALSYM IMAGE_REL_BASED_MIPS_JMPADDR}
  IMAGE_REL_BASED_MIPS_JMPADDR   = 5;
  {$EXTERNALSYM IMAGE_REL_BASED_MIPS_JMPADDR16}
  IMAGE_REL_BASED_MIPS_JMPADDR16 = 9;
  {$EXTERNALSYM IMAGE_REL_BASED_IA64_IMM64}
  IMAGE_REL_BASED_IA64_IMM64     = 9;
  {$EXTERNALSYM IMAGE_REL_BASED_DIR64}
  IMAGE_REL_BASED_DIR64          = 10;

  // obsolete, not part of the current Platform SDK (2003-02)
  {$EXTERNALSYM IMAGE_REL_BASED_SECTION}
  IMAGE_REL_BASED_SECTION        = 6;
  {$EXTERNALSYM IMAGE_REL_BASED_REL32}
  IMAGE_REL_BASED_REL32          = 7;
  {$EXTERNALSYM IMAGE_REL_BASED_HIGH3ADJ}
  IMAGE_REL_BASED_HIGH3ADJ       = 11;

  // Debug Format
  {$EXTERNALSYM IMAGE_DEBUG_TYPE_BORLAND}
  IMAGE_DEBUG_TYPE_BORLAND = 9;

//--------------------------------------------------------------------------------------------------
// Image COM+ 2.0 (WinNT.h)
//--------------------------------------------------------------------------------------------------

const
  // COM+ Header entry point flags.
  {$EXTERNALSYM COMIMAGE_FLAGS_ILONLY}
  COMIMAGE_FLAGS_ILONLY           = $00000001;
  {$EXTERNALSYM COMIMAGE_FLAGS_32BITREQUIRED}
  COMIMAGE_FLAGS_32BITREQUIRED    = $00000002;
  {$EXTERNALSYM COMIMAGE_FLAGS_IL_LIBRARY}
  COMIMAGE_FLAGS_IL_LIBRARY       = $00000004;
  {$EXTERNALSYM COMIMAGE_FLAGS_STRONGNAMESIGNED}
  COMIMAGE_FLAGS_STRONGNAMESIGNED = $00000008;
  {$EXTERNALSYM COMIMAGE_FLAGS_TRACKDEBUGDATA}
  COMIMAGE_FLAGS_TRACKDEBUGDATA   = $00010000;

{$IFNDEF FPC}
type
  // COM+ 2.0 header structure.
  { TODO : Why Compiler6? }
  // {$IFDEF COMPILER6_UP} {$EXTERNALSYM IMAGE_COR20_HEADER} {$ENDIF}
  {$EXTERNALSYM IMAGE_COR20_HEADER}
  IMAGE_COR20_HEADER = packed record
    // Header versioning
    cb: DWORD;
    MajorRuntimeVersion: WORD;
    MinorRuntimeVersion: WORD;
    
    // Symbol table and startup information
    MetaData: IMAGE_DATA_DIRECTORY;        
    Flags: DWORD;           
    EntryPointToken: DWORD;
    
    // Binding information
    Resources: IMAGE_DATA_DIRECTORY;
    StrongNameSignature: IMAGE_DATA_DIRECTORY;

    // Regular fixup and binding information
    CodeManagerTable: IMAGE_DATA_DIRECTORY;
    VTableFixups: IMAGE_DATA_DIRECTORY;
    ExportAddressTableJumps: IMAGE_DATA_DIRECTORY;

    // Precompiled image info (internal use only - set to zero)
    ManagedNativeHeader: IMAGE_DATA_DIRECTORY;
  end;
  {$EXTERNALSYM PIMAGE_COR20_HEADER}
  PIMAGE_COR20_HEADER = ^IMAGE_COR20_HEADER;
  TImageCor20Header = IMAGE_COR20_HEADER;
  PImageCor20Header = PIMAGE_COR20_HEADER;
{$ENDIF FPC}

//==================================================================================================
// from DelayImp.h
//==================================================================================================

type
  { TODO : Source unknown }
  {$EXTERNALSYM ImgDelayDescr}
  ImgDelayDescr = packed record
    grAttrs: DWORD;                 // attributes
    szName: DWORD;                  // pointer to dll name
    phmod: PDWORD;                  // address of module handle
    { TODO : probably wrong declaration }
    pIAT: TImageThunkData;          // address of the IAT
    { TODO : probably wrong declaration }
    pINT: TImageThunkData;          // address of the INT
    { TODO : probably wrong declaration }
    pBoundIAT: TImageThunkData;     // address of the optional bound IAT
    { TODO : probably wrong declaration }
    pUnloadIAT: TImageThunkData;    // address of optional copy of original IAT
    dwTimeStamp: DWORD;             // 0 if not bound,
                                    // O.W. date/time stamp of DLL bound to (Old BIND)
  end;
  TImgDelayDescr = ImgDelayDescr;
  PImgDelayDescr = ^ImgDelayDescr;

(*
  // DelayImp.h, Borland BCC 5.5
  {$EXTERNALSYM ImgDelayDescr}
  ImgDelayDescr = packed record
    grAttrs: DWORD;                 // attributes
    szName: LPCSTR;                 // pointer to dll name
    { TODO : probably wrong declaration }
    hmod: HMODULE;                  // address of module handle
    pIAT: PIMAGE_THUNK_DATA;        // address of the IAT
    pINT: PIMAGE_THUNK_DATA;        // address of the INT
    pBoundIAT: PIMAGE_THUNK_DATA;   // address of the optional bound IAT
    pUnloadIAT: PIMAGE_THUNK_DATA;  // address of optional copy of original IAT
    dwTimeStamp: DWORD;             // 0 if not bound,
                                    // O.W. date/time stamp of DLL bound to (Old BIND)
  end;
  TImgDelayDescr = ImgDelayDescr;
  PImgDelayDescr = ^ImgDelayDescr;

  
  // Microsoft version (64 bit SDK)
  {$EXTERNALSYM RVA}
  RVA = DWORD;
  
  {$EXTERNALSYM ImgDelayDescr}
  ImgDelayDescr = packed record
    grAttrs: DWORD;      // attributes
    rvaDLLName: RVA;     // RVA to dll name
    rvaHmod: RVA;        // RVA of module handle
    rvaIAT: RVA;         // RVA of the IAT
    rvaINT: RVA;         // RVA of the INT
    rvaBoundIAT: RVA;    // RVA of the optional bound IAT
    rvaUnloadIAT: RVA;   // RVA of optional copy of original IAT
    dwTimeStamp: DWORD;  // 0 if not bound,
                         // O.W. date/time stamp of DLL bound to (Old BIND)
  end;
  {$EXTERNALSYM PImgDelayDescr}
  PImgDelayDescr = ImgDelayDescr;
  TImgDelayDescr = ImgDelayDescr;
*)

//==================================================================================================
// from RasDlg.h
//==================================================================================================

type
  {$EXTERNALSYM tagRASDIALDLG}
  tagRASDIALDLG = packed record
    dwSize: DWORD;         // IN
    hwndOwner: HWND;       // IN
    dwFlags: DWORD;        // IN
    xDlg: LongInt;         // IN
    yDlg: LongInt;         // IN
    dwSubEntry: DWORD;     // IN
    dwError: DWORD;        // OUT
    reserved: ULONG_PTR;   // IN
    reserved2: ULONG_PTR;  // IN
  end;
  {$EXTERNALSYM RASDIALDLG}
  RASDIALDLG = tagRASDIALDLG;
  {$EXTERNALSYM LPRASDIALDLG}
  LPRASDIALDLG = ^tagRASDIALDLG;
  TRasDialDlg = tagRASDIALDLG;
  PRasDialDlg = LPRASDIALDLG;

//--------------------------------------------------------------------------------------------------
// Run time dynamic linking
//--------------------------------------------------------------------------------------------------

function RtdlRasDialDlgA(lpszPhonebook, lpszEntry, lpszPhoneNumber: LPSTR;
  lpInfo: LPRASDIALDLG): BOOL;

//==================================================================================================
// from ShlObj.h
//==================================================================================================

const
  {$EXTERNALSYM CSIDL_MYDOCUMENTS}
  CSIDL_MYDOCUMENTS             = $000c;  // logical "My Documents" desktop icon
  {$EXTERNALSYM CSIDL_MYMUSIC}
  CSIDL_MYMUSIC                 = $000d;  // "My Music" folder
  {$EXTERNALSYM CSIDL_MYVIDEO}
  CSIDL_MYVIDEO                 = $000e;  // "My Videos" folder

  {$EXTERNALSYM CSIDL_LOCAL_APPDATA}
  CSIDL_LOCAL_APPDATA           = $001c;  // <user name>\Local Settings\Applicaiton Data (non roaming)

  {$EXTERNALSYM CSIDL_COMMON_APPDATA}
  CSIDL_COMMON_APPDATA          = $0023;  // All Users\Application Data
  {$EXTERNALSYM CSIDL_WINDOWS}
  CSIDL_WINDOWS                 = $0024;  // GetWindowsDirectory()
  {$EXTERNALSYM CSIDL_SYSTEM}
  CSIDL_SYSTEM                  = $0025;  // GetSystemDirectory()
  {$EXTERNALSYM CSIDL_PROGRAM_FILES}
  CSIDL_PROGRAM_FILES           = $0026;  // C:\Program Files
  {$EXTERNALSYM CSIDL_MYPICTURES}
  CSIDL_MYPICTURES              = $0027;  // C:\Program Files\My Pictures, new for Win2K
  {$EXTERNALSYM CSIDL_PROFILE}
  CSIDL_PROFILE                 = $0028;  // USERPROFILE
  {$EXTERNALSYM CSIDL_SYSTEMX86}
  CSIDL_SYSTEMX86               = $0029;  // x86 system directory on RISC
  {$EXTERNALSYM CSIDL_PROGRAM_FILESX86}
  CSIDL_PROGRAM_FILESX86        = $002a;  // x86 C:\Program Files on RISC
  {$EXTERNALSYM CSIDL_PROGRAM_FILES_COMMON}
  CSIDL_PROGRAM_FILES_COMMON    = $002b;  // C:\Program Files\Common
  {$EXTERNALSYM CSIDL_PROGRAM_FILES_COMMONX86}
  CSIDL_PROGRAM_FILES_COMMONX86 = $002c;  // x86 Program Files\Common on RISC
  {$EXTERNALSYM CSIDL_COMMON_TEMPLATES}
  CSIDL_COMMON_TEMPLATES        = $002d;  // All Users\Templates
  {$EXTERNALSYM CSIDL_COMMON_DOCUMENTS}
  CSIDL_COMMON_DOCUMENTS        = $002e;  // All Users\Documents
  {$EXTERNALSYM CSIDL_COMMON_ADMINTOOLS}
  CSIDL_COMMON_ADMINTOOLS       = $002f;  // All Users\Start Menu\Programs\Administrative Tools
  {$EXTERNALSYM CSIDL_ADMINTOOLS}
  CSIDL_ADMINTOOLS              = $0030;  // <user name>\Start Menu\Programs\Administrative Tools
  {$EXTERNALSYM CSIDL_CONNECTIONS}
  CSIDL_CONNECTIONS             = $0031;  // Network and Dial-up Connections

  {$EXTERNALSYM CSIDL_COMMON_MUSIC}
  CSIDL_COMMON_MUSIC            = $0035;  // All Users\My Music
  {$EXTERNALSYM CSIDL_COMMON_PICTURES}
  CSIDL_COMMON_PICTURES         = $0036;  // All Users\My Pictures
  {$EXTERNALSYM CSIDL_COMMON_VIDEO}
  CSIDL_COMMON_VIDEO            = $0037;  // All Users\My Video
  {$EXTERNALSYM CSIDL_RESOURCES}
  CSIDL_RESOURCES               = $0038;  // %windir%\Resources\, For theme and other windows resources.
  {$EXTERNALSYM CSIDL_RESOURCES_LOCALIZED}
  CSIDL_RESOURCES_LOCALIZED     = $0039;  // %windir%\Resources\<LangID>, for theme and other windows specific resources.
  {$EXTERNALSYM CSIDL_COMMON_OEM_LINKS}
  CSIDL_COMMON_OEM_LINKS        = $003a;  // Links to All Users OEM specific apps
  {$EXTERNALSYM CSIDL_CDBURN_AREA}
  CSIDL_CDBURN_AREA             = $003b;  // USERPROFILE\Local Settings\Application Data\Microsoft\CD Burning
  // unused                     = $003c;
  {$EXTERNALSYM CSIDL_COMPUTERSNEARME}
  CSIDL_COMPUTERSNEARME         = $003d;  // Computers Near Me (computered from Workgroup membership)

  {$EXTERNALSYM CSIDL_FLAG_CREATE}
  CSIDL_FLAG_CREATE          = $8000;  // new for Win2K, or this in to force creation of folder

//==================================================================================================
// from ShlWApi.h
//==================================================================================================

//====== DllGetVersion  =======================================================

type
  {$EXTERNALSYM _DLLVERSIONINFO}
  _DLLVERSIONINFO = packed record
    cbSize: DWORD;
    dwMajorVersion: DWORD;                   // Major version
    dwMinorVersion: DWORD;                   // Minor version
    dwBuildNumber: DWORD;                    // Build number
    dwPlatformID: DWORD;                     // DLLVER_PLATFORM_*
  end;
  {$EXTERNALSYM DLLVERSIONINFO}
  DLLVERSIONINFO = _DLLVERSIONINFO;
  TDllVersionInfo = _DLLVERSIONINFO;

const
  // Platform IDs for DLLVERSIONINFO
  {$EXTERNALSYM DLLVER_PLATFORM_WINDOWS}
  DLLVER_PLATFORM_WINDOWS = $00000001;       // Windows 95
  {$EXTERNALSYM DLLVER_PLATFORM_NT}
  DLLVER_PLATFORM_NT      = $00000002;       // Windows NT

//==================================================================================================
// from WinBase.h
//==================================================================================================

{$IFNDEF FPC}
type
  {$EXTERNALSYM LPSECURITY_ATTRIBUTES}
  LPSECURITY_ATTRIBUTES = PSecurityAttributes;
{$ENDIF ~FPC}

{$EXTERNALSYM InterlockedExchangePointer}
function InterlockedExchangePointer(var Target: Pointer; Value: Pointer): Pointer;  // Macro

//--------------------------------------------------------------------------------------------------
// NTFS Reparse Points (WinBase.h)
//--------------------------------------------------------------------------------------------------

const
  {$EXTERNALSYM FILE_FLAG_OPEN_REPARSE_POINT}
  FILE_FLAG_OPEN_REPARSE_POINT = $00200000;

//--------------------------------------------------------------------------------------------------
// alternative conversions
//--------------------------------------------------------------------------------------------------

// At least in Win98 SE AdjustTokenPrivileges exist and return False and
// GetLastError = ERROR_CALL_NOT_IMPLEMENTED
// AdjustTokenPrivileges exists in Win95C as well

// alternative conversion, ReturnLength can be NULL
{$EXTERNALSYM AdjustTokenPrivileges}
function AdjustTokenPrivileges(TokenHandle: THandle; DisableAllPrivileges: BOOL;
  const NewState: TTokenPrivileges; BufferLength: DWORD;
  PreviousState: PTokenPrivileges; ReturnLength: PDWORD): BOOL; stdcall;

// alternative conversion for WinNT 4.0 SP6 and later (OSVersionInfoEx instead of OSVersionInfo)
{$EXTERNALSYM GetVersionEx}
function GetVersionEx(var lpVersionInformation: TOSVersionInfoEx): BOOL; stdcall;

{ TODO -cTest : test the CreateMutex - BOOL problem }
// Supposition: modified conversion to avoid a WinAPI bug
// bInitialOwner need to have the values 0 or 1

// alternative conversion, bInitialOwner DWORD instead of BOOL
{$EXTERNALSYM CreateMutex}
function CreateMutex(lpMutexAttributes: PSecurityAttributes; bInitialOwner: DWORD;
  lpName: PChar): THandle; stdcall; 

// wrong Declaration in Windows.pas
{$EXTERNALSYM BackupSeek}
function BackupSeek(hFile: THandle; dwLowBytesToSeek, dwHighBytesToSeek: DWORD;
  out lpdwLowByteSeeked, lpdwHighByteSeeked: DWORD; var lpContext: Pointer): BOOL; stdcall; 

//--------------------------------------------------------------------------------------------------
// Run time dynamic linking
//--------------------------------------------------------------------------------------------------

function RtdlGetVolumeNameForVolumeMountPoint(lpszVolumeMountPoint: LPCSTR; lpszVolumeName: LPSTR; cchBufferLength: DWORD): BOOL;
function RtdlSetVolumeMountPoint(lpszVolumeMountPoint: LPCSTR; lpszVolumeName: LPCSTR): BOOL;
function RtdlDeleteVolumeMountPoint(lpszVolumeMountPoint: LPCSTR): BOOL;

function RtdlGetFileAttributesEx(lpFileName: PChar; fInfoLevelId: TGetFileExInfoLevels;
  lpFileInformation: Pointer): BOOL;
function RtdlMoveFileEx(lpExistingFileName, lpNewFileName: PChar; dwFlags: DWORD): BOOL;

function RtdlCreateHardLink(lpFileName, lpExistingFileName: LPCSTR;
  lpSecurityAttributes: LPSECURITY_ATTRIBUTES): BOOL;

// WinNT 4 and later, not Win9x
function RtdlSignalObjectAndWait(hObjectToSignal: THandle; hObjectToWaitOn: THandle;
  dwMilliseconds: DWORD; bAlertable: BOOL): DWORD; stdcall;
// Win98 and later or WinNT 4.0 SP3 and later
function RtdlInitializeCriticalSectionAndSpinCount(
  var lpCriticalSection: TRTLCriticalSection; dwSpinCount: DWORD): BOOL; stdcall;
// WinNT 4.0 SP3 and later, not Win9x
// Use GetLastError to detect, whether SetCriticalSectionSpinCount exist
function RtdlSetCriticalSectionSpinCount(
  var lpCriticalSection: TRTLCriticalSection; dwSpinCount: DWORD): DWORD; stdcall;
// WinNT 4.0 and later, not Win9x
// Use GetLastError to detect, whether SetCriticalSectionSpinCount exist
function RtdlTryEnterCriticalSection(
  var lpCriticalSection: TRTLCriticalSection): BOOL; stdcall;
// Win98 and later or WinNT 4.0 and later
function RtdlCancelWaitableTimer(hTimer: THandle): BOOL; stdcall;
// Win98 and later or WinNT 4.0 and later
function RtdlCreateWaitableTimer(lpTimerAttributes: PSecurityAttributes;
  bManualReset: BOOL; lpTimerName: PChar): THandle; stdcall;
// Win98 and later or WinNT 4.0 and later
function RtdlOpenWaitableTimer(dwDesiredAccess: DWORD; bInheritHandle: BOOL;
  lpTimerName: PChar): THandle; stdcall;
// Win98 and later or WinNT 4.0 and later
function RtdlSetWaitableTimer(hTimer: THandle; var lpDueTime: TLargeInteger;
  lPeriod: Longint; pfnCompletionRoutine: TFNTimerAPCRoutine;
  lpArgToCompletionRoutine: Pointer; fResume: BOOL): BOOL; stdcall;

//==================================================================================================
// from WinIoCtl.h
//==================================================================================================

type
  // Structure for FSCTL_QUERY_ALLOCATED_RANGES

  // Querying the allocated ranges requires an output buffer to store the
  // allocated ranges and an input buffer to specify the range to query.
  // The input buffer contains a single entry, the output buffer is an
  // array of the following structure.

  {$EXTERNALSYM _FILE_ALLOCATED_RANGE_BUFFER}
  _FILE_ALLOCATED_RANGE_BUFFER = packed record
    FileOffset: LARGE_INTEGER;
    Length: LARGE_INTEGER;
  end;
  {$EXTERNALSYM FILE_ALLOCATED_RANGE_BUFFER}
  FILE_ALLOCATED_RANGE_BUFFER = _FILE_ALLOCATED_RANGE_BUFFER;
  {$EXTERNALSYM PFILE_ALLOCATED_RANGE_BUFFER}
  PFILE_ALLOCATED_RANGE_BUFFER = ^_FILE_ALLOCATED_RANGE_BUFFER;
  TFileAllocatedRangeBuffer = _FILE_ALLOCATED_RANGE_BUFFER;
  PFileAllocatedRangeBuffer = PFILE_ALLOCATED_RANGE_BUFFER;

  // Structure for FSCTL_SET_ZERO_DATA
  {$EXTERNALSYM _FILE_ZERO_DATA_INFORMATION}
  _FILE_ZERO_DATA_INFORMATION = packed record
    FileOffset: LARGE_INTEGER;
    BeyondFinalZero: LARGE_INTEGER;
  end;
  {$EXTERNALSYM FILE_ZERO_DATA_INFORMATION}
  FILE_ZERO_DATA_INFORMATION = _FILE_ZERO_DATA_INFORMATION;
  {$EXTERNALSYM PFILE_ZERO_DATA_INFORMATION}
  PFILE_ZERO_DATA_INFORMATION = ^_FILE_ZERO_DATA_INFORMATION;
  TFileZeroDataInformation = _FILE_ZERO_DATA_INFORMATION;
  PFileZeroDataInformation = PFILE_ZERO_DATA_INFORMATION;

//--------------------------------------------------------------------------------------------------
// NTFS related I/O control codes, types and constants (WinIoCtl.h)
//--------------------------------------------------------------------------------------------------

const
  {$EXTERNALSYM FILE_DEVICE_FILE_SYSTEM}
  FILE_DEVICE_FILE_SYSTEM = $00000009;

  {$EXTERNALSYM METHOD_BUFFERED}
  METHOD_BUFFERED         = 0;
  {$EXTERNALSYM METHOD_IN_DIRECT}
  METHOD_IN_DIRECT        = 1;
  {$EXTERNALSYM METHOD_OUT_DIRECT}
  METHOD_OUT_DIRECT       = 2;
  {$EXTERNALSYM METHOD_NEITHER}
  METHOD_NEITHER          = 3;

  {$EXTERNALSYM FILE_ANY_ACCESS}
  FILE_ANY_ACCESS         = 0;
  {$EXTERNALSYM FILE_SPECIAL_ACCESS}
  FILE_SPECIAL_ACCESS     = FILE_ANY_ACCESS;
  {$EXTERNALSYM FILE_READ_ACCESS}
  FILE_READ_ACCESS        = $0001;
  {$EXTERNALSYM FILE_WRITE_ACCESS}
  FILE_WRITE_ACCESS       = $0002;

  {$EXTERNALSYM FSCTL_GET_COMPRESSION}
  FSCTL_GET_COMPRESSION   = (FILE_DEVICE_FILE_SYSTEM shl 16) or
                            (FILE_ANY_ACCESS shl 14) or
                            (15 shl 2) or METHOD_BUFFERED;
  {$EXTERNALSYM FSCTL_SET_COMPRESSION}
  FSCTL_SET_COMPRESSION   = (FILE_DEVICE_FILE_SYSTEM shl 16) or
                            ((FILE_READ_DATA or FILE_WRITE_DATA) shl 14) or
                            (16 shl 2) or METHOD_BUFFERED;
  {$EXTERNALSYM FSCTL_LOCK_VOLUME}
  FSCTL_LOCK_VOLUME       = (FILE_DEVICE_FILE_SYSTEM shl 16) or
                            (FILE_ANY_ACCESS shl 14) or
                            (6 shl 2) or METHOD_BUFFERED;
  {$EXTERNALSYM FSCTL_UNLOCK_VOLUME}
  FSCTL_UNLOCK_VOLUME     = (FILE_DEVICE_FILE_SYSTEM shl 16) or
                            (FILE_ANY_ACCESS shl 14) or
                            (7 shl 2) or METHOD_BUFFERED;
  {$EXTERNALSYM FSCTL_SET_SPARSE}
  FSCTL_SET_SPARSE        = (FILE_DEVICE_FILE_SYSTEM shl 16) or
                            (FILE_SPECIAL_ACCESS shl 14) or
                            (49 shl 2) or METHOD_BUFFERED;
  {$EXTERNALSYM FSCTL_SET_ZERO_DATA}
  FSCTL_SET_ZERO_DATA     = (FILE_DEVICE_FILE_SYSTEM shl 16) or
                            (FILE_WRITE_DATA shl 14) or
                            (50 shl 2) or METHOD_BUFFERED;
  {$EXTERNALSYM FSCTL_QUERY_ALLOCATED_RANGES}
  FSCTL_QUERY_ALLOCATED_RANGES =
                            (FILE_DEVICE_FILE_SYSTEM shl 16) or
                            (FILE_READ_DATA shl 14) or
                            (51 shl 2) or METHOD_NEITHER;
  {$EXTERNALSYM FSCTL_SET_REPARSE_POINT}
  FSCTL_SET_REPARSE_POINT = (FILE_DEVICE_FILE_SYSTEM shl 16) or
                            (FILE_SPECIAL_ACCESS shl 14) or
                            (41 shl 2) or METHOD_BUFFERED;
  {$EXTERNALSYM FSCTL_GET_REPARSE_POINT}
  FSCTL_GET_REPARSE_POINT = (FILE_DEVICE_FILE_SYSTEM shl 16) or
                            (FILE_ANY_ACCESS shl 14) or
                            (42 shl 2) or METHOD_BUFFERED;
  {$EXTERNALSYM FSCTL_DELETE_REPARSE_POINT}
  FSCTL_DELETE_REPARSE_POINT =
                            (FILE_DEVICE_FILE_SYSTEM shl 16) or
                            (FILE_SPECIAL_ACCESS shl 14) or
                            (43 shl 2) or METHOD_BUFFERED;
  {$EXTERNALSYM FSCTL_REQUEST_OPLOCK_LEVEL_1}
  FSCTL_REQUEST_OPLOCK_LEVEL_1 =
                            (FILE_DEVICE_FILE_SYSTEM shl 16) or
                            (FILE_ANY_ACCESS shl 14) or
                            (0 shl 2) or METHOD_BUFFERED;
  {$EXTERNALSYM FSCTL_REQUEST_OPLOCK_LEVEL_2}
  FSCTL_REQUEST_OPLOCK_LEVEL_2 =
                            (FILE_DEVICE_FILE_SYSTEM shl 16) or
                            (FILE_ANY_ACCESS shl 14) or
                            (1 shl 2) or METHOD_BUFFERED;
  {$EXTERNALSYM FSCTL_REQUEST_BATCH_OPLOCK}
  FSCTL_REQUEST_BATCH_OPLOCK =
                            (FILE_DEVICE_FILE_SYSTEM shl 16) or
                            (FILE_ANY_ACCESS shl 14) or
                            (2 shl 2) or METHOD_BUFFERED;
  {$EXTERNALSYM FSCTL_REQUEST_FILTER_OPLOCK}
  FSCTL_REQUEST_FILTER_OPLOCK =
                            (FILE_DEVICE_FILE_SYSTEM shl 16) or
                            (FILE_ANY_ACCESS shl 14) or
                            (23 shl 2) or METHOD_BUFFERED;
  {$EXTERNALSYM FSCTL_OPLOCK_BREAK_ACKNOWLEDGE}
  FSCTL_OPLOCK_BREAK_ACKNOWLEDGE =
                            (FILE_DEVICE_FILE_SYSTEM shl 16) or
                            (FILE_ANY_ACCESS shl 14) or
                            (3 shl 2) or METHOD_BUFFERED;
  {$EXTERNALSYM FSCTL_OPBATCH_ACK_CLOSE_PENDING}
  FSCTL_OPBATCH_ACK_CLOSE_PENDING =
                            (FILE_DEVICE_FILE_SYSTEM shl 16) or
                            (FILE_ANY_ACCESS shl 14) or
                            (4 shl 2) or METHOD_BUFFERED;
  {$EXTERNALSYM FSCTL_OPLOCK_BREAK_NOTIFY}
  FSCTL_OPLOCK_BREAK_NOTIFY =
                            (FILE_DEVICE_FILE_SYSTEM shl 16) or
                            (FILE_ANY_ACCESS shl 14) or
                            (5 shl 2) or METHOD_BUFFERED;
  {$EXTERNALSYM FSCTL_OPLOCK_BREAK_ACK_NO_2}
  FSCTL_OPLOCK_BREAK_ACK_NO_2 =
                            (FILE_DEVICE_FILE_SYSTEM shl 16) or
                            (FILE_ANY_ACCESS shl 14) or
                            (20 shl 2) or METHOD_BUFFERED;
                            
//==================================================================================================
// from WinUser.h
//==================================================================================================

const
  {$EXTERNALSYM KLF_SETFORPROCESS}
  KLF_SETFORPROCESS         = $00000100;

{$IFNDEF FPC}
const
  {$EXTERNALSYM RT_HTML}
  RT_HTML     = MakeIntResource(23);
  {$EXTERNALSYM RT_MANIFEST}
  RT_MANIFEST = MakeIntResource(24);

  {$EXTERNALSYM CREATEPROCESS_MANIFEST_RESOURCE_ID}
  CREATEPROCESS_MANIFEST_RESOURCE_ID                 = MakeIntResource(1);
  {$EXTERNALSYM ISOLATIONAWARE_MANIFEST_RESOURCE_ID}
  ISOLATIONAWARE_MANIFEST_RESOURCE_ID                = MakeIntResource(2);
  {$EXTERNALSYM ISOLATIONAWARE_NOSTATICIMPORT_MANIFEST_RESOURCE_ID}
  ISOLATIONAWARE_NOSTATICIMPORT_MANIFEST_RESOURCE_ID = MakeIntResource(3);
  {$EXTERNALSYM MINIMUM_RESERVED_MANIFEST_RESOURCE_ID}
  MINIMUM_RESERVED_MANIFEST_RESOURCE_ID              = MakeIntResource(1);
  {$EXTERNALSYM MAXIMUM_RESERVED_MANIFEST_RESOURCE_ID}
  MAXIMUM_RESERVED_MANIFEST_RESOURCE_ID              = MakeIntResource(16);
{$ENDIF ~FPC}

//==================================================================================================
// from LMcons.h
//==================================================================================================

const
  // Value to be used with APIs which have a "preferred maximum length"
  // parameter.  This value indicates that the API should just allocate
  // "as much as it takes."
  MAX_PREFERRED_LENGTH = DWORD(-1);

type
  {$EXTERNALSYM NET_API_STATUS}
  NET_API_STATUS = DWORD;

//==================================================================================================
// from LMaccess.h
//==================================================================================================

type
  {$EXTERNALSYM _USER_INFO_2}
  _USER_INFO_2 = packed record
    usri2_name: LPWSTR;
    usri2_password: LPWSTR;
    usri2_password_age: DWORD;
    usri2_priv: DWORD;
    usri2_home_dir: LPWSTR;
    usri2_comment: LPWSTR;
    usri2_flags: DWORD;
    usri2_script_path: LPWSTR;
    usri2_auth_flags: DWORD;
    usri2_full_name: LPWSTR;
    usri2_usr_comment: LPWSTR;
    usri2_parms: LPWSTR;
    usri2_workstations: LPWSTR;
    usri2_last_logon: DWORD;
    usri2_last_logoff: DWORD;
    usri2_acct_expires: DWORD;
    usri2_max_storage: DWORD;
    usri2_units_per_week: DWORD;
    usri2_logon_hours: PBYTE;
    usri2_bad_pw_count: DWORD;
    usri2_num_logons: DWORD;
    usri2_logon_server: LPWSTR;
    usri2_country_code: DWORD;
    usri2_code_page: DWORD;
  end;
  {$EXTERNALSYM USER_INFO_2}
  USER_INFO_2 = _USER_INFO_2;
  {$EXTERNALSYM PUSER_INFO_2}
  PUSER_INFO_2 = ^_USER_INFO_2;
  {$EXTERNALSYM LPUSER_INFO_2}
  LPUSER_INFO_2 = PUSER_INFO_2;
  TUserInfo2 = _USER_INFO_2;
  PUserInfo2 = PUSER_INFO_2;

  // Data Structures - Group
  {$EXTERNALSYM _GROUP_INFO_0}
  _GROUP_INFO_0 = packed record
    grpi0_name: LPWSTR;
  end;
  {$EXTERNALSYM GROUP_INFO_0}
  GROUP_INFO_0 = _GROUP_INFO_0;
  {$EXTERNALSYM PGROUP_INFO_0}
  PGROUP_INFO_0 = ^_GROUP_INFO_0;
  {$EXTERNALSYM LPGROUP_INFO_0}
  LPGROUP_INFO_0 = PGROUP_INFO_0;
  TGroupInfo0 = _GROUP_INFO_0;
  PGroupInfo0 = PGROUP_INFO_0;

  {$EXTERNALSYM _GROUP_INFO_1}
  _GROUP_INFO_1 = packed record
    grpi1_name: LPWSTR;
    grpi1_comment: LPWSTR;
  end;
  {$EXTERNALSYM GROUP_INFO_1}
  GROUP_INFO_1 = _GROUP_INFO_1;
  {$EXTERNALSYM PGROUP_INFO_1}
  PGROUP_INFO_1 = ^_GROUP_INFO_1;
  {$EXTERNALSYM LPGROUP_INFO_1}
  LPGROUP_INFO_1 = PGROUP_INFO_1;
  TGroupInfo1 = _GROUP_INFO_1;
  PGroupInfo1 = PGROUP_INFO_1;

  // Data Structures - LocalGroup
  {$EXTERNALSYM _LOCALGROUP_INFO_0}
  _LOCALGROUP_INFO_0 = packed record
    lgrpi0_name: LPWSTR;
  end;
  {$EXTERNALSYM LOCALGROUP_INFO_0}
  LOCALGROUP_INFO_0 = _LOCALGROUP_INFO_0;
  {$EXTERNALSYM PLOCALGROUP_INFO_0}
  PLOCALGROUP_INFO_0 = ^_LOCALGROUP_INFO_0;
  {$EXTERNALSYM LPLOCALGROUP_INFO_0}
  LPLOCALGROUP_INFO_0 = PLOCALGROUP_INFO_0;
  TLocalGroupInfo0 = _LOCALGROUP_INFO_0;
  PLocalGroupInfo0 = PLOCALGROUP_INFO_0;

  {$EXTERNALSYM _LOCALGROUP_INFO_1}
  _LOCALGROUP_INFO_1 = packed record
    lgrpi1_name: LPWSTR;
    lgrpi1_comment: LPWSTR;
  end;
  {$EXTERNALSYM LOCALGROUP_INFO_1}
  LOCALGROUP_INFO_1 = _LOCALGROUP_INFO_1;
  {$EXTERNALSYM PLOCALGROUP_INFO_1}
  PLOCALGROUP_INFO_1 = ^_LOCALGROUP_INFO_1;
  {$EXTERNALSYM LPLOCALGROUP_INFO_1}
  LPLOCALGROUP_INFO_1 = PLOCALGROUP_INFO_1;
  TLocalGroupInfo1 = _LOCALGROUP_INFO_1;
  PLocalGroupInfo1 = PLOCALGROUP_INFO_1;

  {$EXTERNALSYM _LOCALGROUP_MEMBERS_INFO_3}
  _LOCALGROUP_MEMBERS_INFO_3 = packed record
    lgrmi3_domainandname: LPWSTR;
  end;
  {$EXTERNALSYM LOCALGROUP_MEMBERS_INFO_3}
  LOCALGROUP_MEMBERS_INFO_3 = _LOCALGROUP_MEMBERS_INFO_3;
  {$EXTERNALSYM PLOCALGROUP_MEMBERS_INFO_3}
  PLOCALGROUP_MEMBERS_INFO_3 = ^_LOCALGROUP_MEMBERS_INFO_3;
  {$EXTERNALSYM LPLOCALGROUP_MEMBERS_INFO_3}
  LPLOCALGROUP_MEMBERS_INFO_3 = PLOCALGROUP_MEMBERS_INFO_3;
  TLocalGroupMemberInfo3 = _LOCALGROUP_MEMBERS_INFO_3;
  PLocalGroupMemberInfo3 = PLOCALGROUP_MEMBERS_INFO_3;

const
  // Privilege levels (USER_INFO_X field usriX_priv (X = 0/1)).
  {$EXTERNALSYM USER_PRIV_MASK}
  USER_PRIV_MASK  = $3;
  {$EXTERNALSYM USER_PRIV_GUEST}
  USER_PRIV_GUEST = 0;
  {$EXTERNALSYM USER_PRIV_USER}
  USER_PRIV_USER  = 1;
  {$EXTERNALSYM USER_PRIV_ADMIN}
  USER_PRIV_ADMIN = 2;

  // Bit masks for field usriX_flags of USER_INFO_X (X = 0/1).
  {$EXTERNALSYM UF_SCRIPT}
  UF_SCRIPT                          = $0001;
  {$EXTERNALSYM UF_ACCOUNTDISABLE}
  UF_ACCOUNTDISABLE                  = $0002;
  {$EXTERNALSYM UF_HOMEDIR_REQUIRED}
  UF_HOMEDIR_REQUIRED                = $0008;
  {$EXTERNALSYM UF_LOCKOUT}
  UF_LOCKOUT                         = $0010;
  {$EXTERNALSYM UF_PASSWD_NOTREQD}
  UF_PASSWD_NOTREQD                  = $0020;
  {$EXTERNALSYM UF_PASSWD_CANT_CHANGE}
  UF_PASSWD_CANT_CHANGE              = $0040;
  {$EXTERNALSYM UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED}
  UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED = $0080;

  {$EXTERNALSYM UF_DONT_EXPIRE_PASSWD}
  UF_DONT_EXPIRE_PASSWD                     = $10000;
  {$EXTERNALSYM UF_MNS_LOGON_ACCOUNT}
  UF_MNS_LOGON_ACCOUNT                      = $20000;
  {$EXTERNALSYM UF_SMARTCARD_REQUIRED}
  UF_SMARTCARD_REQUIRED                     = $40000;
  {$EXTERNALSYM UF_TRUSTED_FOR_DELEGATION}
  UF_TRUSTED_FOR_DELEGATION                 = $80000;
  {$EXTERNALSYM UF_NOT_DELEGATED}
  UF_NOT_DELEGATED                          = $100000;
  {$EXTERNALSYM UF_USE_DES_KEY_ONLY}
  UF_USE_DES_KEY_ONLY                       = $200000;
  {$EXTERNALSYM UF_DONT_REQUIRE_PREAUTH}
  UF_DONT_REQUIRE_PREAUTH                   = $400000;
  {$EXTERNALSYM UF_PASSWORD_EXPIRED}
  UF_PASSWORD_EXPIRED                       = $800000;
  {$EXTERNALSYM UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION}
  UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION = $1000000;

  {$EXTERNALSYM TIMEQ_FOREVER}
  TIMEQ_FOREVER = LongWord(-1);

//--------------------------------------------------------------------------------------------------
// Run time dynamic linking
//--------------------------------------------------------------------------------------------------

function RtdlNetUserAdd({optional} servername: LPCWSTR; level: DWORD;
  buf: PByte; {out optional} parm_err: PDWord): NET_API_STATUS;
function RtdlNetUserDel({optional} servername: LPCWSTR; username: LPCWSTR): NET_API_STATUS;
function RtdlNetGroupAdd({optional} servername: LPCWSTR; level: DWORD; buf: PByte;
  {out optional} parm_err: PDWord): NET_API_STATUS;
function RtdlNetGroupEnum({optional} servername: LPCWSTR; level: DWORD;
  out bufptr: PByte; prefmaxlen: DWORD; out entriesread, totalentries: DWORD;
  {in out optional} resume_handle: PDWORD_PTR): NET_API_STATUS;
function RtdlNetGroupDel({optional} servername: LPCWSTR; groupname: LPCWSTR): NET_API_STATUS;
function RtdlNetLocalGroupAdd({optional} servername: LPCWSTR; level: DWORD;
  buf: PByte; {out optional} parm_err: PDWord): NET_API_STATUS;
function RtdlNetLocalGroupEnum({optional} servername: LPCWSTR; level: DWORD;
  out bufptr: PByte; prefmaxlen: DWORD; out entriesread, totalentries: DWORD;
  {in out optional} resumehandle: PDWORD_PTR): NET_API_STATUS;
function RtdlNetLocalGroupDel({optional} servername: LPCWSTR; groupname: LPCWSTR): NET_API_STATUS;
function RtdlNetLocalGroupAddMembers({optional} servername: LPCWSTR; groupname: LPCWSTR;
  level: DWORD; buf: PByte; totalentries: DWORD): NET_API_STATUS;

//==================================================================================================
// from LMAPIbuf.h
//==================================================================================================

//--------------------------------------------------------------------------------------------------
// Run time dynamic linking
//--------------------------------------------------------------------------------------------------

function RtdlNetApiBufferFree(Buffer: Pointer): NET_API_STATUS;

//==================================================================================================
// from LMErr.h
//==================================================================================================

const
  NERR_Success = 0;  // Success

//==================================================================================================
// from ImageHlp.h
//==================================================================================================

type
  {$EXTERNALSYM _LOADED_IMAGE}
  _LOADED_IMAGE = packed record
    ModuleName: PSTR;
    hFile: THandle;
    MappedAddress: PAnsiChar;  // PUCHAR
    FileHeader: PIMAGE_NT_HEADERS;
    LastRvaSection: PIMAGE_SECTION_HEADER;
    NumberOfSections: ULONG;
    Sections: PIMAGE_SECTION_HEADER;
    Characteristics: ULONG;
    fSystemImage: ByteBool;
    fDOSImage: ByteBool;
    Links: LIST_ENTRY;
    SizeOfImage: ULONG;
  end;
  {$EXTERNALSYM LOADED_IMAGE}
  LOADED_IMAGE = _LOADED_IMAGE;
  {$EXTERNALSYM PLOADED_IMAGE}
  PLOADED_IMAGE = ^_LOADED_IMAGE;
  TLoadedImage = _LOADED_IMAGE;
  PLoadedImage = PLOADED_IMAGE;

  {$EXTERNALSYM _IMAGEHLP_STATUS_REASON}
  _IMAGEHLP_STATUS_REASON = (
    {$EXTERNALSYM BindOutOfMemory}
    BindOutOfMemory,
    {$EXTERNALSYM BindRvaToVaFailed}
    BindRvaToVaFailed,
    {$EXTERNALSYM BindNoRoomInImage}
    BindNoRoomInImage,
    {$EXTERNALSYM BindImportModuleFailed}
    BindImportModuleFailed,
    {$EXTERNALSYM BindImportProcedureFailed}
    BindImportProcedureFailed,
    {$EXTERNALSYM BindImportModule}
    BindImportModule,
    {$EXTERNALSYM BindImportProcedure}
    BindImportProcedure,
    {$EXTERNALSYM BindForwarder}
    BindForwarder,
    {$EXTERNALSYM BindForwarderNOT}
    BindForwarderNOT,
    {$EXTERNALSYM BindImageModified}
    BindImageModified,
    {$EXTERNALSYM BindExpandFileHeaders}
    BindExpandFileHeaders,
    {$EXTERNALSYM BindImageComplete}
    BindImageComplete,
    {$EXTERNALSYM BindMismatchedSymbols}
    BindMismatchedSymbols,
    {$EXTERNALSYM BindSymbolsNotUpdated}
    BindSymbolsNotUpdated,
    {$EXTERNALSYM BindImportProcedure32}
    BindImportProcedure32,
    {$EXTERNALSYM BindImportProcedure64}
    BindImportProcedure64,
    {$EXTERNALSYM BindForwarder32}
    BindForwarder32,
    {$EXTERNALSYM BindForwarder64}
    BindForwarder64,
    {$EXTERNALSYM BindForwarderNOT32}
    BindForwarderNOT32,
    {$EXTERNALSYM BindForwarderNOT64}
    BindForwarderNOT64
  );
  {$EXTERNALSYM IMAGEHLP_STATUS_REASON}
  IMAGEHLP_STATUS_REASON = _IMAGEHLP_STATUS_REASON;
  TImageHlpStatusReason = _IMAGEHLP_STATUS_REASON;

  {$EXTERNALSYM PIMAGEHLP_STATUS_ROUTINE}
  PIMAGEHLP_STATUS_ROUTINE = function(Reason: IMAGEHLP_STATUS_REASON;
    ImageName, DllName: PSTR; Va, Parameter: ULONG_PTR): BOOL; stdcall;
  TImageHlpStatusRoutine = PIMAGEHLP_STATUS_ROUTINE;

{$EXTERNALSYM CheckSumMappedFile}
function CheckSumMappedFile(BaseAddress: Pointer; FileLength: DWORD;
  HeaderSum, CheckSum: PDWORD): PIMAGE_NT_HEADERS; stdcall;

{$EXTERNALSYM MapAndLoad}
function MapAndLoad(ImageName, DllPath: PSTR; LoadedImage: PLOADED_IMAGE;
  DotDll, ReadOnly: BOOL): BOOL; stdcall;

{$EXTERNALSYM UnMapAndLoad}
function UnMapAndLoad(LoadedImage: PLOADED_IMAGE): BOOL; stdcall;

{$EXTERNALSYM ImageDirectoryEntryToData}
function ImageDirectoryEntryToData(Base: Pointer; MappedAsImage: ByteBool;
  DirectoryEntry: Word; out Size: ULONG): Pointer; stdcall;

{$EXTERNALSYM GetImageUnusedHeaderBytes}
function GetImageUnusedHeaderBytes(LoadedImage: PLOADED_IMAGE;
  out SizeUnusedHeaderBytes: DWORD): DWORD; stdcall;

{$EXTERNALSYM ImageRvaToSection}
function ImageRvaToSection(NtHeaders: PIMAGE_NT_HEADERS; Base: Pointer;
  Rva: ULONG): PIMAGE_SECTION_HEADER; stdcall;

{$EXTERNALSYM ReBaseImage}
function ReBaseImage(
  CurrentImageName: PSTR;       // IN
  SymbolPath: PSTR;             // IN
  fReBase: BOOL;                // IN     TRUE if actually rebasing, false if only summing
  fRebaseSysfileOk: BOOL;       // IN     TRUE is system images s/b rebased
  fGoingDown: BOOL;             // IN     TRUE if the image s/b rebased below the given base
  CheckImageSize: ULONG;        // IN     Max size allowed  (0 if don't care)
  out OldImageSize: ULONG;      // OUT    Returned from the header
  out OldImageBase: ULONG_PTR;  // OUT    Returned from the header
  out NewImageSize: ULONG;      // OUT    Image size rounded to next separation boundary
  var NewImageBase: ULONG_PTR;  // IN OUT (in) Desired new address.
                                //        (out) Next address (actual if going down)
  TimeStamp: ULONG              // IN     new timestamp for image, if non-zero
  ): BOOL; stdcall;


// UnDecorateSymbolName Flags

const
  {$EXTERNALSYM UNDNAME_COMPLETE}
  UNDNAME_COMPLETE               = $0000;  // Enable full undecoration
  {$EXTERNALSYM UNDNAME_NO_LEADING_UNDERSCORES}
  UNDNAME_NO_LEADING_UNDERSCORES = $0001;  // Remove leading underscores from MS extended keywords
  {$EXTERNALSYM UNDNAME_NO_MS_KEYWORDS}
  UNDNAME_NO_MS_KEYWORDS         = $0002;  // Disable expansion of MS extended keywords
  {$EXTERNALSYM UNDNAME_NO_FUNCTION_RETURNS}
  UNDNAME_NO_FUNCTION_RETURNS    = $0004;  // Disable expansion of return type for primary declaration
  {$EXTERNALSYM UNDNAME_NO_ALLOCATION_MODEL}
  UNDNAME_NO_ALLOCATION_MODEL    = $0008;  // Disable expansion of the declaration model
  {$EXTERNALSYM UNDNAME_NO_ALLOCATION_LANGUAGE}
  UNDNAME_NO_ALLOCATION_LANGUAGE = $0010;  // Disable expansion of the declaration language specifier
  {$EXTERNALSYM UNDNAME_NO_MS_THISTYPE}
  UNDNAME_NO_MS_THISTYPE         = $0020;  // NYI Disable expansion of MS keywords on the 'this' type for primary declaration
  {$EXTERNALSYM UNDNAME_NO_CV_THISTYPE}
  UNDNAME_NO_CV_THISTYPE         = $0040;  // NYI Disable expansion of CV modifiers on the 'this' type for primary declaration
  {$EXTERNALSYM UNDNAME_NO_THISTYPE}
  UNDNAME_NO_THISTYPE            = $0060;  // Disable all modifiers on the 'this' type
  {$EXTERNALSYM UNDNAME_NO_ACCESS_SPECIFIERS}
  UNDNAME_NO_ACCESS_SPECIFIERS   = $0080;  // Disable expansion of access specifiers for members
  {$EXTERNALSYM UNDNAME_NO_THROW_SIGNATURES}
  UNDNAME_NO_THROW_SIGNATURES    = $0100;  // Disable expansion of 'throw-signatures' for functions and pointers to functions
  {$EXTERNALSYM UNDNAME_NO_MEMBER_TYPE}
  UNDNAME_NO_MEMBER_TYPE         = $0200;  // Disable expansion of 'static' or 'virtual'ness of members
  {$EXTERNALSYM UNDNAME_NO_RETURN_UDT_MODEL}
  UNDNAME_NO_RETURN_UDT_MODEL    = $0400;  // Disable expansion of MS model for UDT returns
  {$EXTERNALSYM UNDNAME_32_BIT_DECODE}
  UNDNAME_32_BIT_DECODE          = $0800;  // Undecorate 32-bit decorated names
  {$EXTERNALSYM UNDNAME_NAME_ONLY}
  UNDNAME_NAME_ONLY              = $1000;  // Crack only the name for primary declaration;
                                           //  return just [scope::]name.  Does expand template params
  {$EXTERNALSYM UNDNAME_NO_ARGUMENTS}
  UNDNAME_NO_ARGUMENTS           = $2000;  // Don't undecorate arguments to function
  {$EXTERNALSYM UNDNAME_NO_SPECIAL_SYMS}
  UNDNAME_NO_SPECIAL_SYMS        = $4000;  // Don't undecorate special names (v-table, vcall, vector xxx, metatype, etc)

{$EXTERNALSYM UnDecorateSymbolName}
function UnDecorateSymbolName(
  DecoratedName: PCSTR;      // Name to undecorate
  UnDecoratedName: PSTR;     // If NULL, it will be allocated
  UndecoratedLength: DWORD;  // The maximym length
  Flags: DWORD               // See above.
  ): DWORD; stdcall;

const
  ImageHlpLib = 'imagehlp.dll';

{$IFNDEF FPC}
type
  PPImageSectionHeader = ^PImageSectionHeader;
{$ENDIF ~FPC}
  
//--------------------------------------------------------------------------------------------------
// Alternative conversions
//--------------------------------------------------------------------------------------------------

{ TODO : don't used in the JCL }

{$IFNDEF FPC}
// wrong translation - last parameter is incorrect
{$EXTERNALSYM BindImageEx}
function BindImageEx(Flags: DWORD; ImageName, DllPath, SymbolPath: LPSTR;
  StatusRoutine: TImageHlpStatusRoutine): Bool; stdcall;
{$ENDIF ~FPC}

// wrong translation - last parameter is incorrect
{$EXTERNALSYM ImageEnumerateCertificates}
function ImageEnumerateCertificates(FileHandle: THandle; TypeFilter: Word;
  CertificateCount, Indices: PDWORD; IndexCount: DWORD): Bool; stdcall; 

//--------------------------------------------------------------------------------------------------
// Run time dynamic linking
//--------------------------------------------------------------------------------------------------

function RtdlImageRvaToVa(NtHeaders: PImageNtHeaders; Base: Pointer;
  Rva: ULONG; LastRvaSection: PPImageSectionHeader): Pointer;

//==================================================================================================
// presumable from any older WinNT.h or from WinIfs.h
//==================================================================================================

//--------------------------------------------------------------------------------------------------
// NTFS Reparse Points
//--------------------------------------------------------------------------------------------------

// The reparse structure is used by layered drivers to store data in a
// reparse point. The constraints on reparse tags are defined below.
// This version of the reparse data buffer is only for Microsoft tags.

(*$HPPEMIT 'typedef struct _REPARSE_DATA_BUFFER {'*)
(*$HPPEMIT ''*)
(*$HPPEMIT '    DWORD   ReparseTag;'*)
(*$HPPEMIT '    WORD    ReparseDataLength;'*)
(*$HPPEMIT '    WORD    Reserved;'*)
(*$HPPEMIT ''*)
(*$HPPEMIT '    union {'*)
(*$HPPEMIT ''*)
(*$HPPEMIT '        struct {'*)
(*$HPPEMIT '            WORD    SubstituteNameOffset;'*)
(*$HPPEMIT '            WORD    SubstituteNameLength;'*)
(*$HPPEMIT '            WORD    PrintNameOffset;'*)
(*$HPPEMIT '            WORD    PrintNameLength;'*)
(*$HPPEMIT '            WCHAR   PathBuffer[1];'*)
(*$HPPEMIT '        } SymbolicLinkReparseBuffer;'*)
(*$HPPEMIT ''*)
(*$HPPEMIT '        struct {'*)
(*$HPPEMIT '            WORD    SubstituteNameOffset;'*)
(*$HPPEMIT '            WORD    SubstituteNameLength;'*)
(*$HPPEMIT '            WORD    PrintNameOffset;'*)
(*$HPPEMIT '            WORD    PrintNameLength;'*)
(*$HPPEMIT '            WCHAR   PathBuffer[1];'*)
(*$HPPEMIT '        } MountPointReparseBuffer;'*)
(*$HPPEMIT ''*)
(*$HPPEMIT '        struct {'*)
(*$HPPEMIT '            UCHAR   DataBuffer[1];'*)
(*$HPPEMIT '        } GenericReparseBuffer;'*)
(*$HPPEMIT '    };'*)
(*$HPPEMIT ''*)
(*$HPPEMIT '} REPARSE_DATA_BUFFER, *PREPARSE_DATA_BUFFER;'*)
(*$HPPEMIT ''*)
(*$HPPEMIT '#ifndef REPARSE_DATA_BUFFER_HEADER_SIZE'*)
(*$HPPEMIT '#define REPARSE_DATA_BUFFER_HEADER_SIZE   8'*)
(*$HPPEMIT '#endif'*)
(*$HPPEMIT ''*)
(*$HPPEMIT 'typedef struct _REPARSE_POINT_INFORMATION {'*)
(*$HPPEMIT '        WORD    ReparseDataLength;'*)
(*$HPPEMIT '        WORD    UnparsedNameLength;'*)
(*$HPPEMIT '} REPARSE_POINT_INFORMATION, *PREPARSE_POINT_INFORMATION;'*)
(*$HPPEMIT ''*)
(*$HPPEMIT '#ifndef IO_REPARSE_TAG_VALID_VALUES'*)
(*$HPPEMIT '#define IO_REPARSE_TAG_VALID_VALUES 0x0E000FFFF'*)
(*$HPPEMIT '#endif'*)
(*$HPPEMIT ''*)

type
  {$EXTERNALSYM _REPARSE_DATA_BUFFER}
  _REPARSE_DATA_BUFFER = record
    ReparseTag: DWORD;
    ReparseDataLength: Word;
    Reserved: Word;
    case Integer of
      0: ( // SymbolicLinkReparseBuffer and MountPointReparseBuffer
        SubstituteNameOffset: Word;
        SubstituteNameLength: Word;
        PrintNameOffset: Word;
        PrintNameLength: Word;
        PathBuffer: array [0..0] of WCHAR);
      1: ( // GenericReparseBuffer
        DataBuffer: array [0..0] of Byte);
  end;
  {$EXTERNALSYM REPARSE_DATA_BUFFER}
  REPARSE_DATA_BUFFER = _REPARSE_DATA_BUFFER;
  {$EXTERNALSYM PREPARSE_DATA_BUFFER}
  PREPARSE_DATA_BUFFER = ^_REPARSE_DATA_BUFFER;
  TReparseDataBuffer = _REPARSE_DATA_BUFFER;
  PReparseDataBuffer = PREPARSE_DATA_BUFFER;

const
  {$EXTERNALSYM REPARSE_DATA_BUFFER_HEADER_SIZE}
  REPARSE_DATA_BUFFER_HEADER_SIZE = 8;

type
  {$EXTERNALSYM _REPARSE_POINT_INFORMATION}
  _REPARSE_POINT_INFORMATION = record
    ReparseDataLength: Word;
    UnparsedNameLength: Word;
  end;
  {$EXTERNALSYM REPARSE_POINT_INFORMATION}
  REPARSE_POINT_INFORMATION = _REPARSE_POINT_INFORMATION;
  {$EXTERNALSYM PREPARSE_POINT_INFORMATION}
  PREPARSE_POINT_INFORMATION = ^_REPARSE_POINT_INFORMATION;
  TReparsePointInformation = _REPARSE_POINT_INFORMATION;
  PReparsePointInformation = PREPARSE_POINT_INFORMATION;

const
  {$EXTERNALSYM IO_REPARSE_TAG_VALID_VALUES}
  IO_REPARSE_TAG_VALID_VALUES = DWORD($E000FFFF);

//==================================================================================================
// from WinSpool.h
//==================================================================================================

// need Win2k or later
function RtdlSetDefaultPrinter(pszPrinter: LPCSTR): BOOL; 

//==================================================================================================
// from winternl.h
//==================================================================================================

type
  {$EXTERNALSYM NTSTATUS}
  NTSTATUS = LongInt;

//==================================================================================================
// from ntstatus.h
//==================================================================================================

const
  STATUS_SUCCESS         = NTSTATUS($00000000);  // ntsubauth

  // MessageId: STATUS_NOT_IMPLEMENTED
  //
  // MessageText:
  //
  //  {Not Implemented}
  //  The requested operation is not implemented.
  //
  STATUS_NOT_IMPLEMENTED = NTSTATUS($C0000002);

//==================================================================================================
// from Native API
//==================================================================================================

// for documentation see: http://undocumented.ntinternals.net/

type
  // There are two Event types in WinNT:
  // NotificationEvent
  //   Known also as manual-reset event. Caller decide about state of event.
  //   You can use NtClearEvent or NtResetEvent to put Event Object into
  //   non-signaled state.
  // SynchronizationEvent
  //   Known as auto-reset event. This type automatically change his state to
  //   non-signaled after releasing any (but only one) waiting thread.
  _EVENT_TYPE = (NotificationEvent, SynchronizationEvent);
  EVENT_TYPE = _EVENT_TYPE;
  TEventType = _EVENT_TYPE;

  _EVENT_INFORMATION_CLASS = (EventBasicInformation);
  EVENT_INFORMATION_CLASS = _EVENT_INFORMATION_CLASS;
  TEventInformationClass = _EVENT_INFORMATION_CLASS;

  _EVENT_BASIC_INFORMATION = packed record
    EventType: EVENT_TYPE;  // Type of Event Object. Can be SynchronizationEvent
                            // or NotificationEvent. See EVENT_TYPE for details.
    SignalState: LongInt;   // Current state of Event Object.
  end;
  EVENT_BASIC_INFORMATION = _EVENT_BASIC_INFORMATION;
  PEVENT_BASIC_INFORMATION = ^_EVENT_BASIC_INFORMATION;
  TEventBasicInformation = _EVENT_BASIC_INFORMATION;
  PEventBasicInformation = PEVENT_BASIC_INFORMATION;

// EventHandle
//   HANDLE to Event Object opened with EVENT_QUERY_STATE access.
// EventInformationClass
//   See EVENT_INFORMATION_CLASS for details.
// EventInformation
//   Caller's allocated buffer for result data.
// EventInformationLength
//   Length of EventInformation buffer, in bytes.
// ResultLength
//   Returns required/used size of EventInformation buffer.
function RtdlNtQueryEvent(EventHandle: THandle;
  EventInformationClass: EVENT_INFORMATION_CLASS; {out} EventInformation: Pointer;
  EventInformationLength: ULONG; {out, optional} ResultLength: PULONG): NTSTATUS; stdcall;

//--------------------------------------------------------------------------------------------------

type
  _MUTANT_INFORMATION_CLASS = (MutantBasicInformation);
  MUTANT_INFORMATION_CLASS = _MUTANT_INFORMATION_CLASS;
  TMutantInformationClass = _MUTANT_INFORMATION_CLASS;

  _MUTANT_BASIC_INFORMATION = packed record
    CurrentCount: LongInt;     // If CurrentCount is less than zero, mutant is signaled.
    OwnedByCaller: ByteBool;   // It's TRUE if mutant is signaled by caller's thread.
    AbandonedState: ByteBool;  // Is set when thread terminates without call NtReleaseMutant.
  end;

  MUTANT_BASIC_INFORMATION = _MUTANT_BASIC_INFORMATION;
  PMUTANT_BASIC_INFORMATION = ^_MUTANT_BASIC_INFORMATION;
  TMutantBasicInformation = _MUTANT_BASIC_INFORMATION;
  PMutantBasicInformation = PMUTANT_BASIC_INFORMATION;

// MutantHandle
//   MutantHandleHandle to Mutant object.
// MutantInformationClass
//   {MutantBasicInformation}
// MutantInformation
//   MutantInformationBuffer for result. As long as only one information type
//   is defined, set MutantInformation as a pointer to MUTANT_BASIC_INFORMATION
//   structure.
// MutantInformationLength
//   MutantInformationLengthSize of buffer.
// ResultLengthNumber
//   ResultLengthNumber of bytes written to buffer.
function RtdlNtQueryMutant(MutantHandle: THandle;
  MutantInformationClass: MUTANT_INFORMATION_CLASS; {out} MutantInformation: Pointer;
  MutantInformationLength: ULONG; {out, optional} ResultLength: PULONG): NTSTATUS; stdcall;

//--------------------------------------------------------------------------------------------------

type
  _SEMAPHORE_INFORMATION_CLASS = (SemaphoreBasicInformation);
  SEMAPHORE_INFORMATION_CLASS = _SEMAPHORE_INFORMATION_CLASS;
  TSemaphoreInformationClass = _SEMAPHORE_INFORMATION_CLASS;

  _SEMAPHORE_BASIC_INFORMATION = record
    CurrentCount: LongInt;  // Current state of semaphore's counter. 
    MaximumCount: LongInt;  // Maximum counter position, defined with call to
                            // NtCreateSemaphore.
  end;
  SEMAPHORE_BASIC_INFORMATION = _SEMAPHORE_BASIC_INFORMATION;
  PSEMAPHORE_BASIC_INFORMATION = ^_SEMAPHORE_BASIC_INFORMATION;
  TSemaphoreBasicInformation = _SEMAPHORE_BASIC_INFORMATION;
  PSemaphoreBasicInformation = PSEMAPHORE_BASIC_INFORMATION;

// Function NtQuerySemaphore retrieve semaphore's parameters. 

// SemaphoreHandle
//   HANDLE to Semaphore Object opened with SEMAPHORE_QUERY_STATE access. 
// SemaphoreInformationClass
//   Information class descripted in SEMAPHORE_INFORMATION_CLASS section. 
// SemaphoreInformation
//   Pointer to user's allocated buffer for result data. 
// SemaphoreInformationLength
//   Size of SemaphoreInformation buffer, in bytes. 
// ResultLength
//   Optionally returns required buffer size. 
function RtdlNtQuerySemaphore(SemaphoreHandle: THandle;
  SemaphoreInformationClass: SEMAPHORE_INFORMATION_CLASS;
  SemaphoreInformation: Pointer; SemaphoreInformationLength: ULONG;
  ResultLength: PULONG): NTSTATUS; stdcall;

//--------------------------------------------------------------------------------------------------

type
  // Currently only one information class is avaiable for Timer Object.
  // Information buffer is TIMER_BASIC_INFORMATION structure.
  _TIMER_INFORMATION_CLASS = (TimerBasicInformation);
  TIMER_INFORMATION_CLASS = _TIMER_INFORMATION_CLASS;

  _TIMER_BASIC_INFORMATION = packed record
    RemainingTime: LARGE_INTEGER;  // Contains time (in 100ns units) to next
                                   // timer signal (negative value), or time
                                   // after last signalization.
    TimerState: ByteBool;          // If TRUE, timer is signaled.
  end;
  TIMER_BASIC_INFORMATION = _TIMER_BASIC_INFORMATION;
  PTIMER_BASIC_INFORMATION = ^_TIMER_BASIC_INFORMATION;
  TTimerBasicInformation = _TIMER_BASIC_INFORMATION;
  PTimerBasicInformation = PTIMER_BASIC_INFORMATION;

// NtQueryTimer
//
// TimerHandle
//   HANDLE to Timer Object opened with TIMER_QUERY_STATE access.
// TimerInformationClass
//   Information class. See TIMER_INFORMATION_CLASS for details.
// TimerInformation
//   User's allocated buffer for result data.
// TimerInformationLength
//   Length of TimerInformation buffer, in bytes.
// ResultLength
//   Optional pointer to value received used/required length of TimerInformation buffer.
function RtdlNtQueryTimer(TimerHandle: THandle;
  TimerInformationClass: TIMER_INFORMATION_CLASS; {out} TimerInformation: Pointer;
  TimerInformationLength: ULONG; {out, optional} ResultLength: PULONG): NTSTATUS; stdcall;

//==================================================================================================
// Helper functions
//==================================================================================================

function InitNetbios: Boolean; // obsolete
procedure ExitNetbios; // do nothing, obsolete


//==================================================================================================
// COM related declarations
//==================================================================================================

{ TODO : Don't used in the JCL }
type
  TCoCreateInstanceExProc = function (const clsid: TGUID;
    unkOuter: IUnknown; dwClsCtx: Longint; ServerInfo: Pointer{PCoServerInfo};
    dwCount: Longint; rgmqResults: Pointer{PMultiQIArray}): HResult stdcall;

(* correct conversion
  TFNCoCreateInstanceExProc = function (const clsid: TGUID;
    unkOuter: IUnknown; dwClsCtx: DWORD; ServerInfo: Pointer{PCOSERVERINFO};
    dwCount: ULONG; rgmqResults: Pointer{PMULTI_QI}): HResult stdcall;
*)

implementation

//==================================================================================================
// Run time dynamic linking
//==================================================================================================

const
  CallNotImplemented = Pointer(-1);

function JclLoadLibrary(var LibHandle: HModule; LibFileName: LPCTSTR): HModule;
begin
  if LibHandle = 0 then
  begin
    LibHandle := LoadLibrary(LibFileName);
    if LibHandle = 0 then
      LibHandle := INVALID_HANDLE_VALUE;
  end;
  Result := LibHandle;
end;

function JclGetModuleHandle(var LibHandle: HModule; LibFileName: LPCTSTR): HModule;
begin
  if LibHandle = 0 then
  begin
    LibHandle := GetModuleHandle(LibFileName);
    if LibHandle = 0 then
      LibHandle := INVALID_HANDLE_VALUE;
  end;
  Result := LibHandle;
end;

procedure JclFreeLibrary(LibHandle: HModule);
begin
  case LibHandle of
    0, INVALID_HANDLE_VALUE: ;
  else
    FreeLibrary(LibHandle);
  end;
end;

function JclGetProcAddress(var Call: Pointer; LibHandle: HModule; ProcName: LPCSTR): Boolean;
begin
  if not Assigned(Call) then
  begin
    case LibHandle of
      0, INVALID_HANDLE_VALUE:   // 0 to be on the safe side
        Call := CallNotImplemented;
    else
      Call := GetProcAddress(LibHandle, ProcName);
      if not Assigned(Call) then
        Call := CallNotImplemented;
    end;
  end;
  Result := Call <> CallNotImplemented;
end;

function JclGetProcAddressResult(var Call: Pointer; LibHandle: HModule; ProcName: LPCSTR): HResult;
begin
  if JclGetProcAddress(Call, LibHandle, ProcName) then
    Result := ERROR_SUCCESS
  else
    Result := ERROR_CALL_NOT_IMPLEMENTED;
end;

function JclGetProcAddressBool(var Call: Pointer; LibHandle: HModule; ProcName: LPCSTR): BOOL;
begin
  Result := JclGetProcAddress(Call, LibHandle, ProcName);
  if Result then
    SetLastError(ERROR_SUCCESS)
  else
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
end;

function JclGetProcAddressInt(var Call: Pointer; LibHandle: HModule; ProcName: LPCSTR): Integer;
begin
  Result := Integer(JclGetProcAddressBool(Call, LibHandle, ProcName));
end;

function JclGetProcAddressNTStatus(var Call: Pointer; LibHandle: HModule; ProcName: LPCSTR): NTSTATUS;
begin
  if JclGetProcAddressBool(Call, LibHandle, ProcName) then
    Result := STATUS_SUCCESS
  else
    Result := STATUS_NOT_IMPLEMENTED;
end;

//--------------------------------------------------------------------------------------------------

var
  _Kernel32Handle: HModule{ = 0};
  // LoadLibrary, need to be released in the finalization section
  _Advapi32Handle: HModule{ = 0};
  _NetApi32Handle: HModule{ = 0};
  _WinSpoolHandle: HModule{ = 0};
  _ImageHlpHandle: HModule{ = 0};
  _RasDlgHandle: HModule{ = 0};
  _NTDllHandle: HModule{ = 0};

function Kernel32Handle: HModule;
begin
  Result := JclGetModuleHandle(_Kernel32Handle, Kernel32);
end;

function Advapi32Handle: HModule;
begin
  Result := JclLoadLibrary(_Advapi32Handle, 'Advapi32.dll');
end;

function NetApi32Handle: HModule;
begin
  Result := JclLoadLibrary(_NetApi32Handle, 'NetApi32.dll');
end;

function WinSpoolHandle: HModule;
begin
  Result := JclLoadLibrary(_WinSpoolHandle, winspl);
end;

function ImageHlpHandle: HModule;
begin
  Result := JclLoadLibrary(_ImageHlpHandle, ImageHlpLib);
end;

function RasDlgHandle: HModule;
begin
  Result := JclLoadLibrary(_RasDlgHandle, 'rasdlg.dll');
end;

function NTDllHandle: HModule;
begin
  Result := JclLoadLibrary(_NTDllHandle, 'ntdll.dll');
end;

//==================================================================================================
// from AclAPI.h
//==================================================================================================

//--------------------------------------------------------------------------------------------------
// Run time dynamic linking
//--------------------------------------------------------------------------------------------------

type
  TFNSetNamedSecurityInfoW = function(pObjectName: LPWSTR;
  ObjectType: SE_OBJECT_TYPE; SecurityInfo: SECURITY_INFORMATION;
  psidOwner, psidGroup: PSID; pDacl, pSacl: PACL): DWORD; stdcall;

var
  _SetNamedSecurityInfoW: TFNSetNamedSecurityInfoW{ = Nil};

function RtdlSetNamedSecurityInfoW(pObjectName: LPWSTR; ObjectType: SE_OBJECT_TYPE;
  SecurityInfo: SECURITY_INFORMATION; psidOwner, psidGroup: PSID;
  pDacl, pSacl: PACL): DWORD;
begin
  Result := JclGetProcAddressResult(@_SetNamedSecurityInfoW, AdvAPI32Handle, 'SetNamedSecurityInfoW');
  if Result = DWORD(ERROR_SUCCESS) then
    Result := _SetNamedSecurityInfoW(pObjectName, ObjectType, SecurityInfo,
      psidOwner, psidGroup, pDacl, pSacl);
end;

//==================================================================================================
// from Nb30.h  Netbios (incorrect/inconvenient declarations in rtl)
//==================================================================================================

//--------------------------------------------------------------------------------------------------
// Run time dynamic linking
//--------------------------------------------------------------------------------------------------

type
  TFNNetBios = function(P: PNCB): UCHAR; stdcall;

var
  _NetBios: TFNNetBios{ = Nil};

//--------------------------------------------------------------------------------------------------

// return NRC_OPENERR, if the function can not be linked
function RtdlNetBios(P: PNCB): UCHAR;
var
  Exists: Boolean;
begin
  Exists := JclGetProcAddress(@_NetBios, NetApi32Handle, 'Netbios');
  if Exists then
    Result := _NetBios(P)
  else
    Result := NRC_OPENERR;
end;

//==================================================================================================
// from WinNls.h
//==================================================================================================

function LANGIDFROMLCID(const lcid: LCID): Word;
begin
  Result := Word(lcid);
end;

//--------------------------------------------------------------------------------------------------

function MAKELANGID(const usPrimaryLanguage, usSubLanguage: Byte): Word;
begin
  Result := usPrimaryLanguage or (usSubLanguage shl 10);
end;

//--------------------------------------------------------------------------------------------------

function PRIMARYLANGID(const lgid: Word): Word;
begin
  Result := (lgid and $03FF);
end;

//--------------------------------------------------------------------------------------------------

function SUBLANGID(const lgid: Word): Word;
begin
  Result := (lgid shr 10);
end;

//--------------------------------------------------------------------------------------------------

function MAKELCID(const wLanguageID, wSortID: Word): LCID;
begin
  Result := wLanguageID or (wSortID shl 16);
end;

//--------------------------------------------------------------------------------------------------

function SORTIDFROMLCID(const lcid: LCID): Word;
begin
  Result := (lcid shr 16) and $0F;
end;

//==================================================================================================
// from WinNls.h
//==================================================================================================

//--------------------------------------------------------------------------------------------------
// Run time dynamic linking
//--------------------------------------------------------------------------------------------------

var
  _GetCalendarInfoA: function(Locale: LCID; Calendar: CALID; CalType: CALTYPE; lpCalData: PAnsiChar;
    cchData: Integer; lpValue: PDWORD): Integer; stdcall;
  _GetCalendarInfoW: function(Locale: LCID; Calendar: CALID; CalType: CALTYPE; lpCalData: PWideChar;
    cchData: Integer; lpValue: PDWORD): Integer; stdcall;
  _SetCalendarInfoA: function(Locale: LCID; Calendar: CALID; CalType: CALTYPE; lpCalData: PAnsiChar): Integer; stdcall;
  _SetCalendarInfoW: function(Locale: LCID; Calendar: CALID; CalType: CALTYPE; lpCalData: PWideChar): Integer; stdcall;
  _EnumCalendarInfoExA: function(lpCalInfoEnumProc: TCalInfoEnumProcExA; Locale: LCID;
    Calendar: CALID; CalType: CALTYPE): BOOL; stdcall;

//--------------------------------------------------------------------------------------------------

function RtdlGetCalendarInfoA(Locale: LCID; Calendar: CALID; CalType: CALTYPE;
  lpCalData: PAnsiChar; cchData: Integer; lpValue: PDWORD): Integer;
begin
  Result := JclGetProcAddressInt(@_GetCalendarInfoA, Kernel32Handle, 'GetCalendarInfoA');
  if Result <> 0 then
    Result := _GetCalendarInfoA(Locale, Calendar, CalType, lpCalData, cchData, lpValue);
end;

//--------------------------------------------------------------------------------------------------

function RtdlGetCalendarInfoW(Locale: LCID; Calendar: CALID; CalType: CALTYPE;
  lpCalData: PWideChar; cchData: Integer; lpValue: PDWORD): Integer;
begin
  Result := JclGetProcAddressInt(@_GetCalendarInfoW, Kernel32Handle, 'GetCalendarInfoW');
  if Result <> 0 then
    Result := _GetCalendarInfoW(Locale, Calendar, CalType, lpCalData, cchData, lpValue);
end;

//--------------------------------------------------------------------------------------------------

function RtdlSetCalendarInfoA(Locale: LCID; Calendar: CALID; CalType: CALTYPE;
  lpCalData: PAnsiChar): Integer;
begin
  Result := JclGetProcAddressInt(@_SetCalendarInfoA, Kernel32Handle, 'SetCalendarInfoA');
  if Result <> 0 then
    Result := _SetCalendarInfoA(Locale, Calendar, CalType, lpCalData);
end;

//--------------------------------------------------------------------------------------------------

function RtdlSetCalendarInfoW(Locale: LCID; Calendar: CALID; CalType: CALTYPE;
  lpCalData: PWideChar): Integer;
begin
  Result := JclGetProcAddressInt(@_SetCalendarInfoW, Kernel32Handle, 'SetCalendarInfoW');
  if Result <> 0 then
    Result := _SetCalendarInfoW(Locale, Calendar, CalType, lpCalData);
end;

//--------------------------------------------------------------------------------------------------

function RtdlEnumCalendarInfoExA(lpCalInfoEnumProc: TCalInfoEnumProcExA;
  Locale: LCID; Calendar: CALID; CalType: CALTYPE): BOOL;
begin
  Result := JclGetProcAddressBool(@_EnumCalendarInfoExA, Kernel32Handle, 'EnumCalendarInfoExA');
  if Result then
    Result := _EnumCalendarInfoExA(lpCalInfoEnumProc, Locale, Calendar, CalType);
end;

//==================================================================================================
// from WinNT.h
//==================================================================================================

//--------------------------------------------------------------------------------------------------
// Image (WinNT.h)
//--------------------------------------------------------------------------------------------------

function IMAGE_ORDINAL64(Ordinal: Word): Word;
begin
  Result := Ordinal;
end;

//--------------------------------------------------------------------------------------------------

function IMAGE_ORDINAL32(Ordinal: Word): Word;
begin
  Result := Ordinal;
end;

//--------------------------------------------------------------------------------------------------

function IMAGE_SNAP_BY_ORDINAL64(Ordinal: UInt64): Boolean;
begin
  Result := Ordinal and IMAGE_ORDINAL_FLAG64 <> 0;
end;

//--------------------------------------------------------------------------------------------------

function IMAGE_SNAP_BY_ORDINAL32(Ordinal: DWord): Boolean;
begin
  Result := Ordinal and IMAGE_ORDINAL_FLAG32 <> 0;
end;

//--------------------------------------------------------------------------------------------------

function IMAGE_ORDINAL(Ordinal: Word): Word;
begin
  Result := Ordinal;
end;

//--------------------------------------------------------------------------------------------------

function IMAGE_SNAP_BY_ORDINAL(Ordinal: DWord): Boolean;
begin
  Result := Ordinal and IMAGE_ORDINAL_FLAG32 <> 0;
end;

//==================================================================================================
// from RasDlg.h
//==================================================================================================

//--------------------------------------------------------------------------------------------------
// Run time dynamic linking
//--------------------------------------------------------------------------------------------------

type
  TFNRasDialDlgA = function(lpszPhonebook, lpszEntry, lpszPhoneNumber: LPSTR;
    lpInfo: LPRASDIALDLG): BOOL; stdcall;

var
  _RasDialDlgA: TFNRasDialDlgA{ = Nil};

function RtdlRasDialDlgA(lpszPhonebook, lpszEntry, lpszPhoneNumber: LPSTR;
  lpInfo: LPRASDIALDLG): BOOL;
begin
  Result := JclGetProcAddressBool(@_RasDialDlgA, RasDlgHandle, 'RasDialDlgA');
  if Result then
    Result := _RasDialDlgA(lpszPhonebook, lpszEntry, lpszPhoneNumber, lpInfo);
end;

//==================================================================================================
// from WinBase.h
//==================================================================================================

function InterlockedExchangePointer(var Target: Pointer; Value: Pointer): Pointer;
begin
  Result := Pointer(InterlockedExchange(LongInt(Target), LongInt(Value)));
end;

//--------------------------------------------------------------------------------------------------
// alternative conversions
//--------------------------------------------------------------------------------------------------

function AdjustTokenPrivileges; external 'Advapi32.dll' name 'AdjustTokenPrivileges';
function GetVersionEx; external kernel32 name 'GetVersionExA';
function CreateMutex; external kernel32 name 'CreateMutexA';
function BackupSeek; external kernel32 name 'BackupSeek';

//--------------------------------------------------------------------------------------------------
// Run time dynamic linking
//--------------------------------------------------------------------------------------------------

type
  TFNGetVolumeNameForVolumeMountPointA = function(lpszVolumeMountPoint: LPCSTR; lpszVolumeName: LPSTR; cchBufferLength: DWORD): BOOL; stdcall;
  TFNSetVolumeMountPointA = function(lpszVolumeMountPoint: LPCSTR; lpszVolumeName: LPCSTR): BOOL; stdcall;
  TFNDeleteVolumeMountPointA = function(lpszVolumeMountPoint: LPCSTR): BOOL; stdcall;
  TFNGetFileAttributesExA = function(lpFileName: PAnsiChar;
    fInfoLevelId: TGetFileExInfoLevels; lpFileInformation: Pointer): BOOL; stdcall;
  TFNMoveFileExA = function(lpExistingFileName, lpNewFileName: PAnsiChar;
    dwFlags: DWORD): BOOL; stdcall;
  TFNCreateHardLinkA = function(lpFileName, lpExistingFileName: LPCSTR;
    lpSecurityAttributes: LPSECURITY_ATTRIBUTES): BOOL; stdcall;
  // WinNT 4 and later, not Win9x
  TFNSignalObjectAndWait = function(hObjectToSignal: THandle;
    hObjectToWaitOn: THandle; dwMilliseconds: DWORD; bAlertable: BOOL): DWORD; stdcall;
  // Win98 and later or WinNT 4.0 SP3 and later
  TFNInitializeCriticalSectionAndSpinCount = function(
    var lpCriticalSection: TRTLCriticalSection; dwSpinCount: DWORD): BOOL; stdcall;
  // WinNT 4.0 SP3 and later, not Win9x
  TFNSetCriticalSectionSpinCount = function(
    var lpCriticalSection: TRTLCriticalSection; dwSpinCount: DWORD): DWORD; stdcall;
  // WinNT 4.0 and later, not Win9x
  TFNTryEnterCriticalSection = function(var lpCriticalSection: TRTLCriticalSection): BOOL; stdcall;
  // Win98 and later or WinNT 4.0 and later
  TFNCancelWaitableTimer = function(hTimer: THandle): BOOL; stdcall;
  // Win98 and later or WinNT 4.0 and later
  TFNCreateWaitableTimerA = function(lpTimerAttributes: PSecurityAttributes;
    bManualReset: BOOL; lpTimerName: PAnsiChar): THandle; stdcall;
  // Win98 and later or WinNT 4.0 and later
  TFNOpenWaitableTimerA = function(dwDesiredAccess: DWORD; bInheritHandle: BOOL;
    lpTimerName: PAnsiChar): THandle; stdcall;
  // Win98 and later or WinNT 4.0 and later
  TFNSetWaitableTimer = function(hTimer: THandle; var lpDueTime: TLargeInteger;
    lPeriod: Longint; pfnCompletionRoutine: TFNTimerAPCRoutine;
    lpArgToCompletionRoutine: Pointer; fResume: BOOL): BOOL; stdcall;

var
  _GetVolumeNameForVolumeMountPointA: TFNGetVolumeNameForVolumeMountPointA{ = Nil};
  _SetVolumeMountPointA: TFNSetVolumeMountPointA{ = Nil};
  _DeleteVolumeMountPointA: TFNDeleteVolumeMountPointA{ = Nil};
  _GetFileAttributesExA: TFNGetFileAttributesExA{ = Nil};
  _MoveFileExA: TFNMoveFileExA{ = Nil};
  _CreateHardLinkA: TFNCreateHardLinkA{ = Nil};
  _SignalObjectAndWait: TFNSignalObjectAndWait{ = Nil};
  _InitializeCriticalSectionAndSpinCount: TFNInitializeCriticalSectionAndSpinCount{ = Nil};
  _SetCriticalSectionSpinCount: TFNSetCriticalSectionSpinCount{ = Nil};
  _TryEnterCriticalSection: TFNTryEnterCriticalSection{ = Nil};
  _CancelWaitableTimer: TFNCancelWaitableTimer{ = Nil};
  _CreateWaitableTimerA: TFNCreateWaitableTimerA{ = Nil};
  _OpenWaitableTimerA: TFNOpenWaitableTimerA{ = Nil};
  _SetWaitableTimer: TFNSetWaitableTimer{ = Nil};

//--------------------------------------------------------------------------------------------------

function RtdlGetVolumeNameForVolumeMountPoint(lpszVolumeMountPoint: LPCSTR;
  lpszVolumeName: LPSTR; cchBufferLength: DWORD): BOOL;
begin
  Result := JclGetProcAddressBool(@_GetVolumeNameForVolumeMountPointA,
    Kernel32Handle, 'GetVolumeNameForVolumeMountPointA');
  if Result then
    Result := _GetVolumeNameForVolumeMountPointA(lpszVolumeMountPoint,
      lpszVolumeName, cchBufferLength);
end;

//--------------------------------------------------------------------------------------------------

function RtdlSetVolumeMountPoint(lpszVolumeMountPoint: LPCSTR; lpszVolumeName: LPCSTR): BOOL;
begin
  Result := JclGetProcAddressBool(@_SetVolumeMountPointA, Kernel32Handle, 'SetVolumeMountPointA');
  if Result then
    Result := _SetVolumeMountPointA(lpszVolumeMountPoint, lpszVolumeName);
end;

//--------------------------------------------------------------------------------------------------

function RtdlDeleteVolumeMountPoint(lpszVolumeMountPoint: LPCSTR): BOOL;
begin
  Result := JclGetProcAddressBool(@_DeleteVolumeMountPointA, Kernel32Handle, 'DeleteVolumeMountPointA');
  if Result then
    Result := _DeleteVolumeMountPointA(lpszVolumeMountPoint);
end;

//--------------------------------------------------------------------------------------------------

function RtdlGetFileAttributesEx(lpFileName: PChar; fInfoLevelId: TGetFileExInfoLevels;
  lpFileInformation: Pointer): BOOL;
begin
  Result := JclGetProcAddressBool(@_GetFileAttributesExA, Kernel32Handle, 'GetFileAttributesExA');
  if Result then
    Result := _GetFileAttributesExA(lpFileName, fInfoLevelId, lpFileInformation);
end;

//--------------------------------------------------------------------------------------------------

function RtdlMoveFileEx(lpExistingFileName, lpNewFileName: PChar; dwFlags: DWORD): BOOL;
begin
  Result := JclGetProcAddressBool(@_MoveFileExA, Kernel32Handle, 'MoveFileExA');
  if Result then
    Result := _MoveFileExA(lpExistingFileName, lpNewFileName, dwFlags);
end;

//--------------------------------------------------------------------------------------------------

function RtdlCreateHardLink(lpFileName, lpExistingFileName: LPCSTR;
  lpSecurityAttributes: LPSECURITY_ATTRIBUTES): BOOL;
begin
  Result := JclGetProcAddressBool(@_CreateHardLinkA, Kernel32Handle, 'CreateHardLinkA');
  if Result then
    Result := _CreateHardLinkA(lpFileName, lpExistingFileName, lpSecurityAttributes);
end;

//--------------------------------------------------------------------------------------------------

// WinNT 4 and later, not Win9x
function RtdlSignalObjectAndWait(hObjectToSignal: THandle; hObjectToWaitOn: THandle;
  dwMilliseconds: DWORD; bAlertable: BOOL): DWORD; stdcall;
begin
  if JclGetProcAddressBool(@_SignalObjectAndWait, Kernel32Handle, 'SignalObjectAndWait') then
    Result := _SignalObjectAndWait(hObjectToSignal, hObjectToWaitOn,
      dwMilliseconds, bAlertable)
  else
    Result := WAIT_FAILED;
end;

//--------------------------------------------------------------------------------------------------

// Win98 and later or WinNT 4.0 SP3 and later
function RtdlInitializeCriticalSectionAndSpinCount(
  var lpCriticalSection: TRTLCriticalSection; dwSpinCount: DWORD): BOOL; stdcall;
begin
  Result := JclGetProcAddressBool(@_InitializeCriticalSectionAndSpinCount, Kernel32Handle, 'InitializeCriticalSectionAndSpinCount');
  if Result then
    Result := _InitializeCriticalSectionAndSpinCount(lpCriticalSection, dwSpinCount);
end;

//--------------------------------------------------------------------------------------------------

// WinNT 4.0 SP3 and later, not Win9x
// Use GetLastError to detect, whether SetCriticalSectionSpinCount exist
function RtdlSetCriticalSectionSpinCount(
  var lpCriticalSection: TRTLCriticalSection; dwSpinCount: DWORD): DWORD; stdcall;
begin
  if JclGetProcAddressBool(@_SetCriticalSectionSpinCount, Kernel32Handle, 'SetCriticalSectionSpinCount') then
    Result := _SetCriticalSectionSpinCount(lpCriticalSection, dwSpinCount)
  else
    Result := 0;
end;

//--------------------------------------------------------------------------------------------------

// WinNT 4.0 and later, not Win9x
// Use GetLastError to detect, whether SetCriticalSectionSpinCount exist
function RtdlTryEnterCriticalSection(
  var lpCriticalSection: TRTLCriticalSection): BOOL; stdcall;
begin
  Result := JclGetProcAddressBool(@_TryEnterCriticalSection, Kernel32Handle, 'TryEnterCriticalSection');
  if Result then
    Result := _TryEnterCriticalSection(lpCriticalSection);
end;

//--------------------------------------------------------------------------------------------------

// Win98 and later or WinNT 4.0 and later
function RtdlCancelWaitableTimer(hTimer: THandle): BOOL; stdcall;
begin
  Result := JclGetProcAddressBool(@_CancelWaitableTimer, Kernel32Handle, 'CancelWaitableTimer');
  if Result then
    Result := _CancelWaitableTimer(hTimer);
end;

//--------------------------------------------------------------------------------------------------

// Win98 and later or WinNT 4.0 and later
function RtdlCreateWaitableTimer(lpTimerAttributes: PSecurityAttributes;
  bManualReset: BOOL; lpTimerName: PChar): THandle; stdcall;
begin
  if JclGetProcAddressBool(@_CreateWaitableTimerA, Kernel32Handle, 'CreateWaitableTimerA') then
    Result := _CreateWaitableTimerA(lpTimerAttributes, bManualReset, lpTimerName)
  else
    Result := 0;
end;

//--------------------------------------------------------------------------------------------------

// Win98 and later or WinNT 4.0 and later
function RtdlOpenWaitableTimer(dwDesiredAccess: DWORD; bInheritHandle: BOOL;
  lpTimerName: PChar): THandle; stdcall;
begin
  if JclGetProcAddressBool(@_OpenWaitableTimerA, Kernel32Handle, 'OpenWaitableTimerA') then
    Result := _OpenWaitableTimerA(dwDesiredAccess, bInheritHandle, lpTimerName)
  else
    Result := 0;
end;

//--------------------------------------------------------------------------------------------------

// Win98 and later or WinNT 4.0 and later
function RtdlSetWaitableTimer(hTimer: THandle; var lpDueTime: TLargeInteger;
  lPeriod: Longint; pfnCompletionRoutine: TFNTimerAPCRoutine;
  lpArgToCompletionRoutine: Pointer; fResume: BOOL): BOOL; stdcall;
begin
  Result := JclGetProcAddressBool(@_SetWaitableTimer, Kernel32Handle, 'SetWaitableTimer');
  if Result then
    Result := _SetWaitableTimer(hTimer, lpDueTime, lPeriod, pfnCompletionRoutine,
      lpArgToCompletionRoutine, fResume);
end;

//==================================================================================================
// from LMaccess.h
//==================================================================================================

//--------------------------------------------------------------------------------------------------
// Run time dynamic linking
//--------------------------------------------------------------------------------------------------

type
  TFNNetUserAdd = function({optional} servername: LPCWSTR; level: DWORD;
    buf: PByte; {out optional} parm_err: PDWord): NET_API_STATUS; stdcall;
  TFNNetUserDel = function({optional} servername: LPCWSTR;
    username: LPCWSTR): NET_API_STATUS; stdcall;
  TFNNetGroupAdd = function({optional} servername: LPCWSTR; level: DWORD;
    buf: PByte; {out optional} parm_err: PDWord): NET_API_STATUS; stdcall;
  TFNNetGroupEnum = function({optional} servername: LPCWSTR; level: DWORD;
    out bufptr: PByte; prefmaxlen: DWORD; out entriesread, totalentries: DWORD;
    {in out optional} resume_handle: PDWORD_PTR): NET_API_STATUS; stdcall;
  TFNNetGroupDel = function({optional} servername: LPCWSTR;
    groupname: LPCWSTR): NET_API_STATUS; stdcall;
  TFNNetLocalGroupAdd = function({optional} servername: LPCWSTR; level: DWORD;
    buf: PByte; {out optional} parm_err: PDWord): NET_API_STATUS; stdcall;
  TFNNetLocalGroupEnum = function({optional} servername: LPCWSTR; level: DWORD;
    out bufptr: PByte; prefmaxlen: DWORD; out entriesread, totalentries: DWORD;
    {in out optional} resumehandle: PDWORD_PTR): NET_API_STATUS; stdcall;
  TFNNetLocalGroupDel = function({optional} servername: LPCWSTR; 
    groupname: LPCWSTR): NET_API_STATUS; stdcall;
  TFNNetLocalGroupAddMembers = function({optional} servername: LPCWSTR;
    groupname: LPCWSTR; level: DWORD; buf: PByte;
    totalentries: DWORD): NET_API_STATUS; stdcall;

var
  _NetUserAdd: TFNNetUserAdd{ = Nil};
  _NetUserDel: TFNNetUserDel{ = Nil};
  _NetGroupAdd: TFNNetGroupAdd{ = Nil};
  _NetGroupEnum: TFNNetGroupEnum{ = Nil};
  _NetGroupDel: TFNNetGroupDel{ = Nil};
  _NetLocalGroupAdd: TFNNetLocalGroupAdd{ = Nil};
  _NetLocalGroupEnum: TFNNetLocalGroupEnum{ = Nil};
  _NetLocalGroupDel: TFNNetLocalGroupDel{ = Nil};
  _NetLocalGroupAddMembers: TFNNetLocalGroupAddMembers{ = Nil};

//--------------------------------------------------------------------------------------------------

function RtdlNetUserAdd({optional} servername: LPCWSTR; level: DWORD;
  buf: PByte; {out optional} parm_err: PDWord): NET_API_STATUS;
begin
  Result := JclGetProcAddressResult(@_NetUserAdd, NetApi32Handle, 'NetUserAdd');
  if Result = NET_API_STATUS(ERROR_SUCCESS) then
    Result := _NetUserAdd(servername, level, buf, parm_err);
end;

//--------------------------------------------------------------------------------------------------

function RtdlNetUserDel({optional} servername: LPCWSTR; username: LPCWSTR): NET_API_STATUS;
begin
  Result := JclGetProcAddressResult(@_NetUserDel, NetApi32Handle, 'NetUserDel');
  if Result = NET_API_STATUS(ERROR_SUCCESS) then
    Result := _NetUserDel(servername, username);
end;

//--------------------------------------------------------------------------------------------------

function RtdlNetGroupAdd({optional} servername: LPCWSTR; level: DWORD; buf: PByte;
  {out optional} parm_err: PDWord): NET_API_STATUS;
begin
  Result := JclGetProcAddressResult(@_NetGroupAdd, NetApi32Handle, 'NetGroupAdd');
  if Result = NET_API_STATUS(ERROR_SUCCESS) then
    Result := _NetGroupAdd(servername, level, buf, parm_err);
end;

//--------------------------------------------------------------------------------------------------

function RtdlNetGroupEnum({optional} servername: LPCWSTR; level: DWORD;
  out bufptr: PByte; prefmaxlen: DWORD; out entriesread, totalentries: DWORD;
  {in out optional} resume_handle: PDWORD_PTR): NET_API_STATUS;
begin
  Result := JclGetProcAddressResult(@_NetGroupEnum, NetApi32Handle, 'NetGroupEnum');
  if Result = NET_API_STATUS(ERROR_SUCCESS) then
    Result := _NetGroupEnum(servername, level, bufptr, prefmaxlen, entriesread,
      totalentries, resume_handle);
end;

//--------------------------------------------------------------------------------------------------

function RtdlNetGroupDel({optional} servername: LPCWSTR; groupname: LPCWSTR): NET_API_STATUS;
begin
  Result := JclGetProcAddressResult(@_NetGroupDel, NetApi32Handle, 'NetGroupDel');
  if Result = NET_API_STATUS(ERROR_SUCCESS) then
    Result := _NetGroupDel(servername, groupname);
end;

//--------------------------------------------------------------------------------------------------

function RtdlNetLocalGroupAdd({optional} servername: LPCWSTR; level: DWORD;
  buf: PByte; {out optional} parm_err: PDWord): NET_API_STATUS;
begin
  Result := JclGetProcAddressResult(@_NetLocalGroupAdd, NetApi32Handle, 'NetLocalGroupAdd');
  if Result = NET_API_STATUS(ERROR_SUCCESS) then
    Result := _NetLocalGroupAdd(servername, level, buf, parm_err);
end;

//--------------------------------------------------------------------------------------------------

function RtdlNetLocalGroupEnum({optional} servername: LPCWSTR; level: DWORD;
  out bufptr: PByte; prefmaxlen: DWORD; out entriesread, totalentries: DWORD;
  {in out optional} resumehandle: PDWORD_PTR): NET_API_STATUS;
begin
  Result := JclGetProcAddressResult(@_NetLocalGroupEnum, NetApi32Handle, 'NetLocalGroupEnum');
  if Result = NET_API_STATUS(ERROR_SUCCESS) then
    Result := _NetLocalGroupEnum(servername, level, bufptr, prefmaxlen,
      entriesread, totalentries, resumehandle);
end;

//--------------------------------------------------------------------------------------------------

function RtdlNetLocalGroupDel({optional} servername: LPCWSTR; groupname: LPCWSTR): NET_API_STATUS;
begin
  Result := JclGetProcAddressResult(@_NetLocalGroupDel, NetApi32Handle, 'NetLocalGroupDel');
  if Result = NET_API_STATUS(ERROR_SUCCESS) then
    Result := _NetLocalGroupDel(servername, groupname);
end;

//--------------------------------------------------------------------------------------------------

function RtdlNetLocalGroupAddMembers({optional} servername: LPCWSTR; groupname: LPCWSTR;
  level: DWORD; buf: PByte; totalentries: DWORD): NET_API_STATUS;
begin
  Result := JclGetProcAddressResult(@_NetLocalGroupAddMembers, NetApi32Handle, 'NetLocalGroupAddMembers');
  if Result = NET_API_STATUS(ERROR_SUCCESS) then
    Result := _NetLocalGroupAddMembers(servername, groupname, level, buf, totalentries);
end;

//==================================================================================================
// from LMAPIbuf.h
//==================================================================================================

//--------------------------------------------------------------------------------------------------
// Run time dynamic linking
//--------------------------------------------------------------------------------------------------

type
  TFNNetApiBufferFree = function(Buffer: Pointer): NET_API_STATUS; stdcall;

var
  _NetApiBufferFree: TFNNetApiBufferFree{ = Nil};

//--------------------------------------------------------------------------------------------------

function RtdlNetApiBufferFree(Buffer: Pointer): NET_API_STATUS;
begin
  Result := JclGetProcAddressResult(@_NetApiBufferFree, NetApi32Handle, 'NetApiBufferFree');
  if Result = NET_API_STATUS(ERROR_SUCCESS) then
    Result := _NetApiBufferFree(Buffer);
end;

//==================================================================================================
// from ImageHlp.h
//==================================================================================================

function CheckSumMappedFile; external ImageHlpLib name 'CheckSumMappedFile';
function MapAndLoad; external ImageHlpLib name 'MapAndLoad';
function UnMapAndLoad; external ImageHlpLib name 'UnMapAndLoad';
function ImageDirectoryEntryToData; external ImageHlpLib name 'ImageDirectoryEntryToData';
function GetImageUnusedHeaderBytes; external ImageHlpLib name 'GetImageUnusedHeaderBytes';
function ImageRvaToSection; external ImageHlpLib name 'ImageRvaToSection';
function ReBaseImage; external ImageHlpLib name 'ReBaseImage';
function UnDecorateSymbolName; external ImageHlpLib name 'UnDecorateSymbolName';

//--------------------------------------------------------------------------------------------------
// alternative conversions
//--------------------------------------------------------------------------------------------------

{ TODO : don't used in the JCL }

{$IFNDEF FPC}
function BindImageEx; external ImageHlpLib name 'BindImageEx';
{$ENDIF ~FPC}

function ImageEnumerateCertificates; external ImageHlpLib name 'ImageEnumerateCertificates';

//--------------------------------------------------------------------------------------------------
// Run time dynamic linking
//--------------------------------------------------------------------------------------------------

type
  TFNImageRvaToVa = function(NtHeaders: PImageNtHeaders; Base: Pointer;
    Rva: ULONG; LastRvaSection: PPImageSectionHeader): Pointer; stdcall;

var
  _ImageRvaToVa: TFNImageRvaToVa{ = Nil};

//--------------------------------------------------------------------------------------------------

function RtdlImageRvaToVa(NtHeaders: PImageNtHeaders; Base: Pointer;
  Rva: ULONG; LastRvaSection: PPImageSectionHeader): Pointer;
begin
  if JclGetProcAddressBool(@_ImageRvaToVa, ImageHlpHandle, 'ImageRvaToVa') then
    Result := _ImageRvaToVa(NtHeaders, Base, Rva, LastRvaSection)
  else
    Result := Nil;
end;

//==================================================================================================
// from WinSpool.h
//==================================================================================================

type
  TFNSetDefaultPrinterA = function(pszPrinter: LPCSTR): BOOL; stdcall;

var
  _SetDefaultPrinterA: TFNSetDefaultPrinterA{ = Nil};

//--------------------------------------------------------------------------------------------------

function RtdlSetDefaultPrinter(pszPrinter: LPCSTR): BOOL;
begin
  Result := JclGetProcAddressBool(@_SetDefaultPrinterA, WinSpoolHandle, 'SetDefaultPrinterA');
  if Result then
    Result := _SetDefaultPrinterA(pszPrinter);
end;

//==================================================================================================
// from Native API
//==================================================================================================

type
  TFNNtQueryEvent = function(EventHandle: THandle;
    EventInformationClass: EVENT_INFORMATION_CLASS; {out} EventInformation: Pointer;
    EventInformationLength: ULONG; {out, optional} ResultLength: PULONG): NTSTATUS; stdcall;
  TFNNtQueryMutant = function(MutantHandle: THandle;
    MutantInformationClass: MUTANT_INFORMATION_CLASS; {out} MutantInformation: Pointer;
    MutantInformationLength: ULONG; {out, optional} ResultLength: PULONG): NTSTATUS; stdcall;
  TFNNtQuerySemaphore = function(SemaphoreHandle: THandle;
    SemaphoreInformationClass: SEMAPHORE_INFORMATION_CLASS;
    SemaphoreInformation: Pointer; SemaphoreInformationLength: ULONG;
    ResultLength: PULONG): NTSTATUS; stdcall;
  TFNNtQueryTimer = function(TimerHandle: THandle;
    TimerInformationClass: TIMER_INFORMATION_CLASS; {out} TimerInformation: Pointer;
    TimerInformationLength: ULONG; {out, optional} ResultLength: PULONG): NTSTATUS; stdcall;

var
  _NtQueryEvent: TFNNtQueryEvent{ = Nil};
  _NtQueryMutant: TFNNtQueryMutant{ = Nil};
  _NtQuerySemaphore: TFNNtQuerySemaphore{ = Nil};
  _NtQueryTimer: TFNNtQueryTimer{ = Nil};

//--------------------------------------------------------------------------------------------------

function RtdlNtQueryEvent(EventHandle: THandle;
  EventInformationClass: EVENT_INFORMATION_CLASS; {out} EventInformation: Pointer;
  EventInformationLength: ULONG; {out, optional} ResultLength: PULONG): NTSTATUS; stdcall;
begin
  Result := JclGetProcAddressNTStatus(@_NtQueryEvent, NTDllHandle, 'NtQueryEvent');
  if Result = STATUS_SUCCESS then
    _NtQueryEvent(EventHandle, EventInformationClass, EventInformation,
      EventInformationLength, ResultLength);
end;

function RtdlNtQueryMutant(MutantHandle: THandle;
  MutantInformationClass: MUTANT_INFORMATION_CLASS; {out} MutantInformation: Pointer;
  MutantInformationLength: ULONG; {out, optional} ResultLength: PULONG): NTSTATUS; stdcall;
begin
  Result := JclGetProcAddressNTStatus(@_NtQueryMutant, NTDllHandle, 'NtQueryMutant');
  if Result = STATUS_SUCCESS then
    _NtQueryMutant(MutantHandle, MutantInformationClass, MutantInformation,
      MutantInformationLength, ResultLength);
end;

function RtdlNtQuerySemaphore(SemaphoreHandle: THandle;
  SemaphoreInformationClass: SEMAPHORE_INFORMATION_CLASS;
  SemaphoreInformation: Pointer; SemaphoreInformationLength: ULONG;
  ResultLength: PULONG): NTSTATUS; stdcall;
begin
  Result := JclGetProcAddressNTStatus(@_NtQuerySemaphore, NTDllHandle, 'NtQuerySemaphore');
  if Result = STATUS_SUCCESS then
    _NtQuerySemaphore(SemaphoreHandle, SemaphoreInformationClass, SemaphoreInformation,
      SemaphoreInformationLength, ResultLength);
end;

function RtdlNtQueryTimer(TimerHandle: THandle;
  TimerInformationClass: TIMER_INFORMATION_CLASS; {out} TimerInformation: Pointer;
  TimerInformationLength: ULONG; {out, optional} ResultLength: PULONG): NTSTATUS; stdcall;
begin
  Result := JclGetProcAddressNTStatus(@_NtQueryTimer, NTDllHandle, 'NtQueryTimer');
  if Result = STATUS_SUCCESS then
    _NtQueryTimer(TimerHandle, TimerInformationClass, TimerInformation,
      TimerInformationLength, ResultLength);
end;

//==================================================================================================
// Helper functions
//==================================================================================================

function InitNetbios: Boolean; // obsolete
begin
  Assert(False, 'Please remove the InitNetbios call');
  Result := JclGetProcAddress(@_NetBios, NetApi32Handle, 'Netbios');
end;

//--------------------------------------------------------------------------------------------------

procedure ExitNetbios; // do nothing, obsolete
begin
  Assert(False, 'Please remove the ExitNetbios call');
end;

//==================================================================================================

initialization
  Assert(SizeOf(ULONG_PTR) = SizeOf(Pointer));
finalization
  JclFreeLibrary(_Advapi32Handle);
  JclFreeLibrary(_NetApi32Handle);
  JclFreeLibrary(_WinSpoolHandle);
  JclFreeLibrary(_ImageHlpHandle);
  JclFreeLibrary(_RasDlgHandle);
  JclFreeLibrary(_NTDllHandle);

// History:

// $Log$
// Revision 1.11  2004/04/06 22:41:26  peterjhaas
// Bugfix the in Delphi missing pointer declarations for BCB
//
// Revision 1.10  2004/04/06 17:13:03  peterjhaas
// Delete overload statements to solve the linker problem
//
// Revision 1.9  2004/04/06 04:19:47  peterjhaas
// Complete redesign, add all needed Win32 declarations from other units and run time dynamic linking for platform dependent functions
//

end.
