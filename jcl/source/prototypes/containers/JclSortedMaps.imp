(*$JPPDEFINEMACRO JCLSORTEDMAPINT(KEYTYPENAME, VALUETYPENAME, ENTRYTYPENAME, ENTRYARRAYTYPENAME,
  SELFCLASSNAME, ANCESTORNAME, STDMAPINTERFACENAME, SORTEDMAPINTERFACENAME, KEYSETINTERFACENAME, VALUECOLLECTIONINTERFACENAME,
  INTERFACEADDITIONAL, PRIVATEADDITIONAL, PROTECTEDADDITIONAL, PUBLICADDITIONAL, KEYOWNERSHIPDECLARATION, VALUEOWNERSHIPDECLARATION,
  KEYPARAMETERDECLARATION, VALUEPARAMETERDECLARATION, HEADMAPPARAMETERDECLARATION, SUBMAPPARAMETERDECLARATION, TAILMAPPARAMETERDECLARATION)
  ENTRYTYPENAME = record
    Key: KEYTYPENAME;
    Value: VALUETYPENAME;
  end;

  ENTRYARRAYTYPENAME = array of ENTRYTYPENAME;

  SELFCLASSNAME = class(ANCESTORNAME, {$IFDEF THREADSAFE} IJclLockable, {$ENDIF THREADSAFE}
    IJclIntfCloneable, IJclCloneable, IJclGrowable, IJclPackable, IJclContainer,INTERFACEADDITIONAL
    STDMAPINTERFACENAME, SORTEDMAPINTERFACENAME)
  private
    FEntries: ENTRYARRAYTYPENAME;PRIVATEADDITIONAL
    function BinarySearch(KEYPARAMETERDECLARATION): Integer;
  protected
    procedure AssignDataTo(Dest: TJclAbstractContainerBase); override;
    procedure MoveArray(FromIndex, ToIndex, Count: Integer);
    { IJclPackable }
    procedure SetCapacity(Value: Integer); override;
    { STDMAPINTERFACENAME }
    procedure Clear;
    function ContainsKey(KEYPARAMETERDECLARATION): Boolean;
    function ContainsValue(VALUEPARAMETERDECLARATION): Boolean;
    function Equals(const AMap: STDMAPINTERFACENAME): Boolean;
    function GetValue(KEYPARAMETERDECLARATION): VALUETYPENAME;
    function IsEmpty: Boolean;
    function KeyOfValue(VALUEPARAMETERDECLARATION): KEYTYPENAME;
    function KeySet: KEYSETINTERFACENAME;
    procedure PutAll(const AMap: STDMAPINTERFACENAME);
    procedure PutValue(KEYPARAMETERDECLARATION; VALUEPARAMETERDECLARATION);
    function Remove(KEYPARAMETERDECLARATION): VALUETYPENAME;
    function Size: Integer;
    function Values: VALUECOLLECTIONINTERFACENAME;
    { SORTEDMAPINTERFACENAME }
    function FirstKey: KEYTYPENAME;
    function HeadMap(HEADMAPPARAMETERDECLARATION): SORTEDMAPINTERFACENAME;
    function LastKey: KEYTYPENAME;
    function SubMap(SUBMAPPARAMETERDECLARATION): SORTEDMAPINTERFACENAME;
    function TailMap(TAILMAPPARAMETERDECLARATION): SORTEDMAPINTERFACENAME;
    { IJclIntfCloneable }
    function IJclIntfCloneable.Clone = IntfClone;PROTECTEDADDITIONAL
  public
    constructor Create(ACapacity: IntegerVALUEOWNERSHIPDECLARATIONKEYOWNERSHIPDECLARATION);
    destructor Destroy; override;PUBLICADDITIONAL
  end;*)
(*$JPPDEFINEMACRO JCLSORTEDMAPIMP(SELFCLASSNAME, ENTRYARRAYTYPENAME,
  STDMAPINTERFACENAME, SORTEDMAPINTERFACENAME, KEYSETINTERFACENAME, KEYITRINTERFACENAME, VALUECOLLECTIONINTERFACENAME,
  KEYOWNERSHIPDECLARATION, VALUEOWNERSHIPDECLARATION, OWNERSHIPASSIGNMENTS,
  KEYPARAMETERDECLARATION, KEYTYPENAME, KEYDEFAULT, VALUEPARAMETERDECLARATION, VALUETYPENAME, VALUEDEFAULT,
  HEADMAPPARAMETERDECLARATION, SUBMAPPARAMETERDECLARATION, TAILMAPPARAMETERDECLARATION)
//=== { SELFCLASSNAME } ==============================================

constructor SELFCLASSNAME.Create(ACapacity: IntegerVALUEOWNERSHIPDECLARATIONKEYOWNERSHIPDECLARATION);
begin
  inherited Create(nil);OWNERSHIPASSIGNMENTS
  SetCapacity(ACapacity);
end;

destructor SELFCLASSNAME.Destroy;
begin
  Clear;
  inherited Destroy;
end;

procedure SELFCLASSNAME.AssignDataTo(Dest: TJclAbstractContainerBase);
var
  MyDest: SELFCLASSNAME;
begin
  inherited AssignDataTo(Dest);
  if Dest is SELFCLASSNAME then
  begin
    MyDest := SELFCLASSNAME(Dest);
    MyDest.SetCapacity(FSize);
    MyDest.FEntries := FEntries;
    MyDest.FSize := FSize;
  end;
end;

function SELFCLASSNAME.BinarySearch(KEYPARAMETERDECLARATION): Integer;
var
  HiPos, LoPos, CompPos: Integer;
  Comp: Integer;
begin
  {$IFDEF THREADSAFE}
  ReadLock;
  try
  {$ENDIF THREADSAFE}
    LoPos := 0;
    HiPos := FSize - 1;
    CompPos := (HiPos + LoPos) div 2;
    while HiPos >= LoPos do
    begin
      Comp := KeysCompare(FEntries[CompPos].Key, Key);
      if Comp < 0 then
        LoPos := CompPos + 1
      else
      if Comp > 0 then
        HiPos := CompPos - 1
      else
      begin
        HiPos := CompPos;
        LoPos := CompPos + 1;
      end;
      CompPos := (HiPos + LoPos) div 2;
    end;
    Result := HiPos;
  {$IFDEF THREADSAFE}
  finally
    ReadUnlock;
  end;
  {$ENDIF THREADSAFE}
end;

procedure SELFCLASSNAME.Clear;
var
  Index: Integer;
begin
  {$IFDEF THREADSAFE}
  WriteLock;
  try
  {$ENDIF THREADSAFE}
    for Index := 0 to FSize - 1 do
    begin
      FreeKey(FEntries[Index].Key);
      FreeValue(FEntries[Index].Value);
    end;
    FSize := 0;
    AutoPack;
  {$IFDEF THREADSAFE}
  finally
    WriteUnlock;
  end;
  {$ENDIF THREADSAFE}
end;

function SELFCLASSNAME.ContainsKey(KEYPARAMETERDECLARATION): Boolean;
var
  Index: Integer;
begin
  {$IFDEF THREADSAFE}
  ReadLock;
  try
  {$ENDIF THREADSAFE}
    Index := BinarySearch(Key);
    Result := (Index >= 0) and (KeysCompare(FEntries[Index].Key, Key) = 0);
  {$IFDEF THREADSAFE}
  finally
    ReadUnlock;
  end;
  {$ENDIF THREADSAFE}
end;

function SELFCLASSNAME.ContainsValue(VALUEPARAMETERDECLARATION): Boolean;
var
  Index: Integer;
begin
  {$IFDEF THREADSAFE}
  ReadLock;
  try
  {$ENDIF THREADSAFE}
    Result := False;
    for Index := 0 to FSize - 1 do
      if ValuesCompare(FEntries[Index].Value, Value) = 0 then
    begin
      Result := True;
      Break;
    end;
  {$IFDEF THREADSAFE}
  finally
    ReadUnlock;
  end;
  {$ENDIF THREADSAFE}
end;

{$JPPEXPANDMACRO CREATEEMPTYCONTAINER}
function SELFCLASSNAME.Equals(const AMap: STDMAPINTERFACENAME): Boolean;
var
  It: KEYITRINTERFACENAME;
  Index: Integer;
  AKey: KEYTYPENAME;
begin
  {$IFDEF THREADSAFE}
  ReadLock;
  try
  {$ENDIF THREADSAFE}
    Result := False;
    if AMap = nil then
      Exit;
    if FSize <> AMap.Size then
      Exit;
    It := AMap.KeySet.First;
    Index := 0;
    while It.HasNext do
    begin
      if Index >= FSize then
        Exit;
      AKey := It.Next;
      if ValuesCompare(AMap.GetValue(AKey), FEntries[Index].Value) <> 0 then
        Exit;
      Inc(Index);
    end;
    Result := True;
  {$IFDEF THREADSAFE}
  finally
    ReadUnlock;
  end;
  {$ENDIF THREADSAFE}
end;

function SELFCLASSNAME.FirstKey: KEYTYPENAME;
begin
  {$IFDEF THREADSAFE}
  ReadLock;
  try
  {$ENDIF THREADSAFE}
    Result := KEYDEFAULT;
    if FSize > 0 then
      Result := FEntries[0].Key
    else
    if not FReturnDefaultElements then
      raise EJclNoSuchElementError.Create('');
  {$IFDEF THREADSAFE}
  finally
    ReadUnlock;
  end;
  {$ENDIF THREADSAFE}
end;

{$JPPEXPANDMACRO FREEKEY}
{$JPPEXPANDMACRO FREEVALUE}
{$JPPEXPANDMACRO GETOWNSKEYS}
{$JPPEXPANDMACRO GETOWNSVALUES}
function SELFCLASSNAME.GetValue(KEYPARAMETERDECLARATION): VALUETYPENAME;
var
  Index: Integer;
begin
  {$IFDEF THREADSAFE}
  ReadLock;
  try
  {$ENDIF THREADSAFE}
    Index := BinarySearch(Key);
    Result := VALUEDEFAULT;
    if (Index >= 0) and (KeysCompare(FEntries[Index].Key, Key) = 0) then
      Result := FEntries[Index].Value
    else if not FReturnDefaultElements then
      raise EJclNoSuchElementError.Create('');
  {$IFDEF THREADSAFE}
  finally
    ReadUnlock;
  end;
  {$ENDIF THREADSAFE}
end;

function SELFCLASSNAME.HeadMap(HEADMAPPARAMETERDECLARATION): SORTEDMAPINTERFACENAME;
var
  ToIndex: Integer;
  NewMap: SELFCLASSNAME;
begin
  {$IFDEF THREADSAFE}
  ReadLock;
  try
  {$ENDIF THREADSAFE}
    NewMap := CreateEmptyContainer as SELFCLASSNAME;
    ToIndex := BinarySearch(ToKey);
    if ToIndex >= 0 then
    begin
      NewMap.SetCapacity(ToIndex + 1);
      NewMap.FEntries := Copy(FEntries, 0, ToIndex + 1);
      NewMap.FSize := ToIndex + 1;
    end;
    Result := NewMap;
  {$IFDEF THREADSAFE}
  finally
    ReadUnlock;
  end;
  {$ENDIF THREADSAFE}
end;

function SELFCLASSNAME.IsEmpty: Boolean;
begin
  {$IFDEF THREADSAFE}
  ReadLock;
  try
  {$ENDIF THREADSAFE}
    Result := FSize = 0;
  {$IFDEF THREADSAFE}
  finally
    ReadUnlock;
  end;
  {$ENDIF THREADSAFE}
end;

function SELFCLASSNAME.KeyOfValue(VALUEPARAMETERDECLARATION): KEYTYPENAME;
var
  Index: Integer;
  Found: Boolean;
begin
  {$IFDEF THREADSAFE}
  ReadLock;
  try
  {$ENDIF THREADSAFE}
    Found := False;
    Result := KEYDEFAULT;
    for Index := 0 to FSize - 1 do
      if ValuesCompare(FEntries[Index].Value, Value) = 0 then
    begin
      Result := FEntries[Index].Key;
      Found := True;
      Break;
    end;

    if (not Found) and (not FReturnDefaultElements) then
      raise EJclNoSuchElementError.Create('');
  {$IFDEF THREADSAFE}
  finally
    ReadUnlock;
  end;
  {$ENDIF THREADSAFE}
end;

{$JPPEXPANDMACRO KEYSCOMPARE}
function SELFCLASSNAME.KeySet: KEYSETINTERFACENAME;
var
  Index: Integer;
begin
  {$IFDEF THREADSAFE}
  ReadLock;
  try
  {$ENDIF THREADSAFE}
    Result := {$JPPEXPANDMACRO CREATEEMPTYARRAYSET(FSize)};
    for Index := 0 to FSize - 1 do
      Result.Add(FEntries[Index].Key);
  {$IFDEF THREADSAFE}
  finally
    ReadUnlock;
  end;
  {$ENDIF THREADSAFE}
end;

function SELFCLASSNAME.LastKey: KEYTYPENAME;
begin
  {$IFDEF THREADSAFE}
  ReadLock;
  try
  {$ENDIF THREADSAFE}
    Result := KEYDEFAULT;
    if FSize > 0 then
      Result := FEntries[FSize - 1].Key
    else
    if not FReturnDefaultElements then
      raise EJclNoSuchElementError.Create('');
  {$IFDEF THREADSAFE}
  finally
    ReadUnlock;
  end;
  {$ENDIF THREADSAFE}
end;

procedure SELFCLASSNAME.MoveArray(FromIndex, ToIndex, Count: Integer);
{$IFDEF CLR}
var
  I: Integer;
begin
  if FromIndex < ToIndex then
  begin
    for I := Count - 1 downto 0 do
      FEntries[ToIndex + I] := FEntries[FromIndex + I];
    if (ToIndex - FromIndex) < Count then
      // overlapped source and target
      for I := 0 to ToIndex - FromIndex - 1 do
      begin
        FEntries[FromIndex + I].Key := KEYDEFAULT;
        FEntries[FromIndex + I].Value := VALUEDEFAULT;
      end
    else
      // independant
      for I := 0 to Count - 1 do
      begin
        FEntries[FromIndex + I].Key := KEYDEFAULT;
        FEntries[FromIndex + I].Value := VALUEDEFAULT;
      end;
  end
  else
  if FromIndex > ToIndex then
  begin
    for I := 0 to Count - 1 do
      FEntries[ToIndex + I] := FEntries[FromIndex + I];
    if (FromIndex - ToIndex) < Count then
      // overlapped source and target
      for I := Count - FromIndex + ToIndex to Count - 1 do
      begin
        FEntries[FromIndex + I].Key := KEYDEFAULT;
        FEntries[FromIndex + I].Value := VALUEDEFAULT;
      end
    else
      // independant
      for I := 0 to Count - 1 do
      begin
        FEntries[FromIndex + I].Key := KEYDEFAULT;
        FEntries[FromIndex + I].Value := VALUEDEFAULT;
      end;
  end;
end;
{$ELSE}
begin
  if Count > 0 then
  begin
    Move(FEntries[FromIndex], FEntries[ToIndex], Count * SizeOf(FEntries[0]));
    { Keep reference counting working }
    if FromIndex < ToIndex then
    begin
      if (ToIndex - FromIndex) < Count then
        FillChar(FEntries[FromIndex], (ToIndex - FromIndex) * SizeOf(FEntries[0]), 0)
      else
        FillChar(FEntries[FromIndex], Count * SizeOf(FEntries[0]), 0);
    end
    else
    if FromIndex > ToIndex then
    begin
      if (FromIndex - ToIndex) < Count then
        FillChar(FEntries[ToIndex + Count], (FromIndex - ToIndex) * SizeOf(FEntries[0]), 0)
      else
        FillChar(FEntries[FromIndex], Count * SizeOf(FEntries[0]), 0);
    end;
  end;
end;
{$ENDIF CLR}

procedure SELFCLASSNAME.PutAll(const AMap: STDMAPINTERFACENAME);
var
  It: KEYITRINTERFACENAME;
  Key: KEYTYPENAME;
begin
  {$IFDEF THREADSAFE}
  WriteLock;
  try
  {$ENDIF THREADSAFE}
    if AMap = nil then
      Exit;
    It := AMap.KeySet.First;
    while It.HasNext do
    begin
      Key := It.Next;
      PutValue(Key, AMap.GetValue(Key));
    end;
  {$IFDEF THREADSAFE}
  finally
    WriteUnlock;
  end;
  {$ENDIF THREADSAFE}
end;

procedure SELFCLASSNAME.PutValue(KEYPARAMETERDECLARATION; VALUEPARAMETERDECLARATION);
var
  Index: Integer;
begin
  {$IFDEF THREADSAFE}
  WriteLock;
  try
  {$ENDIF THREADSAFE}
    if FAllowDefaultElements or ((KeysCompare(Key, KEYDEFAULT) <> 0) and (ValuesCompare(Value, VALUEDEFAULT) <> 0)) then
    begin
      Index := BinarySearch(Key);

      if (Index >= 0) and (KeysCompare(FEntries[Index].Key, Key) = 0) then
      begin
        FreeValue(FEntries[Index].Value);
        FEntries[Index].Value := Value;
      end
      else
      begin
        if FSize = FCapacity then
          AutoGrow;
        if FSize < FCapacity then
        begin
          Inc(Index);
          if (Index < FSize) and (KeysCompare(FEntries[Index].Key, Key) <> 0) then
            MoveArray(Index, Index + 1, FSize - Index);
          FEntries[Index].Key := Key;
          FEntries[Index].Value := Value;
          Inc(FSize);
        end;
      end;
    end;
  {$IFDEF THREADSAFE}
  finally
    WriteUnlock;
  end;
  {$ENDIF THREADSAFE}
end;

function SELFCLASSNAME.Remove(KEYPARAMETERDECLARATION): VALUETYPENAME;
var
  Index: Integer;
begin
  {$IFDEF THREADSAFE}
  WriteLock;
  try
  {$ENDIF THREADSAFE}
    Index := BinarySearch(Key);
    if (Index >= 0) and (KeysCompare(FEntries[Index].Key, Key) = 0) then
    begin
      Result := FreeValue(FEntries[Index].Value);
      FreeKey(FEntries[Index].Key);
      if Index < (FSize - 1) then
        MoveArray(Index + 1, Index, FSize - Index - 1);
      Dec(FSize);
      AutoPack;
    end
    else
      Result := VALUEDEFAULT;
  {$IFDEF THREADSAFE}
  finally
    WriteUnlock;
  end;
  {$ENDIF THREADSAFE}
end;

procedure SELFCLASSNAME.SetCapacity(Value: Integer);
begin
  {$IFDEF THREADSAFE}
  WriteLock;
  try
  {$ENDIF THREADSAFE}
    if FSize <= Value then
    begin
      SetLength(FEntries, Value);
      inherited SetCapacity(Value);
    end
    else
      raise EJclOperationNotSupportedError.Create;
  {$IFDEF THREADSAFE}
  finally
    WriteUnlock;
  end;
  {$ENDIF THREADSAFE}
end;

function SELFCLASSNAME.Size: Integer;
begin
  Result := FSize;
end;

function SELFCLASSNAME.SubMap(SUBMAPPARAMETERDECLARATION): SORTEDMAPINTERFACENAME;
var
  FromIndex, ToIndex: Integer;
  NewMap: SELFCLASSNAME;
begin
  {$IFDEF THREADSAFE}
  ReadLock;
  try
  {$ENDIF THREADSAFE}
    NewMap := CreateEmptyContainer as SELFCLASSNAME;
    FromIndex := BinarySearch(FromKey);
    if (FromIndex = -1) or (KeysCompare(FEntries[FromIndex].Key, FromKey) < 0) then
      Inc(FromIndex);
    ToIndex := BinarySearch(ToKey);
    if (FromIndex >= 0) and (FromIndex <= ToIndex) then
    begin
      NewMap.SetCapacity(ToIndex - FromIndex + 1);
      NewMap.FEntries := Copy(FEntries, FromIndex, ToIndex - FromIndex + 1);
      NewMap.FSize := ToIndex - FromIndex + 1;
    end;
    Result := NewMap;
  {$IFDEF THREADSAFE}
  finally
    ReadUnlock;
  end;
  {$ENDIF THREADSAFE}
end;

function SELFCLASSNAME.TailMap(TAILMAPPARAMETERDECLARATION): SORTEDMAPINTERFACENAME;
var
  FromIndex: Integer;
  NewMap: SELFCLASSNAME;
begin
  {$IFDEF THREADSAFE}
  ReadLock;
  try
  {$ENDIF THREADSAFE}
    NewMap := CreateEmptyContainer as SELFCLASSNAME;
    FromIndex := BinarySearch(FromKey);
    if (FromIndex = -1) or (KeysCompare(FEntries[FromIndex].Key, FromKey) < 0) then
      Inc(FromIndex);
    if (FromIndex >= 0) and (FromIndex < FSize) then
    begin
      NewMap.SetCapacity(FSize - FromIndex);
      NewMap.FEntries := Copy(FEntries, FromIndex, FSize - FromIndex);
      NewMap.FSize := FSize - FromIndex;
    end;
    Result := NewMap;
  {$IFDEF THREADSAFE}
  finally
    ReadUnlock;
  end;
  {$ENDIF THREADSAFE}
end;

function SELFCLASSNAME.Values: VALUECOLLECTIONINTERFACENAME;
var
  Index: Integer;
begin
  {$IFDEF THREADSAFE}
  ReadLock;
  try
  {$ENDIF THREADSAFE}
    Result := {$JPPEXPANDMACRO CREATEEMPTYARRAYLIST(FSize)};
    for Index := 0 to FSize - 1 do
      Result.Add(FEntries[Index].Value);
  {$IFDEF THREADSAFE}
  finally
    ReadUnlock;
  end;
  {$ENDIF THREADSAFE}
end;

{$JPPEXPANDMACRO VALUESCOMPARE}*)