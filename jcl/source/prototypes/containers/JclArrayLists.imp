(*$JPPDEFINEMACRO JCLARRAYLISTINT(SELFCLASSNAME, ANCESTORCLASSNAME, COLLECTIONINTERFACENAME, LISTINTERFACENAME, ARRAYINTERFACENAME, ITRINTERFACENAME,
  DYNARRAYTYPE, INTERFACELISTADDITIONAL, PRIVATEADDITIONAL, PROTECTEDADDITIONAL, PUBLICADDITIONAL, COLLECTIONFLAGS,
  OWNERSHIPDECLARATION, PARAMETERDECLARATION, TYPENAME, GETTERNAME, SETTERNAME)
  SELFCLASSNAME = class(ANCESTORCLASSNAME, COLLECTIONINTERFACENAME, LISTINTERFACENAME, ARRAYINTERFACENAME,INTERFACELISTADDITIONAL
    {$IFDEF THREADSAFE} IJclLockable, {$ENDIF THREADSAFE} IJclIntfCloneable, IJclCloneable, IJclPackable, IJclGrowable)
  private
    FElementData: DYNARRAYTYPE;PRIVATEADDITIONAL
  protected
    procedure AssignDataTo(Dest: TJclAbstractContainer); override;
    { IJclPackable }
    procedure SetCapacity(Value: Integer); override;
    { IJclIntfCloneable }
    function IJclIntfCloneable.Clone = IntfClone;
    { COLLECTIONINTERFACENAME }
    function Add(PARAMETERDECLARATION): Boolean;COLLECTIONFLAGS
    function AddAll(const ACollection: COLLECTIONINTERFACENAME): Boolean;COLLECTIONFLAGS
    procedure Clear;COLLECTIONFLAGS
    function Contains(PARAMETERDECLARATION): Boolean;COLLECTIONFLAGS
    function ContainsAll(const ACollection: COLLECTIONINTERFACENAME): Boolean;COLLECTIONFLAGS
    function Equals(const ACollection: COLLECTIONINTERFACENAME): Boolean;COLLECTIONFLAGS
    function First: ITRINTERFACENAME;COLLECTIONFLAGS
    function IsEmpty: Boolean;COLLECTIONFLAGS
    function Last: ITRINTERFACENAME;COLLECTIONFLAGS
    function Remove(PARAMETERDECLARATION): Boolean; overload;COLLECTIONFLAGS
    function RemoveAll(const ACollection: COLLECTIONINTERFACENAME): Boolean;COLLECTIONFLAGS
    function RetainAll(const ACollection: COLLECTIONINTERFACENAME): Boolean;COLLECTIONFLAGS
    function Size: Integer;COLLECTIONFLAGS
    { LISTINTERFACENAME }
    function Insert(Index: Integer; PARAMETERDECLARATION): Boolean;
    function InsertAll(Index: Integer; const ACollection: COLLECTIONINTERFACENAME): Boolean;
    function GETTERNAME(Index: Integer): TYPENAME;
    function IndexOf(PARAMETERDECLARATION): Integer;
    function LastIndexOf(PARAMETERDECLARATION): Integer;
    function Remove(Index: Integer): TYPENAME; overload;
    procedure SETTERNAME(Index: Integer; PARAMETERDECLARATION);
    function SubList(First, Count: Integer): LISTINTERFACENAME;PROTECTEDADDITIONAL
  public
    constructor Create(ACapacity: IntegerOWNERSHIPDECLARATION); overload;
    constructor Create(const ACollection: COLLECTIONINTERFACENAMEOWNERSHIPDECLARATION); overload;
    destructor Destroy; override;PUBLICADDITIONAL
  end;*)
(*$JPPDEFINEMACRO JCLARRAYLISTITR(SELFCLASSNAME, ITRINTERFACENAME, LISTINTERFACENAME,
  PARAMETERDECLARATION, PARAMETERNAME, TYPENAME, GETTERNAME, SETTERNAME)
//=== { SELFCLASSNAME } ===============================================================

type
  SELFCLASSNAME = class(TJclAbstractIterator, ITRINTERFACENAME, {$IFDEF THREADSAFE} IJclLockable, {$ENDIF THREADSAFE}
    IJclIntfCloneable, IJclCloneable)
  private
    FCursor: Integer;
    FOwnList: LISTINTERFACENAME;
  protected
    procedure AssignPropertiesTo(Dest: TJclAbstractIterator); override;
    function CreateEmptyIterator: TJclAbstractIterator; override;
    { IJclIntfCloneable }
    function IJclIntfCloneable.Clone = IntfClone;
    { ITRINTERFACENAME }
    function Add(PARAMETERDECLARATION): Boolean;
    function GETTERNAME: TYPENAME;
    function HasNext: Boolean;
    function HasPrevious: Boolean;
    function Insert(PARAMETERDECLARATION): Boolean;
    function Next: TYPENAME;
    function NextIndex: Integer;
    function Previous: TYPENAME;
    function PreviousIndex: Integer;
    procedure Remove;
    procedure SETTERNAME(PARAMETERDECLARATION);
  public
    constructor Create(const AOwnList: LISTINTERFACENAME; ACursor: Integer; AValid: Boolean);
  end;

constructor SELFCLASSNAME.Create(const AOwnList: LISTINTERFACENAME; ACursor: Integer; AValid: Boolean);
begin
  inherited Create(AOwnList, AValid);
  FOwnList := AOwnList;
  FCursor := ACursor;
end;

function SELFCLASSNAME.Add(PARAMETERDECLARATION): Boolean;
begin
  Result := FOwnList.Add(PARAMETERNAME);
end;

procedure SELFCLASSNAME.AssignPropertiesTo(Dest: TJclAbstractIterator);
var
  ADest: SELFCLASSNAME;
begin
  inherited AssignPropertiesTo(Dest);
  if Dest is SELFCLASSNAME then
  begin
    ADest := SELFCLASSNAME(Dest);
    ADest.FOwnList := FOwnList;
    ADest.FCursor := FCursor;
  end;
end;

function SELFCLASSNAME.CreateEmptyIterator: TJclAbstractIterator;
begin
  Result := SELFCLASSNAME.Create(FOwnList, FCursor, Valid);
end;

function SELFCLASSNAME.GETTERNAME: TYPENAME;
begin
  CheckValid;
  Result := FOwnList.GETTERNAME(FCursor);
end;

function SELFCLASSNAME.HasNext: Boolean;
begin
  if Valid then
    Result := FCursor < (FOwnList.Size - 1)
  else
    Result := FCursor < FOwnList.Size;
end;

function SELFCLASSNAME.HasPrevious: Boolean;
begin
  if Valid then
    Result := FCursor > 0
  else
    Result := FCursor >= 0;
end;

function SELFCLASSNAME.Insert(PARAMETERDECLARATION): Boolean;
begin
  CheckValid;
  Result := FOwnList.Insert(FCursor, PARAMETERNAME);
end;

function SELFCLASSNAME.Next: TYPENAME;
begin
  if Valid then
    Inc(FCursor)
  else
    Valid := True;
  Result := FOwnList.GETTERNAME(FCursor);
end;

function SELFCLASSNAME.NextIndex: Integer;
begin
  if Valid then
    Result := FCursor + 1
  else
    Result := FCursor;
end;

function SELFCLASSNAME.Previous: TYPENAME;
begin
  if Valid then
    Dec(FCursor)
  else
    Valid := True;
  Result := FOwnList.GETTERNAME(FCursor);
end;

function SELFCLASSNAME.PreviousIndex: Integer;
begin
  if Valid then
    Result := FCursor - 1
  else
    Result := FCursor;
end;

procedure SELFCLASSNAME.Remove;
begin
  CheckValid;
  Valid := False;
  FOwnList.Remove(FCursor);
end;

procedure SELFCLASSNAME.SETTERNAME(PARAMETERDECLARATION);
begin
  CheckValid;
  FOwnList.SETTERNAME(FCursor, PARAMETERNAME);
end;*)
(*$JPPDEFINEMACRO JCLARRAYLISTIMP(SELFCLASSNAME,
  OWNERSHIPDECLARATION, OWNERSHIPPARAMETER, COLLECTIONINTERFACENAME, ITRINTERFACENAME, ITRCLASSNAME, LISTINTERFACENAME,
  PARAMETERDECLARATION, PARAMETERNAME, GETTERNAME, SETTERNAME, RELEASERNAME, TYPENAME, DEFAULTVALUE, MOVEARRAY)
//=== { SELFCLASSNAME } ======================================================

constructor SELFCLASSNAME.Create(ACapacity: IntegerOWNERSHIPDECLARATION);
begin
  inherited Create(nilOWNERSHIPPARAMETER);
  FSize := 0;
  if ACapacity < 0 then
    FCapacity := 0
  else
    FCapacity := ACapacity;
  SetLength(FElementData, FCapacity);
end;

constructor SELFCLASSNAME.Create(const ACollection: COLLECTIONINTERFACENAMEOWNERSHIPDECLARATION);
begin
  // (rom) disabled because the following Create already calls inherited
  // inherited Create;
  if ACollection = nil then
    raise EJclNoCollectionError.Create;
  Create(ACollection.SizeOWNERSHIPPARAMETER);
  AddAll(ACollection);
end;

destructor SELFCLASSNAME.Destroy;
begin
  Clear;
  inherited Destroy;
end;

function SELFCLASSNAME.Add(PARAMETERDECLARATION): Boolean;
var
  Index: Integer;
begin
  {$IFDEF THREADSAFE}
  WriteLock;
  try
  {$ENDIF THREADSAFE}
    Result := FAllowDefaultElements or not ItemsEqual(PARAMETERNAME, DEFAULTVALUE);
    if Result then
    begin
      if FDuplicates <> dupAccept then
        for Index := 0 to FSize - 1 do
          if ItemsEqual(PARAMETERNAME, FElementData[Index]) then
          begin
            Result := CheckDuplicate;
            Break;
          end;

      if Result then
      begin
        if FSize = FCapacity then
          AutoGrow;
        Result := FSize < FCapacity;
        if Result then
        begin
          FElementData[FSize] := PARAMETERNAME;
          Inc(FSize);
        end;
      end;
    end;
  {$IFDEF THREADSAFE}
  finally
    WriteUnlock;
  end;
  {$ENDIF THREADSAFE}
end;

function SELFCLASSNAME.AddAll(const ACollection: COLLECTIONINTERFACENAME): Boolean;
var
  It: ITRINTERFACENAME;
  Item: TYPENAME;
  AddItem: Boolean;
  Index: Integer;
begin
  {$IFDEF THREADSAFE}
  WriteLock;
  try
  {$ENDIF THREADSAFE}
    Result := False;
    if ACollection = nil then
      Exit;
    Result := True;
    It := ACollection.First;
    while It.HasNext do
    begin
      Item := It.Next;
      // (rom) inlining Add() gives about 5 percent performance increase
      AddItem := FAllowDefaultElements or not ItemsEqual(Item, DEFAULTVALUE);
      if AddItem then
      begin
        if FDuplicates <> dupAccept then
          for Index := 0 to FSize - 1 do
            if ItemsEqual(Item, FElementData[Index]) then
            begin
              AddItem := CheckDuplicate;
              Break;
            end;
        if AddItem then
        begin
          if FSize = FCapacity then
            AutoGrow;
          AddItem := FSize < FCapacity;
          if AddItem then
          begin
            FElementData[FSize] := Item;
            Inc(FSize);
          end;
        end;
      end;
      Result := Result and AddItem;
    end;
  {$IFDEF THREADSAFE}
  finally
    WriteUnlock;
  end;
  {$ENDIF THREADSAFE}
end;

procedure SELFCLASSNAME.AssignDataTo(Dest: TJclAbstractContainer);
var
  ADest: SELFCLASSNAME;
  ACollection: COLLECTIONINTERFACENAME;
begin
  inherited AssignDataTo(Dest);
  if Dest is SELFCLASSNAME then
  begin
    ADest := SELFCLASSNAME(Dest);
    ADest.Clear;
    ADest.AddAll(Self);
  end
  else
  if Supports(IInterface(Dest), COLLECTIONINTERFACENAME, ACollection) then
  begin
    ACollection.Clear;
    ACollection.AddAll(Self);
  end;
end;

procedure SELFCLASSNAME.Clear;
var
  I: Integer;
begin
  {$IFDEF THREADSAFE}
  WriteLock;
  try
  {$ENDIF THREADSAFE}
    for I := 0 to FSize - 1 do
      RELEASERNAME(FElementData[I]);
    FSize := 0;
    AutoPack;
  {$IFDEF THREADSAFE}
  finally
    WriteUnlock;
  end;
  {$ENDIF THREADSAFE}
end;

function SELFCLASSNAME.Contains(PARAMETERDECLARATION): Boolean;
var
  I: Integer;
begin
  {$IFDEF THREADSAFE}
  ReadLock;
  try
  {$ENDIF THREADSAFE}
    Result := False;
    for I := 0 to FSize - 1 do
      if ItemsEqual(FElementData[I], PARAMETERNAME) then
      begin
        Result := True;
        Break;
      end;
  {$IFDEF THREADSAFE}
  finally
    ReadUnlock;
  end;
  {$ENDIF THREADSAFE}
end;

function SELFCLASSNAME.ContainsAll(const ACollection: COLLECTIONINTERFACENAME): Boolean;
var
  It: ITRINTERFACENAME;
begin
  {$IFDEF THREADSAFE}
  ReadLock;
  try
  {$ENDIF THREADSAFE}
    Result := False;
    if ACollection = nil then
      Exit;
    Result := True;
    It := ACollection.First;
    while Result and It.HasNext do
      Result := Contains(It.Next);
  {$IFDEF THREADSAFE}
  finally
    ReadUnlock;
  end;
  {$ENDIF THREADSAFE}
end;

{$JPPEXPANDMACRO CREATEEMPTYCONTAINER}
function SELFCLASSNAME.Equals(const ACollection: COLLECTIONINTERFACENAME): Boolean;
var
  I: Integer;
  It: ITRINTERFACENAME;
begin
  {$IFDEF THREADSAFE}
  ReadLock;
  try
  {$ENDIF THREADSAFE}
    Result := False;
    if ACollection = nil then
      Exit;
    if FSize <> ACollection.Size then
      Exit;
    It := ACollection.First;
    for I := 0 to FSize - 1 do
      if not ItemsEqual(FElementData[I], It.Next) then
        Exit;
    Result := True;
  {$IFDEF THREADSAFE}
  finally
    ReadUnlock;
  end;
  {$ENDIF THREADSAFE}
end;

function SELFCLASSNAME.First: ITRINTERFACENAME;
begin
  Result := ITRCLASSNAME.Create(Self, 0, False);
end;

function SELFCLASSNAME.GETTERNAME(Index: Integer): TYPENAME;
begin
  {$IFDEF THREADSAFE}
  ReadLock;
  try
  {$ENDIF THREADSAFE}
    Result := DEFAULTVALUE;
    if (Index >= 0) or (Index < FSize) then
      Result := FElementData[Index]
    else
    if not FReturnDefaultElements then
      raise EJclNoSuchElementError.Create(IntToStr(Index));
  {$IFDEF THREADSAFE}
  finally
    ReadUnlock;
  end;
  {$ENDIF THREADSAFE}
end;

function SELFCLASSNAME.IndexOf(PARAMETERDECLARATION): Integer;
var
  I: Integer;
begin
  {$IFDEF THREADSAFE}
  ReadLock;
  try
  {$ENDIF THREADSAFE}
    Result := -1;
    for I := 0 to FSize - 1 do
      if ItemsEqual(FElementData[I], PARAMETERNAME) then
      begin
        Result := I;
        Break;
      end;
  {$IFDEF THREADSAFE}
  finally
    ReadUnlock;
  end;
  {$ENDIF THREADSAFE}
end;

function SELFCLASSNAME.Insert(Index: Integer; PARAMETERDECLARATION): Boolean;
begin
  {$IFDEF THREADSAFE}
  WriteLock;
  try
  {$ENDIF THREADSAFE}
    Result := FAllowDefaultElements or not ItemsEqual(PARAMETERNAME, DEFAULTVALUE);

    if (Index < 0) or (Index > FSize) then
      raise EJclOutOfBoundsError.Create;

    if Result then
    begin
      if FDuplicates <> dupAccept then
        for Index := 0 to FSize - 1 do
          if ItemsEqual(PARAMETERNAME, FElementData[Index]) then
          begin
            Result := CheckDuplicate;
            Break;
          end;

      if Result then
      begin
        if FSize = FCapacity then
          AutoGrow;
        Result := FSize < FCapacity;
        if Result then
        begin
          if Index < FSize then
            MOVEARRAY(FElementData, Index, Index + 1, FSize - Index);
          FElementData[Index] := PARAMETERNAME;
          Inc(FSize);
        end;
      end;
    end;
  {$IFDEF THREADSAFE}
  finally
    WriteUnlock;
  end;
  {$ENDIF THREADSAFE}
end;

function SELFCLASSNAME.InsertAll(Index: Integer; const ACollection: COLLECTIONINTERFACENAME): Boolean;
var
  It: ITRINTERFACENAME;
begin
  {$IFDEF THREADSAFE}
  WriteLock;
  try
  {$ENDIF THREADSAFE}
    Result := False;
    if (Index < 0) or (Index > FSize) then
      raise EJclOutOfBoundsError.Create;
    if ACollection = nil then
      Exit;

    Result := True;
    It := ACollection.Last;
    while It.HasPrevious do
      Result := Insert(Index, It.Previous) and Result;
  {$IFDEF THREADSAFE}
  finally
    WriteUnlock;
  end;
  {$ENDIF THREADSAFE}
end;

function SELFCLASSNAME.IsEmpty: Boolean;
begin
  Result := FSize = 0;
end;

function SELFCLASSNAME.Last: ITRINTERFACENAME;
begin
  Result := ITRCLASSNAME.Create(Self, FSize - 1, False);
end;

function SELFCLASSNAME.LastIndexOf(PARAMETERDECLARATION): Integer;
var
  I: Integer;
begin
  {$IFDEF THREADSAFE}
  ReadLock;
  try
  {$ENDIF THREADSAFE}
    Result := -1;
    for I := FSize - 1 downto 0 do
      if ItemsEqual(FElementData[I], PARAMETERNAME) then
      begin
        Result := I;
        Break;
      end;
  {$IFDEF THREADSAFE}
  finally
    ReadUnlock;
  end;
  {$ENDIF THREADSAFE}
end;

function SELFCLASSNAME.Remove(PARAMETERDECLARATION): Boolean;
var
  I: Integer;
begin
  {$IFDEF THREADSAFE}
  WriteLock;
  try
  {$ENDIF THREADSAFE}
    Result := False;
    for I := FSize - 1 downto 0 do
      if ItemsEqual(FElementData[I], PARAMETERNAME) then
      begin
        RELEASERNAME(FElementData[I]);
        if I < (FSize - 1) then
          MOVEARRAY(FElementData, I + 1, I, FSize - I - 1);
        Dec(FSize);
        Result := True;
        if FRemoveSingleElement then
          Break;
      end;
    AutoPack;
  {$IFDEF THREADSAFE}
  finally
    WriteUnlock;
  end;
  {$ENDIF THREADSAFE}
end;

function SELFCLASSNAME.Remove(Index: Integer): TYPENAME;
begin
  {$IFDEF THREADSAFE}
  WriteLock;
  try
  {$ENDIF THREADSAFE}
    if (Index < 0) or (Index >= FSize) then
      raise EJclOutOfBoundsError.Create;
    Result := RELEASERNAME(FElementData[Index]);
    if Index < (FSize - 1) then
      MOVEARRAY(FElementData, Index + 1, Index, FSize - Index - 1);
    Dec(FSize);
    AutoPack;
  {$IFDEF THREADSAFE}
  finally
    WriteUnlock;
  end;
  {$ENDIF THREADSAFE}
end;

function SELFCLASSNAME.RemoveAll(const ACollection: COLLECTIONINTERFACENAME): Boolean;
var
  It: ITRINTERFACENAME;
begin
  {$IFDEF THREADSAFE}
  WriteLock;
  try
  {$ENDIF THREADSAFE}
    Result := False;
    if ACollection = nil then
      Exit;
    Result := True;
    It := ACollection.First;
    while It.HasNext do
      Result := Remove(It.Next) and Result;
  {$IFDEF THREADSAFE}
  finally
    WriteUnlock;
  end;
  {$ENDIF THREADSAFE}
end;

function SELFCLASSNAME.RetainAll(const ACollection: COLLECTIONINTERFACENAME): Boolean;
var
  I: Integer;
begin
  {$IFDEF THREADSAFE}
  WriteLock;
  try
  {$ENDIF THREADSAFE}
    Result := False;
    if ACollection = nil then
      Exit;
    Result := True;
    for I := FSize - 1 downto 0 do
      if not ACollection.Contains(FElementData[I]) then
        Remove(I);
  {$IFDEF THREADSAFE}
  finally
    WriteUnlock;
  end;
  {$ENDIF THREADSAFE}
end;

procedure SELFCLASSNAME.SetCapacity(Value: Integer);
begin
  {$IFDEF THREADSAFE}
  WriteLock;
  try
  {$ENDIF THREADSAFE}
    if Value >= FSize then
    begin
      SetLength(FElementData, Value);
      inherited SetCapacity(Value);
    end
    else
      raise EJclOutOfBoundsError.Create;
  {$IFDEF THREADSAFE}
  finally
    WriteUnlock;
  end;
  {$ENDIF THREADSAFE}
end;

procedure SELFCLASSNAME.SETTERNAME(Index: Integer; PARAMETERDECLARATION);
var
  ReplaceItem: Boolean;
  I: Integer;
begin
  {$IFDEF THREADSAFE}
  WriteLock;
  try
  {$ENDIF THREADSAFE}
    if (Index < 0) or (Index >= FSize) then
      raise EJclOutOfBoundsError.Create;
    ReplaceItem := FAllowDefaultElements or not ItemsEqual(PARAMETERNAME, DEFAULTVALUE);
    if ReplaceItem then
    begin
      if FDuplicates <> dupAccept then
        for I := 0 to FSize - 1 do
          if ItemsEqual(FElementData[I], PARAMETERNAME) then
          begin
            ReplaceItem := CheckDuplicate;
            Break;
          end;
      if ReplaceItem then
      begin
        RELEASERNAME(FElementData[Index]);
        FElementData[Index] := PARAMETERNAME;
      end;
    end;
    if not ReplaceItem then
      Remove(Index);
  {$IFDEF THREADSAFE}
  finally
    WriteUnlock;
  end;
  {$ENDIF THREADSAFE}
end;

function SELFCLASSNAME.Size: Integer;
begin
  Result := FSize;
end;

function SELFCLASSNAME.SubList(First, Count: Integer): LISTINTERFACENAME;
var
  I: Integer;
  Last: Integer;
begin
  {$IFDEF THREADSAFE}
  ReadLock;
  try
  {$ENDIF THREADSAFE}
    Last := First + Count - 1;
    if Last >= FSize then
      Last := FSize - 1;
    Result := CreateEmptyContainer as LISTINTERFACENAME;
    for I := First to Last do
      Result.Add(FElementData[I]);
  {$IFDEF THREADSAFE}
  finally
    ReadUnlock;
  end;
  {$ENDIF THREADSAFE}
end;*)